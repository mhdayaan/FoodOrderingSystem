2023-11-14 12:22:25.141 PST [5042] LOG:  starting PostgreSQL 15.5 on aarch64-apple-darwin21.6.0, compiled by Apple clang version 14.0.0 (clang-1400.0.29.102), 64-bit
2023-11-14 12:22:25.144 PST [5042] LOG:  listening on IPv6 address "::1", port 5431
2023-11-14 12:22:25.144 PST [5042] LOG:  listening on IPv4 address "127.0.0.1", port 5431
2023-11-14 12:22:25.147 PST [5042] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5431"
2023-11-14 12:22:25.154 PST [5046] LOG:  database system was shut down at 2023-11-14 12:22:23 PST
2023-11-14 12:22:25.159 PST [5042] LOG:  database system is ready to accept connections
2023-11-14 12:22:25.243 PST [5050] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-11-14 12:23:02.387 PST [5061] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:23:02.387 PST [5061] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:23:02.451 PST [5061] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:02.451 PST [5061] DETAIL:  parameters: $1 = '7'
2023-11-14 12:23:02.451 PST [5061] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:02.451 PST [5061] DETAIL:  parameters: $1 = '1'
2023-11-14 12:23:02.451 PST [5061] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:02.451 PST [5061] DETAIL:  parameters: $1 = '5'
2023-11-14 12:23:02.451 PST [5061] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:02.451 PST [5061] DETAIL:  parameters: $1 = '4'
2023-11-14 12:23:02.452 PST [5061] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:02.452 PST [5061] DETAIL:  parameters: $1 = '2'
2023-11-14 12:23:02.452 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:02.452 PST [5061] DETAIL:  parameters: $1 = '6'
2023-11-14 12:23:02.452 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:02.452 PST [5061] DETAIL:  parameters: $1 = '3'
2023-11-14 12:23:02.454 PST [5061] LOG:  statement: SELECT fdc_id, description FROM food
2023-11-14 12:23:10.621 PST [5061] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:23:10.621 PST [5061] DETAIL:  parameters: $1 = '319906'
2023-11-14 12:23:10.674 PST [5061] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:23:10.674 PST [5061] DETAIL:  parameters: $1 = '319906'
2023-11-14 12:23:12.174 PST [5061] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:23:12.174 PST [5061] DETAIL:  parameters: $1 = '319906'
2023-11-14 12:23:12.187 PST [5061] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:23:12.187 PST [5061] DETAIL:  parameters: $1 = '319906'
2023-11-14 12:23:12.188 PST [5061] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:23:12.197 PST [5061] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:23:12.197 PST [5061] DETAIL:  parameters: $1 = '95', $2 = '5', $3 = '319906', $4 = '0.010', $5 = '1', $6 = '0.010', $7 = '2023-11-14'
2023-11-14 12:23:12.210 PST [5061] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-14 12:23:12.210 PST [5061] DETAIL:  parameters: $1 = '5', $2 = '2023-11-14'
2023-11-14 12:23:12.211 PST [5061] LOG:  execute <unnamed>: COMMIT
2023-11-14 12:23:15.231 PST [5061] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:23:15.232 PST [5061] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:23:15.232 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.232 PST [5061] DETAIL:  parameters: $1 = '7'
2023-11-14 12:23:15.232 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.232 PST [5061] DETAIL:  parameters: $1 = '1'
2023-11-14 12:23:15.233 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.233 PST [5061] DETAIL:  parameters: $1 = '5'
2023-11-14 12:23:15.233 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.233 PST [5061] DETAIL:  parameters: $1 = '4'
2023-11-14 12:23:15.233 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.233 PST [5061] DETAIL:  parameters: $1 = '2'
2023-11-14 12:23:15.234 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.234 PST [5061] DETAIL:  parameters: $1 = '6'
2023-11-14 12:23:15.234 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.234 PST [5061] DETAIL:  parameters: $1 = '3'
2023-11-14 12:23:15.234 PST [5061] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:23:15.234 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.234 PST [5061] DETAIL:  parameters: $1 = '7'
2023-11-14 12:23:15.234 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.234 PST [5061] DETAIL:  parameters: $1 = '1'
2023-11-14 12:23:15.235 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.235 PST [5061] DETAIL:  parameters: $1 = '5'
2023-11-14 12:23:15.235 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.235 PST [5061] DETAIL:  parameters: $1 = '4'
2023-11-14 12:23:15.235 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.235 PST [5061] DETAIL:  parameters: $1 = '2'
2023-11-14 12:23:15.235 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.235 PST [5061] DETAIL:  parameters: $1 = '6'
2023-11-14 12:23:15.235 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.235 PST [5061] DETAIL:  parameters: $1 = '3'
2023-11-14 12:23:15.235 PST [5061] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:23:15.236 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.236 PST [5061] DETAIL:  parameters: $1 = '7'
2023-11-14 12:23:15.236 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.236 PST [5061] DETAIL:  parameters: $1 = '1'
2023-11-14 12:23:15.236 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.236 PST [5061] DETAIL:  parameters: $1 = '5'
2023-11-14 12:23:15.236 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.236 PST [5061] DETAIL:  parameters: $1 = '4'
2023-11-14 12:23:15.236 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.236 PST [5061] DETAIL:  parameters: $1 = '2'
2023-11-14 12:23:15.237 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.237 PST [5061] DETAIL:  parameters: $1 = '6'
2023-11-14 12:23:15.237 PST [5061] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:23:15.237 PST [5061] DETAIL:  parameters: $1 = '3'
2023-11-14 12:23:15.238 PST [5061] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:23:15.238 PST [5061] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:23:15.238 PST [5061] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:23:15.238 PST [5061] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:23:15.239 PST [5061] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:23:15.239 PST [5061] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:23:18.456 PST [5061] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:23:18.456 PST [5061] DETAIL:  parameters: $1 = 'Ayaan                                                                                                                                                                                                                                                          '
2023-11-14 12:23:21.695 PST [5061] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-14 12:23:21.695 PST [5061] DETAIL:  parameters: $1 = '5', $2 = '2023-11-14'
2023-11-14 12:27:25.159 PST [5044] LOG:  checkpoint starting: time
2023-11-14 12:27:25.584 PST [5044] LOG:  checkpoint complete: wrote 7 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.406 s, sync=0.010 s, total=0.426 s; sync files=6, longest=0.006 s, average=0.002 s; distance=18 kB, estimate=18 kB
2023-11-14 12:35:42.811 PST [5314] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:35:42.811 PST [5314] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:35:42.815 PST [5314] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:35:42.815 PST [5314] DETAIL:  parameters: $1 = '7'
2023-11-14 12:35:42.815 PST [5314] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:35:42.815 PST [5314] DETAIL:  parameters: $1 = '1'
2023-11-14 12:35:42.816 PST [5314] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:35:42.816 PST [5314] DETAIL:  parameters: $1 = '5'
2023-11-14 12:35:42.816 PST [5314] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:35:42.816 PST [5314] DETAIL:  parameters: $1 = '4'
2023-11-14 12:35:42.816 PST [5314] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:35:42.816 PST [5314] DETAIL:  parameters: $1 = '2'
2023-11-14 12:35:42.817 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:35:42.817 PST [5314] DETAIL:  parameters: $1 = '6'
2023-11-14 12:35:42.817 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:35:42.817 PST [5314] DETAIL:  parameters: $1 = '3'
2023-11-14 12:35:42.820 PST [5314] LOG:  statement: SELECT fdc_id, description FROM food
2023-11-14 12:35:52.971 PST [5314] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:35:52.971 PST [5314] DETAIL:  parameters: $1 = '319907'
2023-11-14 12:35:52.996 PST [5314] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:35:52.996 PST [5314] DETAIL:  parameters: $1 = '319907'
2023-11-14 12:35:56.502 PST [5314] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:35:56.502 PST [5314] DETAIL:  parameters: $1 = '321677'
2023-11-14 12:35:56.518 PST [5314] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:35:56.518 PST [5314] DETAIL:  parameters: $1 = '321677'
2023-11-14 12:36:00.023 PST [5314] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:00.023 PST [5314] DETAIL:  parameters: $1 = '321810'
2023-11-14 12:36:00.038 PST [5314] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:00.038 PST [5314] DETAIL:  parameters: $1 = '321810'
2023-11-14 12:36:01.917 PST [5314] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:01.917 PST [5314] DETAIL:  parameters: $1 = '319907'
2023-11-14 12:36:01.931 PST [5314] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:01.931 PST [5314] DETAIL:  parameters: $1 = '319907'
2023-11-14 12:36:01.932 PST [5314] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:36:01.933 PST [5314] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:36:01.933 PST [5314] DETAIL:  parameters: $1 = '96', $2 = '6', $3 = '319907', $4 = '8.200', $5 = '1', $6 = '8.200', $7 = '2023-11-14'
2023-11-14 12:36:01.934 PST [5314] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:01.934 PST [5314] DETAIL:  parameters: $1 = '321677'
2023-11-14 12:36:01.946 PST [5314] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:01.946 PST [5314] DETAIL:  parameters: $1 = '321677'
2023-11-14 12:36:01.947 PST [5314] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:36:01.948 PST [5314] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:36:01.948 PST [5314] DETAIL:  parameters: $1 = '97', $2 = '6', $3 = '321677', $4 = '0', $5 = '1', $6 = '0.000', $7 = '2023-11-14'
2023-11-14 12:36:01.954 PST [5314] LOG:  execute _pg3_1: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:01.954 PST [5314] DETAIL:  parameters: $1 = '321810'
2023-11-14 12:36:01.967 PST [5314] LOG:  execute _pg3_2: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:01.967 PST [5314] DETAIL:  parameters: $1 = '321810'
2023-11-14 12:36:01.968 PST [5314] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:36:01.968 PST [5314] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:36:01.968 PST [5314] DETAIL:  parameters: $1 = '98', $2 = '6', $3 = '321810', $4 = '0', $5 = '1', $6 = '0.000', $7 = '2023-11-14'
2023-11-14 12:36:01.969 PST [5314] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-14 12:36:01.969 PST [5314] DETAIL:  parameters: $1 = '6', $2 = '2023-11-14'
2023-11-14 12:36:01.970 PST [5314] LOG:  execute <unnamed>: COMMIT
2023-11-14 12:36:10.206 PST [5314] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:36:10.206 PST [5314] LOG:  execute _pg3_1: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:10.206 PST [5314] DETAIL:  parameters: $1 = '319918'
2023-11-14 12:36:10.223 PST [5314] LOG:  execute _pg3_2: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:10.223 PST [5314] DETAIL:  parameters: $1 = '319918'
2023-11-14 12:36:11.542 PST [5314] LOG:  execute _pg3_1: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:11.542 PST [5314] DETAIL:  parameters: $1 = '319907'
2023-11-14 12:36:11.553 PST [5314] LOG:  execute _pg3_2: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:11.553 PST [5314] DETAIL:  parameters: $1 = '319907'
2023-11-14 12:36:11.555 PST [5314] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:36:11.555 PST [5314] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:36:11.555 PST [5314] DETAIL:  parameters: $1 = '99', $2 = '6', $3 = '319907', $4 = '8.200', $5 = '1', $6 = '8.200', $7 = '2023-11-14'
2023-11-14 12:36:11.556 PST [5314] LOG:  execute _pg3_1: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:11.556 PST [5314] DETAIL:  parameters: $1 = '321677'
2023-11-14 12:36:11.568 PST [5314] LOG:  execute _pg3_2: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:11.568 PST [5314] DETAIL:  parameters: $1 = '321677'
2023-11-14 12:36:11.570 PST [5314] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:36:11.570 PST [5314] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:36:11.570 PST [5314] DETAIL:  parameters: $1 = '100', $2 = '6', $3 = '321677', $4 = '0', $5 = '1', $6 = '0.000', $7 = '2023-11-14'
2023-11-14 12:36:11.571 PST [5314] LOG:  execute _pg3_1: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:11.571 PST [5314] DETAIL:  parameters: $1 = '321810'
2023-11-14 12:36:11.585 PST [5314] LOG:  execute _pg3_2: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:11.585 PST [5314] DETAIL:  parameters: $1 = '321810'
2023-11-14 12:36:11.586 PST [5314] LOG:  execute _pg3_3: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:36:11.587 PST [5314] LOG:  execute _pg3_4: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:36:11.587 PST [5314] DETAIL:  parameters: $1 = '101', $2 = '6', $3 = '321810', $4 = '0', $5 = '1', $6 = '0.000', $7 = '2023-11-14'
2023-11-14 12:36:11.587 PST [5314] LOG:  execute _pg3_1: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:36:11.587 PST [5314] DETAIL:  parameters: $1 = '319918'
2023-11-14 12:36:11.600 PST [5314] LOG:  execute _pg3_2: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:36:11.600 PST [5314] DETAIL:  parameters: $1 = '319918'
2023-11-14 12:36:11.601 PST [5314] LOG:  execute _pg3_3: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:36:11.602 PST [5314] LOG:  execute _pg3_4: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:36:11.602 PST [5314] DETAIL:  parameters: $1 = '102', $2 = '6', $3 = '319918', $4 = '258.000', $5 = '1', $6 = '258.000', $7 = '2023-11-14'
2023-11-14 12:36:11.602 PST [5314] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-14 12:36:11.602 PST [5314] DETAIL:  parameters: $1 = '6', $2 = '2023-11-14'
2023-11-14 12:36:11.602 PST [5314] LOG:  execute <unnamed>: COMMIT
2023-11-14 12:36:15.696 PST [5314] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:36:15.696 PST [5314] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:36:15.696 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.696 PST [5314] DETAIL:  parameters: $1 = '7'
2023-11-14 12:36:15.697 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.697 PST [5314] DETAIL:  parameters: $1 = '1'
2023-11-14 12:36:15.697 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.697 PST [5314] DETAIL:  parameters: $1 = '5'
2023-11-14 12:36:15.697 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.697 PST [5314] DETAIL:  parameters: $1 = '4'
2023-11-14 12:36:15.697 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.697 PST [5314] DETAIL:  parameters: $1 = '2'
2023-11-14 12:36:15.698 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.698 PST [5314] DETAIL:  parameters: $1 = '6'
2023-11-14 12:36:15.698 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.698 PST [5314] DETAIL:  parameters: $1 = '3'
2023-11-14 12:36:15.698 PST [5314] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:36:15.698 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.698 PST [5314] DETAIL:  parameters: $1 = '7'
2023-11-14 12:36:15.698 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.698 PST [5314] DETAIL:  parameters: $1 = '1'
2023-11-14 12:36:15.699 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.699 PST [5314] DETAIL:  parameters: $1 = '5'
2023-11-14 12:36:15.699 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.699 PST [5314] DETAIL:  parameters: $1 = '4'
2023-11-14 12:36:15.699 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.699 PST [5314] DETAIL:  parameters: $1 = '2'
2023-11-14 12:36:15.699 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.699 PST [5314] DETAIL:  parameters: $1 = '6'
2023-11-14 12:36:15.699 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.699 PST [5314] DETAIL:  parameters: $1 = '3'
2023-11-14 12:36:15.699 PST [5314] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:36:15.700 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.700 PST [5314] DETAIL:  parameters: $1 = '7'
2023-11-14 12:36:15.700 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.700 PST [5314] DETAIL:  parameters: $1 = '1'
2023-11-14 12:36:15.700 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.700 PST [5314] DETAIL:  parameters: $1 = '5'
2023-11-14 12:36:15.700 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.700 PST [5314] DETAIL:  parameters: $1 = '4'
2023-11-14 12:36:15.700 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.700 PST [5314] DETAIL:  parameters: $1 = '2'
2023-11-14 12:36:15.700 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.700 PST [5314] DETAIL:  parameters: $1 = '6'
2023-11-14 12:36:15.700 PST [5314] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:15.700 PST [5314] DETAIL:  parameters: $1 = '3'
2023-11-14 12:36:15.702 PST [5314] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:36:15.702 PST [5314] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:36:15.702 PST [5314] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:36:15.702 PST [5314] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:36:15.703 PST [5314] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:36:15.703 PST [5314] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:36:18.353 PST [5314] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:36:18.353 PST [5314] DETAIL:  parameters: $1 = 'muhammed                                                                                                                                                                                                                                                       '
2023-11-14 12:36:20.750 PST [5314] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-14 12:36:20.750 PST [5314] DETAIL:  parameters: $1 = '6', $2 = '2023-11-14'
2023-11-14 12:36:50.575 PST [5339] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:36:50.575 PST [5339] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:36:50.578 PST [5339] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:50.578 PST [5339] DETAIL:  parameters: $1 = '7'
2023-11-14 12:36:50.578 PST [5339] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:50.578 PST [5339] DETAIL:  parameters: $1 = '1'
2023-11-14 12:36:50.579 PST [5339] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:50.579 PST [5339] DETAIL:  parameters: $1 = '5'
2023-11-14 12:36:50.579 PST [5339] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:50.579 PST [5339] DETAIL:  parameters: $1 = '4'
2023-11-14 12:36:50.579 PST [5339] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:50.579 PST [5339] DETAIL:  parameters: $1 = '2'
2023-11-14 12:36:50.580 PST [5339] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:50.580 PST [5339] DETAIL:  parameters: $1 = '6'
2023-11-14 12:36:50.580 PST [5339] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:36:50.580 PST [5339] DETAIL:  parameters: $1 = '3'
2023-11-14 12:36:50.583 PST [5339] LOG:  statement: SELECT fdc_id, description FROM food
2023-11-14 12:37:25.542 PST [5044] LOG:  checkpoint starting: time
2023-11-14 12:37:26.267 PST [5044] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.708 s, sync=0.010 s, total=0.725 s; sync files=5, longest=0.006 s, average=0.002 s; distance=43 kB, estimate=43 kB
2023-11-14 12:39:53.005 PST [5395] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:39:53.005 PST [5395] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:39:53.009 PST [5395] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:39:53.009 PST [5395] DETAIL:  parameters: $1 = '7'
2023-11-14 12:39:53.010 PST [5395] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:39:53.010 PST [5395] DETAIL:  parameters: $1 = '1'
2023-11-14 12:39:53.010 PST [5395] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:39:53.010 PST [5395] DETAIL:  parameters: $1 = '5'
2023-11-14 12:39:53.010 PST [5395] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:39:53.010 PST [5395] DETAIL:  parameters: $1 = '4'
2023-11-14 12:39:53.010 PST [5395] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:39:53.010 PST [5395] DETAIL:  parameters: $1 = '2'
2023-11-14 12:39:53.011 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:39:53.011 PST [5395] DETAIL:  parameters: $1 = '6'
2023-11-14 12:39:53.011 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:39:53.011 PST [5395] DETAIL:  parameters: $1 = '3'
2023-11-14 12:39:53.013 PST [5395] LOG:  statement: SELECT fdc_id, description FROM food
2023-11-14 12:40:05.049 PST [5395] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:40:05.049 PST [5395] DETAIL:  parameters: $1 = '320017'
2023-11-14 12:40:05.072 PST [5395] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:40:05.072 PST [5395] DETAIL:  parameters: $1 = '320017'
2023-11-14 12:40:06.570 PST [5395] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-14 12:40:06.570 PST [5395] DETAIL:  parameters: $1 = '320017'
2023-11-14 12:40:06.581 PST [5395] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-14 12:40:06.581 PST [5395] DETAIL:  parameters: $1 = '320017'
2023-11-14 12:40:06.583 PST [5395] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-14 12:40:06.584 PST [5395] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-14 12:40:06.584 PST [5395] DETAIL:  parameters: $1 = '103', $2 = '1', $3 = '320017', $4 = '0.820', $5 = '1', $6 = '0.820', $7 = '2023-11-14'
2023-11-14 12:40:06.585 PST [5395] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-14 12:40:06.585 PST [5395] DETAIL:  parameters: $1 = '1', $2 = '2023-11-14'
2023-11-14 12:40:06.585 PST [5395] LOG:  execute <unnamed>: COMMIT
2023-11-14 12:40:08.856 PST [5395] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:40:08.856 PST [5395] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:40:08.857 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.857 PST [5395] DETAIL:  parameters: $1 = '7'
2023-11-14 12:40:08.858 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.858 PST [5395] DETAIL:  parameters: $1 = '1'
2023-11-14 12:40:08.858 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.858 PST [5395] DETAIL:  parameters: $1 = '5'
2023-11-14 12:40:08.858 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.858 PST [5395] DETAIL:  parameters: $1 = '4'
2023-11-14 12:40:08.859 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.859 PST [5395] DETAIL:  parameters: $1 = '2'
2023-11-14 12:40:08.859 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.859 PST [5395] DETAIL:  parameters: $1 = '6'
2023-11-14 12:40:08.859 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.859 PST [5395] DETAIL:  parameters: $1 = '3'
2023-11-14 12:40:08.859 PST [5395] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:40:08.860 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.860 PST [5395] DETAIL:  parameters: $1 = '7'
2023-11-14 12:40:08.860 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.860 PST [5395] DETAIL:  parameters: $1 = '1'
2023-11-14 12:40:08.860 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.860 PST [5395] DETAIL:  parameters: $1 = '5'
2023-11-14 12:40:08.861 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.861 PST [5395] DETAIL:  parameters: $1 = '4'
2023-11-14 12:40:08.861 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.861 PST [5395] DETAIL:  parameters: $1 = '2'
2023-11-14 12:40:08.861 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.861 PST [5395] DETAIL:  parameters: $1 = '6'
2023-11-14 12:40:08.861 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.861 PST [5395] DETAIL:  parameters: $1 = '3'
2023-11-14 12:40:08.861 PST [5395] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:40:08.862 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.862 PST [5395] DETAIL:  parameters: $1 = '7'
2023-11-14 12:40:08.862 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.862 PST [5395] DETAIL:  parameters: $1 = '1'
2023-11-14 12:40:08.862 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.862 PST [5395] DETAIL:  parameters: $1 = '5'
2023-11-14 12:40:08.863 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.863 PST [5395] DETAIL:  parameters: $1 = '4'
2023-11-14 12:40:08.863 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.863 PST [5395] DETAIL:  parameters: $1 = '2'
2023-11-14 12:40:08.863 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.863 PST [5395] DETAIL:  parameters: $1 = '6'
2023-11-14 12:40:08.863 PST [5395] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:40:08.863 PST [5395] DETAIL:  parameters: $1 = '3'
2023-11-14 12:40:08.865 PST [5395] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:40:08.865 PST [5395] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:40:08.866 PST [5395] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:40:08.866 PST [5395] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:40:08.866 PST [5395] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:40:08.866 PST [5395] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-14 12:40:11.342 PST [5395] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-14 12:40:11.342 PST [5395] DETAIL:  parameters: $1 = 'A                                                                                                                                                                                                                                                              '
2023-11-14 12:40:13.650 PST [5395] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-14 12:40:13.650 PST [5395] DETAIL:  parameters: $1 = '1', $2 = '2023-11-10'
2023-11-14 12:42:25.269 PST [5044] LOG:  checkpoint starting: time
2023-11-14 12:42:25.688 PST [5044] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.404 s, sync=0.006 s, total=0.420 s; sync files=5, longest=0.003 s, average=0.002 s; distance=18 kB, estimate=41 kB
2023-11-14 12:43:04.008 PST [5469] LOG:  execute <unnamed>: BEGIN
2023-11-14 12:43:04.008 PST [5469] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-14 12:43:04.012 PST [5469] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:43:04.012 PST [5469] DETAIL:  parameters: $1 = '7'
2023-11-14 12:43:04.012 PST [5469] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:43:04.012 PST [5469] DETAIL:  parameters: $1 = '1'
2023-11-14 12:43:04.013 PST [5469] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:43:04.013 PST [5469] DETAIL:  parameters: $1 = '5'
2023-11-14 12:43:04.013 PST [5469] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:43:04.013 PST [5469] DETAIL:  parameters: $1 = '4'
2023-11-14 12:43:04.014 PST [5469] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:43:04.014 PST [5469] DETAIL:  parameters: $1 = '2'
2023-11-14 12:43:04.014 PST [5469] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:43:04.014 PST [5469] DETAIL:  parameters: $1 = '6'
2023-11-14 12:43:04.014 PST [5469] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-14 12:43:04.014 PST [5469] DETAIL:  parameters: $1 = '3'
2023-11-14 12:43:04.023 PST [5469] LOG:  statement: SELECT fdc_id, description FROM food
2023-11-14 12:43:43.948 PST [5487] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-11-14 12:43:43.998 PST [5488] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-11-14 12:43:48.886 PST [5042] LOG:  received fast shutdown request
2023-11-14 12:43:48.887 PST [5042] LOG:  aborting any active transactions
2023-11-14 12:43:48.889 PST [5042] LOG:  background worker "logical replication launcher" (PID 5049) exited with exit code 1
2023-11-14 12:43:48.889 PST [5044] LOG:  shutting down
2023-11-14 12:43:48.895 PST [5044] LOG:  checkpoint starting: shutdown immediate
2023-11-14 12:43:48.901 PST [5044] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.012 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=37 kB
2023-11-14 12:43:48.908 PST [5042] LOG:  database system is shut down
2023-11-17 16:04:28.235 PST [36660] LOG:  starting PostgreSQL 15.5 on aarch64-apple-darwin21.6.0, compiled by Apple clang version 14.0.0 (clang-1400.0.29.102), 64-bit
2023-11-17 16:04:28.238 PST [36660] LOG:  listening on IPv6 address "::1", port 5431
2023-11-17 16:04:28.238 PST [36660] LOG:  listening on IPv4 address "127.0.0.1", port 5431
2023-11-17 16:04:28.240 PST [36660] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5431"
2023-11-17 16:04:28.259 PST [36664] LOG:  database system was shut down at 2023-11-14 12:43:48 PST
2023-11-17 16:04:28.276 PST [36660] LOG:  database system is ready to accept connections
2023-11-17 16:04:34.153 PST [36671] LOG:  execute <unnamed>: BEGIN
2023-11-17 16:04:34.154 PST [36671] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-17 16:04:34.214 PST [36671] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:34.214 PST [36671] DETAIL:  parameters: $1 = '7'
2023-11-17 16:04:34.215 PST [36671] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:34.215 PST [36671] DETAIL:  parameters: $1 = '1'
2023-11-17 16:04:34.215 PST [36671] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:34.215 PST [36671] DETAIL:  parameters: $1 = '5'
2023-11-17 16:04:34.215 PST [36671] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:34.215 PST [36671] DETAIL:  parameters: $1 = '4'
2023-11-17 16:04:34.216 PST [36671] LOG:  execute <unnamed>: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:34.216 PST [36671] DETAIL:  parameters: $1 = '2'
2023-11-17 16:04:34.216 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:34.216 PST [36671] DETAIL:  parameters: $1 = '6'
2023-11-17 16:04:34.216 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:34.216 PST [36671] DETAIL:  parameters: $1 = '3'
2023-11-17 16:04:34.218 PST [36671] LOG:  statement: SELECT fdc_id, description FROM food
2023-11-17 16:04:47.639 PST [36671] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-17 16:04:47.639 PST [36671] DETAIL:  parameters: $1 = '319915'
2023-11-17 16:04:47.700 PST [36671] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-17 16:04:47.700 PST [36671] DETAIL:  parameters: $1 = '319915'
2023-11-17 16:04:51.552 PST [36671] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-17 16:04:51.552 PST [36671] DETAIL:  parameters: $1 = '321430'
2023-11-17 16:04:51.567 PST [36671] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-17 16:04:51.567 PST [36671] DETAIL:  parameters: $1 = '321430'
2023-11-17 16:04:53.065 PST [36671] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-17 16:04:53.065 PST [36671] DETAIL:  parameters: $1 = '319915'
2023-11-17 16:04:53.083 PST [36671] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-17 16:04:53.083 PST [36671] DETAIL:  parameters: $1 = '319915'
2023-11-17 16:04:53.084 PST [36671] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-17 16:04:53.094 PST [36671] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-17 16:04:53.094 PST [36671] DETAIL:  parameters: $1 = '104', $2 = '5', $3 = '319915', $4 = '5.700', $5 = '1', $6 = '5.700', $7 = '2023-11-17'
2023-11-17 16:04:53.105 PST [36671] LOG:  execute <unnamed>: SELECT amount FROM food_nutrient WHERE fdc_id = $1
2023-11-17 16:04:53.105 PST [36671] DETAIL:  parameters: $1 = '321430'
2023-11-17 16:04:53.118 PST [36671] LOG:  execute <unnamed>: SELECT sum(amount) FROM food_portions WHERE fdc_id = $1
2023-11-17 16:04:53.118 PST [36671] DETAIL:  parameters: $1 = '321430'
2023-11-17 16:04:53.119 PST [36671] LOG:  statement: SELECT max(id) FROM user_nutrients_log
2023-11-17 16:04:53.120 PST [36671] LOG:  execute <unnamed>: INSERT INTO user_nutrients_log (id, user_id, fdc_id, amount, portion_amount, total_amount_nutrients, log_date) VALUES ($1, $2, $3, $4, $5, $6, $7)
2023-11-17 16:04:53.120 PST [36671] DETAIL:  parameters: $1 = '105', $2 = '5', $3 = '321430', $4 = '0', $5 = '1.000', $6 = '0.000', $7 = '2023-11-17'
2023-11-17 16:04:53.122 PST [36671] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-17 16:04:53.122 PST [36671] DETAIL:  parameters: $1 = '5', $2 = '2023-11-17'
2023-11-17 16:04:53.123 PST [36671] LOG:  execute <unnamed>: COMMIT
2023-11-17 16:04:57.245 PST [36671] LOG:  execute <unnamed>: BEGIN
2023-11-17 16:04:57.246 PST [36671] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-17 16:04:57.246 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.246 PST [36671] DETAIL:  parameters: $1 = '7'
2023-11-17 16:04:57.246 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.246 PST [36671] DETAIL:  parameters: $1 = '1'
2023-11-17 16:04:57.246 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.246 PST [36671] DETAIL:  parameters: $1 = '5'
2023-11-17 16:04:57.247 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.247 PST [36671] DETAIL:  parameters: $1 = '4'
2023-11-17 16:04:57.247 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.247 PST [36671] DETAIL:  parameters: $1 = '2'
2023-11-17 16:04:57.247 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.247 PST [36671] DETAIL:  parameters: $1 = '6'
2023-11-17 16:04:57.247 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.247 PST [36671] DETAIL:  parameters: $1 = '3'
2023-11-17 16:04:57.247 PST [36671] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-17 16:04:57.248 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.248 PST [36671] DETAIL:  parameters: $1 = '7'
2023-11-17 16:04:57.248 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.248 PST [36671] DETAIL:  parameters: $1 = '1'
2023-11-17 16:04:57.248 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.248 PST [36671] DETAIL:  parameters: $1 = '5'
2023-11-17 16:04:57.248 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.248 PST [36671] DETAIL:  parameters: $1 = '4'
2023-11-17 16:04:57.249 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.249 PST [36671] DETAIL:  parameters: $1 = '2'
2023-11-17 16:04:57.249 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.249 PST [36671] DETAIL:  parameters: $1 = '6'
2023-11-17 16:04:57.249 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.249 PST [36671] DETAIL:  parameters: $1 = '3'
2023-11-17 16:04:57.249 PST [36671] LOG:  statement: SELECT DISTINCT user_id FROM user_nutrients_log
2023-11-17 16:04:57.250 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.250 PST [36671] DETAIL:  parameters: $1 = '7'
2023-11-17 16:04:57.250 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.250 PST [36671] DETAIL:  parameters: $1 = '1'
2023-11-17 16:04:57.250 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.250 PST [36671] DETAIL:  parameters: $1 = '5'
2023-11-17 16:04:57.250 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.250 PST [36671] DETAIL:  parameters: $1 = '4'
2023-11-17 16:04:57.250 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.250 PST [36671] DETAIL:  parameters: $1 = '2'
2023-11-17 16:04:57.250 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.250 PST [36671] DETAIL:  parameters: $1 = '6'
2023-11-17 16:04:57.251 PST [36671] LOG:  execute _pg3_0: SELECT user_name FROM users WHERE id = $1
2023-11-17 16:04:57.251 PST [36671] DETAIL:  parameters: $1 = '3'
2023-11-17 16:04:57.257 PST [36671] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-17 16:04:57.257 PST [36671] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-17 16:04:57.258 PST [36671] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-17 16:04:57.258 PST [36671] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-17 16:04:57.258 PST [36671] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-17 16:04:57.258 PST [36671] DETAIL:  parameters: $1 = 'muhi                                                                                                                                                                                                                                                           '
2023-11-17 16:05:00.321 PST [36671] LOG:  execute <unnamed>: SELECT DISTINCT log_date FROM user_nutrients_log WHERE user_id = (SELECT id FROM users WHERE user_name = $1)
2023-11-17 16:05:00.321 PST [36671] DETAIL:  parameters: $1 = 'Ayaan                                                                                                                                                                                                                                                          '
2023-11-17 16:05:07.686 PST [36671] LOG:  execute <unnamed>: SELECT sum(total_amount_nutrients) FROM user_nutrients_log WHERE user_id = $1 AND log_date = $2
2023-11-17 16:05:07.686 PST [36671] DETAIL:  parameters: $1 = '5', $2 = '2023-11-09'
2023-11-17 16:09:28.261 PST [36662] LOG:  checkpoint starting: time
2023-11-17 16:09:28.790 PST [36662] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.510 s, sync=0.009 s, total=0.529 s; sync files=6, longest=0.003 s, average=0.002 s; distance=27 kB, estimate=27 kB
2023-11-18 21:15:03.731 PST [57245] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-11-18 21:15:06.319 PST [57253] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-11-18 21:15:06.344 PST [57254] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-11-18 21:15:06.536 PST [57256] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-11-18 21:15:06.601 PST [57257] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-03 18:54:46.128 PST [24233] FATAL:  database "Presentation" does not exist
2023-12-05 21:56:22.385 PST [66742] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-05 21:56:22.474 PST [66742] LOG:  statement: SELECT version()
2023-12-05 21:56:22.475 PST [66742] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-05 21:56:22.503 PST [66742] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-05 21:56:22.515 PST [66742] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-05 21:56:22.562 PST [66742] LOG:  statement: SELECT CASE WHEN usesuper
	       THEN pg_catalog.pg_is_in_recovery()
	       ELSE FALSE
	       END as inrecovery,
	       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
	       THEN pg_is_wal_replay_paused()
	       ELSE FALSE
	       END as isreplaypaused
	FROM pg_catalog.pg_user WHERE usename=current_user
2023-12-05 21:56:22.625 PST [66742] LOG:  statement: 
	SELECT
	    has_table_privilege(
	      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
	    ) has_priviledge
	WHERE EXISTS(
	    SELECT has_schema_privilege('pgagent', 'USAGE')
	    WHERE EXISTS(
	        SELECT cl.oid FROM pg_catalog.pg_class cl
	        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
	        WHERE relname='pga_job' AND nspname='pgagent'
	    )
	)
	
2023-12-05 21:56:22.675 PST [66742] LOG:  statement: SELECT
	    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
	    db.datistemplate AS is_template,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner,
	    descr.description
	FROM
	    pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE         db.oid > 16383::OID OR db.datname IN ('postgres', 'edb')
	
	ORDER BY datname;
2023-12-05 21:56:22.715 PST [66742] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16390
2023-12-05 21:56:22.717 PST [66742] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16390
2023-12-05 21:56:22.728 PST [66744] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-05 21:56:22.729 PST [66745] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-05 21:56:22.784 PST [66745] LOG:  statement: SELECT version()
2023-12-05 21:56:22.784 PST [66744] LOG:  statement: SELECT version()
2023-12-05 21:56:22.785 PST [66744] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-05 21:56:22.785 PST [66745] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-05 21:56:22.801 PST [66745] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-05 21:56:22.801 PST [66744] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-05 21:56:22.806 PST [66745] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-05 21:56:22.806 PST [66744] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-05 21:56:22.946 PST [66745] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-05 21:56:23.041 PST [66745] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-05 21:56:23.239 PST [66745] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-05 21:56:30.127 PST [66748] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:56:32.727 PST [66754] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:56:32.755 PST [66755] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:56:32.969 PST [66757] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:56:33.011 PST [66758] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:56:48.916 PST [66742] LOG:  statement: SELECT
	    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
	    db.datistemplate AS is_template,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner,
	    descr.description
	FROM
	    pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE         db.oid > 0::OID OR db.datname IN ('postgres', 'edb')
	
	ORDER BY datname;
2023-12-05 21:56:48.963 PST [66742] LOG:  statement: SELECT * FROM
	(SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
	FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
	WHERE encoding != '' ORDER BY encoding;
	
	
2023-12-05 21:56:48.974 PST [66742] LOG:  statement: SELECT pg_catalog.current_setting('lc_ctype') as cname
	UNION
	SELECT pg_catalog.current_setting('lc_collate') as cname
2023-12-05 21:56:48.977 PST [66742] LOG:  statement: SELECT
		r.oid, r.rolname, r.rolcanlogin, r.rolsuper,
		pg_catalog.shobj_description(r.oid, 'pg_authid') AS description
	FROM
		pg_catalog.pg_roles r
	ORDER BY r.rolcanlogin, r.rolname
2023-12-05 21:56:48.982 PST [66742] LOG:  statement: SELECT
	    ts.oid AS oid, spcname AS name, spcowner as owner,
	    pg_catalog.shobj_description(oid, 'pg_tablespace') AS description
	FROM
	    pg_catalog.pg_tablespace ts
	ORDER BY name;
2023-12-05 21:56:48.984 PST [66742] LOG:  statement: SELECT pg_catalog.current_setting('lc_ctype') as cname
	UNION
	SELECT pg_catalog.current_setting('lc_collate') as cname
2023-12-05 21:57:09.062 PST [66742] LOG:  statement: CREATE DATABASE "Final_Project"
	    WITH
	    OWNER = postgres
	    ENCODING = 'UTF8'
	    CONNECTION LIMIT = -1
	    IS_TEMPLATE = False;
	
2023-12-05 21:57:09.982 PST [66742] LOG:  statement: SELECT
	    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
	    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
	    pg_catalog.pg_get_userbyid(datdba) AS datowner,
	    (select pg_catalog.current_setting('lc_collate')) as datcollate,
	    (select pg_catalog.current_setting('lc_ctype')) as datctype,
	    datconnlimit,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
	    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
	    descr.description AS comments, db.datistemplate AS is_template,
	        '' AS tblacl,
	        '' AS seqacl,
	        '' AS funcacl,
	    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
	FROM pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE
	            db.datname = 'Final_Project'::text
	    
	
	ORDER BY datname;
2023-12-05 21:57:10.022 PST [66742] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-05 21:57:10.059 PST [66779] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-05 21:57:10.061 PST [66779] LOG:  statement: SELECT version()
2023-12-05 21:57:10.061 PST [66779] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-05 21:57:10.062 PST [66779] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-05 21:57:10.063 PST [66779] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-05 21:57:14.590 PST [66782] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:57:37.278 PST [66792] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:57:58.983 PST [36662] LOG:  checkpoint starting: time
2023-12-05 21:58:24.267 PST [66779] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-05 21:58:24.519 PST [66779] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-05 21:58:36.200 PST [66779] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-05 21:58:36.222 PST [66779] LOG:  statement: SELECT name, setting::numeric AS setting FROM pg_catalog.pg_settings WHERE name IN('autovacuum_vacuum_threshold','autovacuum_vacuum_scale_factor','autovacuum_vacuum_cost_delay','autovacuum_vacuum_cost_limit','autovacuum_freeze_max_age','vacuum_freeze_min_age','vacuum_freeze_table_age') ORDER BY name
2023-12-05 21:58:36.225 PST [66779] LOG:  statement: SELECT name, setting::numeric AS setting FROM pg_catalog.pg_settings WHERE name IN('autovacuum_vacuum_threshold','autovacuum_analyze_threshold','autovacuum_vacuum_scale_factor','autovacuum_analyze_scale_factor','autovacuum_vacuum_cost_delay','autovacuum_vacuum_cost_limit','autovacuum_freeze_max_age','vacuum_freeze_min_age','vacuum_freeze_table_age') ORDER BY name
2023-12-05 21:58:36.262 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 21:58:36.266 PST [66779] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-05 21:58:36.269 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 21:58:40.696 PST [66832] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 21:59:27.469 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 21:59:33.422 PST [36662] LOG:  checkpoint complete: wrote 937 buffers (5.7%); 0 WAL file(s) added, 0 removed, 0 recycled; write=94.391 s, sync=0.037 s, total=94.439 s; sync files=300, longest=0.006 s, average=0.001 s; distance=4290 kB, estimate=4290 kB
2023-12-05 21:59:45.182 PST [66865] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 22:00:36.844 PST [66885] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 22:00:53.479 PST [66892] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 22:02:14.579 PST [66779] LOG:  statement: CREATE TABLE public.restaurants
	(
	    id character varying(20) NOT NULL,
	    name character(255),
	    address character varying(255),
	    category character(50),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.restaurants
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-05 22:02:14.615 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'restaurants'::text AND nspname = 'public';
	
2023-12-05 22:02:14.628 PST [66779] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'restaurants'
2023-12-05 22:02:14.676 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-05 22:02:58.421 PST [36662] LOG:  checkpoint starting: time
2023-12-05 22:03:02.096 PST [36662] LOG:  checkpoint complete: wrote 37 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.653 s, sync=0.016 s, total=3.676 s; sync files=35, longest=0.006 s, average=0.001 s; distance=172 kB, estimate=3878 kB
2023-12-05 22:05:41.364 PST [67021] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-05 22:07:17.362 PST [66742] LOG:  statement: SELECT * FROM
	(SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
	FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
	WHERE encoding != '' ORDER BY encoding;
	
	
2023-12-05 22:07:17.390 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16465::oid
2023-12-05 22:07:17.411 PST [66779] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:07:42.740 PST [67091] LOG:  statement: COPY  public.restaurants ( id, name, address, category ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:07:42.741 PST [67091] ERROR:  value too long for type character(50)
2023-12-05 22:07:42.741 PST [67091] CONTEXT:  COPY restaurants, line 9, column category: "Vegetarian, Asian, Asian Fusion, Chinese, Indian, Healthy"
2023-12-05 22:07:42.741 PST [67091] STATEMENT:  COPY  public.restaurants ( id, name, address, category ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:07:58.092 PST [36662] LOG:  checkpoint starting: time
2023-12-05 22:07:58.421 PST [36662] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.311 s, sync=0.007 s, total=0.329 s; sync files=2, longest=0.006 s, average=0.004 s; distance=24 kB, estimate=3493 kB
2023-12-05 22:07:58.904 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:07:58.918 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:07:58.943 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-05 22:07:59.016 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:07:59.019 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:07:59.033 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:07:59.070 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1042)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:07:59.103 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:07:59.105 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:07:59.107 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:07:59.109 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:07:59.117 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:07:59.136 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16470 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:07:59.149 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16470::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:07:59.151 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:07:59.169 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16465::oid
	ORDER BY conname
2023-12-05 22:07:59.212 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16465::oid
	
2023-12-05 22:07:59.238 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:07:59.398 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:07:59.420 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:07:59.437 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:07:59.451 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:08:08.330 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-05 22:08:08.338 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:08.424 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 22:08:08.426 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16465::oid;
	
2023-12-05 22:08:08.439 PST [66779] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-05 22:08:08.452 PST [66779] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16465::oid;
2023-12-05 22:08:08.453 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:08.455 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:08:08.463 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1042)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:08:08.465 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:08.467 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:08.468 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:08.469 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:08.470 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:08:08.473 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16470 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:08:08.474 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16470::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:08:08.475 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:08:08.478 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16465::oid
	ORDER BY conname
2023-12-05 22:08:08.481 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16465::oid
	
2023-12-05 22:08:08.482 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:08:08.552 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum = 4::int
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:08:08.658 PST [66779] LOG:  statement: ALTER TABLE public.restaurants
	    ALTER COLUMN category TYPE character(255) COLLATE pg_catalog."default";
2023-12-05 22:08:08.672 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16465::oid;
	
2023-12-05 22:08:17.565 PST [67113] LOG:  statement: COPY  public.restaurants ( id, name, address, category ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:08:18.085 PST [67113] ERROR:  value too long for type character(255)
2023-12-05 22:08:18.085 PST [67113] CONTEXT:  COPY restaurants, line 30936, column category: "Bakery, Bar Food, BBQ, Breakfast and Brunch, burger, Cafe, Chicken Strips, Comfort Food, Desserts, D..."
2023-12-05 22:08:18.085 PST [67113] STATEMENT:  COPY  public.restaurants ( id, name, address, category ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:08:35.298 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:08:35.315 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:08:35.330 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-05 22:08:35.336 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:35.340 PST [66779] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:35.341 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:08:35.347 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1042)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:08:35.348 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:35.350 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:35.351 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:35.352 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:35.353 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:08:35.356 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16470 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:08:35.357 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16470::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:08:35.358 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:08:35.361 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16465::oid
	ORDER BY conname
2023-12-05 22:08:35.363 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16465::oid
	
2023-12-05 22:08:35.364 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:08:35.635 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:08:35.648 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:08:35.661 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:08:35.675 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:08:43.312 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-05 22:08:43.322 PST [66779] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:43.323 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 22:08:43.324 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16465::oid;
	
2023-12-05 22:08:43.325 PST [66779] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-05 22:08:43.326 PST [66779] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16465::oid;
2023-12-05 22:08:43.327 PST [66779] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:43.328 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:08:43.336 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1042)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1042)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:08:43.338 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:43.339 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:43.340 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:43.343 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:08:43.345 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:08:43.356 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16470 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:08:43.357 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16470::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:08:43.358 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:08:43.361 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16465::oid
	ORDER BY conname
2023-12-05 22:08:43.362 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16465::oid
	
2023-12-05 22:08:43.363 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:08:43.368 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum = 4::int
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:08:43.374 PST [66779] LOG:  statement: ALTER TABLE public.restaurants
	    ALTER COLUMN category TYPE text COLLATE pg_catalog."default";
2023-12-05 22:08:43.387 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16465::oid;
	
2023-12-05 22:08:51.307 PST [67129] LOG:  statement: COPY  public.restaurants ( id, name, address, category ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:09:03.229 PST [67133] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-05 22:09:03.232 PST [67133] LOG:  statement: SELECT version()
2023-12-05 22:09:03.233 PST [67133] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-05 22:09:03.235 PST [67133] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-05 22:09:03.237 PST [67133] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-05 22:09:03.260 PST [66779] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16465;
	
2023-12-05 22:09:03.486 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'restaurants' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'restaurants' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:09:03.505 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'restaurants' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'restaurants' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:09:03.508 PST [67133] LOG:  statement: SELECT * FROM public.restaurants
	ORDER BY id ASC 
2023-12-05 22:09:03.710 PST [67133] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:09:03.744 PST [67133] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-05 22:09:03.744 PST [67133] DETAIL:  parameters: $1 = '{1043,1042,1043,25}'
2023-12-05 22:11:26.052 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:11:26.058 PST [66779] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-05 22:11:26.060 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:11:33.834 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:12:58.424 PST [36662] LOG:  checkpoint starting: time
2023-12-05 22:15:39.122 PST [66779] LOG:  statement: CREATE TABLE public.ratings
	(
	    id serial NOT NULL,
	    restaurant_id integer,
	    restaurant_name character varying(255),
	    ratings numeric(255, 1),
	    score numeric(255, 1),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.ratings
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-05 22:15:39.137 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'ratings'::text AND nspname = 'public';
	
2023-12-05 22:15:39.138 PST [66779] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'ratings'
2023-12-05 22:16:11.587 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16490::oid
2023-12-05 22:16:11.589 PST [66779] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:16:35.367 PST [36662] LOG:  checkpoint complete: wrote 2147 buffers (13.1%); 0 WAL file(s) added, 0 removed, 2 recycled; write=216.901 s, sync=0.017 s, total=216.943 s; sync files=45, longest=0.004 s, average=0.001 s; distance=38185 kB, estimate=38185 kB
2023-12-05 22:16:39.636 PST [67364] LOG:  statement: COPY  public.ratings ( restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:16:46.817 PST [67370] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-05 22:16:46.821 PST [67370] LOG:  statement: SELECT version()
2023-12-05 22:16:46.822 PST [67370] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-05 22:16:46.825 PST [67370] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-05 22:16:46.827 PST [67370] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-05 22:16:46.840 PST [66779] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16490;
	
2023-12-05 22:16:46.947 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:16:46.950 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:16:46.953 PST [67370] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-05 22:16:47.111 PST [67370] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:16:47.129 PST [67370] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-05 22:16:47.129 PST [67370] DETAIL:  parameters: $1 = '{23,23,1043,1700,1700}'
2023-12-05 22:17:28.536 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:17:28.538 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:17:28.555 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:17:28.561 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:17:28.563 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:17:28.565 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:17:28.571 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:17:28.572 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:17:28.574 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:17:28.575 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:17:28.576 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:17:28.577 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:17:28.578 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:17:28.581 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16494 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:17:28.582 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16494::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:17:28.583 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:17:28.585 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16490::oid
	ORDER BY conname
2023-12-05 22:17:28.587 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16490::oid
	
2023-12-05 22:17:28.588 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:17:28.860 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:17:28.901 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:17:28.916 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:17:28.930 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:17:28.943 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:17:35.069 PST [66779] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-05 22:17:58.366 PST [36662] LOG:  checkpoint starting: time
2023-12-05 22:18:51.239 PST [36662] LOG:  checkpoint complete: wrote 523 buffers (3.2%); 0 WAL file(s) added, 0 removed, 1 recycled; write=52.856 s, sync=0.004 s, total=52.873 s; sync files=39, longest=0.003 s, average=0.001 s; distance=4978 kB, estimate=34864 kB
2023-12-05 22:49:24.420 PST [66779] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16465::OID
	
2023-12-05 22:49:30.688 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:49:30.699 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:49:30.707 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 22:49:30.709 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16490::oid;
	
2023-12-05 22:49:30.710 PST [66779] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-05 22:49:30.711 PST [66779] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16490::oid;
2023-12-05 22:49:30.711 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:49:30.714 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:49:30.721 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:49:30.724 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:49:30.726 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:49:30.732 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:49:30.734 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:49:30.735 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:49:30.737 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:49:30.740 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16494 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:49:30.741 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16494::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:49:30.742 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:49:30.745 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16490::oid
	ORDER BY conname
2023-12-05 22:49:30.748 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16490::oid
	
2023-12-05 22:49:30.752 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:49:30.772 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-05 22:49:30.800 PST [66779] LOG:  statement: ALTER TABLE IF EXISTS public.ratings
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-05 22:49:30.801 PST [66779] ERROR:  foreign key constraint "ratings_restaurant_id_fkey" cannot be implemented
2023-12-05 22:49:30.801 PST [66779] DETAIL:  Key columns "restaurant_id" and "id" are of incompatible types: integer and character varying.
2023-12-05 22:49:30.801 PST [66779] STATEMENT:  ALTER TABLE IF EXISTS public.ratings
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-05 22:50:24.736 PST [66779] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:50:24.737 PST [66779] LOG:  execute _pg3_3: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:50:24.749 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-05 22:50:24.756 PST [66779] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:24.758 PST [66779] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:24.759 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:50:24.765 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1042,25)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1042,25)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:50:24.766 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:24.768 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:24.769 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:24.770 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:24.771 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:50:24.774 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16470 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:50:24.775 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16470::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:50:24.775 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:50:24.778 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16465::oid
	ORDER BY conname
2023-12-05 22:50:24.779 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16465::oid
	
2023-12-05 22:50:24.780 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:50:25.064 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:50:25.078 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:50:25.091 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:50:25.104 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:50:34.259 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:50:34.265 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:34.269 PST [66779] LOG:  execute _pg3_4: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:34.271 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:50:34.276 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:50:34.277 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:34.279 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:34.282 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:34.283 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:34.284 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:50:34.286 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:50:34.288 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16494 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:50:34.289 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16494::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:50:34.290 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:50:34.293 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16490::oid
	ORDER BY conname
2023-12-05 22:50:34.294 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16490::oid
	
2023-12-05 22:50:34.295 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:51:29.357 PST [66779] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16465::OID
	
2023-12-05 22:51:39.118 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:51:39.125 PST [66779] LOG:  execute _pg3_4: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:51:39.125 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 22:51:39.126 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16490::oid;
	
2023-12-05 22:51:39.127 PST [66779] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-05 22:51:39.128 PST [66779] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16490::oid;
2023-12-05 22:51:39.128 PST [66779] LOG:  execute _pg3_4: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:51:39.130 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:51:39.137 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:51:39.139 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:51:39.140 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:51:39.141 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:51:39.142 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:51:39.143 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:51:39.145 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:51:39.147 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16494 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:51:39.148 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16494::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:51:39.149 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:51:39.151 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16490::oid
	ORDER BY conname
2023-12-05 22:51:39.153 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16490::oid
	
2023-12-05 22:51:39.157 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:51:39.213 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-05 22:51:39.215 PST [66779] LOG:  statement: ALTER TABLE IF EXISTS public.ratings DROP COLUMN IF EXISTS restaurant_id;
	
	ALTER TABLE IF EXISTS public.ratings
	    ADD COLUMN restaurant_id character varying(20);
	ALTER TABLE IF EXISTS public.ratings
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-05 22:51:39.221 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16490::oid;
	
2023-12-05 22:52:23.810 PST [36662] LOG:  checkpoint starting: time
2023-12-05 22:52:26.282 PST [36662] LOG:  checkpoint complete: wrote 24 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=2.446 s, sync=0.014 s, total=2.472 s; sync files=20, longest=0.006 s, average=0.001 s; distance=86 kB, estimate=31386 kB
2023-12-05 22:52:43.617 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:52:43.624 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 22:52:43.638 PST [66779] LOG:  statement: TRUNCATE TABLE public.ratings;
2023-12-05 22:52:54.942 PST [67850] LOG:  statement: COPY  public.ratings ( restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:53:02.958 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:53:02.964 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:53:03.001 PST [67370] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-05 22:53:03.117 PST [67370] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:53:03.123 PST [67370] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-05 22:53:03.123 PST [67370] DETAIL:  parameters: $1 = '{23,1043,1700,1700,1043}'
2023-12-05 22:53:28.274 PST [66779] LOG:  execute _pg3_5: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:53:28.276 PST [66779] LOG:  execute _pg3_6: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 22:53:28.277 PST [66779] LOG:  statement: TRUNCATE TABLE public.ratings CASCADE;
2023-12-05 22:53:32.830 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:53:32.834 PST [66779] LOG:  execute _pg3_7: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:53:32.837 PST [67370] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-05 22:53:32.899 PST [67370] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:53:32.903 PST [67370] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-05 22:53:32.903 PST [67370] DETAIL:  parameters: $1 = '{23,1043,1700,1700,1043}'
2023-12-05 22:53:53.812 PST [67874] LOG:  statement: COPY  public.ratings ( restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:53:58.432 PST [66779] LOG:  execute _pg3_7: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:53:58.435 PST [66779] LOG:  execute _pg3_7: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:53:58.437 PST [67370] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-05 22:53:58.517 PST [67370] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:53:58.522 PST [67370] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-05 22:53:58.522 PST [67370] DETAIL:  parameters: $1 = '{23,1043,1700,1700,1043}'
2023-12-05 22:54:08.258 PST [66779] LOG:  execute _pg3_3: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:54:08.262 PST [66779] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:54:08.275 PST [66779] LOG:  execute _pg3_5: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:54:08.278 PST [66779] LOG:  execute _pg3_4: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:54:08.279 PST [66779] LOG:  execute _pg3_4: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16490::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:54:08.280 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16490::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:54:08.285 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:54:08.287 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:54:08.288 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:54:08.290 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:54:08.291 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:54:08.292 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16490::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:54:08.293 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:54:08.296 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16494 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:54:08.297 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16494::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:54:08.298 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:54:08.300 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16490::oid
	ORDER BY conname
2023-12-05 22:54:08.318 PST [66779] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16490::oid
	    AND a1.attnum=6
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-05 22:54:08.318 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-05 22:54:08.335 PST [66779] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16490::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16490::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16490::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16490::oid
	   AND conname IS NULL
2023-12-05 22:54:08.354 PST [66779] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16494 , 1 , true) AS column
	
2023-12-05 22:54:08.355 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16490::oid
	
2023-12-05 22:54:08.356 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16490::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:54:08.503 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:54:08.520 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:54:08.533 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:54:08.546 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:54:08.559 PST [66779] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:54:22.533 PST [66779] LOG:  execute _pg3_5: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16490::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16490::oid ORDER BY rel.relname;
2023-12-05 22:54:22.534 PST [66779] LOG:  execute _pg3_6: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 22:54:22.554 PST [66779] LOG:  statement: DROP TABLE IF EXISTS public.ratings CASCADE;
2023-12-05 22:54:22.559 PST [66779] LOG:  execute <unnamed>: DEALLOCATE ALL
2023-12-05 22:54:26.842 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:54:26.913 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:54:26.917 PST [66779] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-05 22:54:36.784 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:56:23.558 PST [66779] LOG:  statement: CREATE TABLE public.ratings
	(
	    id serial NOT NULL,
	    restaurant_id character varying(20),
	    restaurant_name character varying(255),
	    ratings numeric(255, 1),
	    score numeric(255, 1),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.ratings
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-05 22:56:23.565 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'ratings'::text AND nspname = 'public';
	
2023-12-05 22:56:23.566 PST [66779] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'ratings'
2023-12-05 22:56:30.929 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16507::oid
2023-12-05 22:56:30.931 PST [66779] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16507::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:56:34.724 PST [67938] LOG:  statement: COPY  public.ratings ( id, restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:56:34.726 PST [67938] ERROR:  value too long for type character varying(20)
2023-12-05 22:56:34.726 PST [67938] CONTEXT:  COPY ratings, line 2, column restaurant_id: "PJ Fresh (224 Daniel Payne Drive)"
2023-12-05 22:56:34.726 PST [67938] STATEMENT:  COPY  public.ratings ( id, restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:56:51.232 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 22:56:51.236 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 22:56:51.251 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16507::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16507::oid ORDER BY rel.relname;
2023-12-05 22:56:51.258 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:56:51.260 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:56:51.262 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16507::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 22:56:51.269 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 22:56:51.270 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:56:51.272 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:56:51.273 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:56:51.274 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:56:51.275 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 22:56:51.277 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 22:56:51.279 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16511 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 22:56:51.280 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16511::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 22:56:51.281 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 22:56:51.283 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16507::oid
	ORDER BY conname
2023-12-05 22:56:51.285 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16507::oid
	
2023-12-05 22:56:51.286 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 22:56:51.631 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:56:51.647 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:56:51.663 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:56:51.679 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:56:51.698 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 22:56:58.500 PST [67949] LOG:  execute <unnamed>: BEGIN
2023-12-05 22:56:58.502 PST [67949] LOG:  statement: SELECT pg_cancel_backend(67133);
2023-12-05 22:56:58.537 PST [66742] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-05 22:57:01.384 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:57:01.387 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:57:01.393 PST [67370] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-05 22:57:01.448 PST [67370] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16507::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:57:01.454 PST [67370] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-05 22:57:01.454 PST [67370] DETAIL:  parameters: $1 = '{23,1043,1043,1700,1700}'
2023-12-05 22:57:11.458 PST [67960] LOG:  statement: COPY  public.ratings ( restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 22:57:17.094 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:57:17.098 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-05 22:57:17.104 PST [67370] LOG:  execute _pg3_0: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-05 22:57:17.209 PST [67370] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16507::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 22:57:17.213 PST [67370] LOG:  execute _pg3_1: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-05 22:57:17.213 PST [67370] DETAIL:  parameters: $1 = '{23,1043,1043,1700,1700}'
2023-12-05 22:57:23.279 PST [36662] LOG:  checkpoint starting: time
2023-12-05 23:01:29.983 PST [36662] LOG:  checkpoint complete: wrote 2443 buffers (14.9%); 0 WAL file(s) added, 0 removed, 2 recycled; write=246.680 s, sync=0.006 s, total=246.704 s; sync files=45, longest=0.001 s, average=0.001 s; distance=34148 kB, estimate=34148 kB
2023-12-05 23:01:41.357 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 23:01:41.367 PST [66779] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-05 23:01:41.371 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 23:02:15.591 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:05:39.626 PST [66779] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-05 23:05:46.395 PST [66779] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16465::OID
	
2023-12-05 23:05:52.580 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-05 23:05:52.583 PST [66779] LOG:  statement: CREATE TABLE public.menus
	(
	    id character varying(255) NOT NULL,
	    restaurant_id character varying(255),
	    category text,
	    name character varying(255),
	    description text,
	    price numeric(100, 2),
	    PRIMARY KEY (id),
	    FOREIGN KEY (restaurant_id)
	        REFERENCES public.restaurants (id) MATCH SIMPLE
	        ON UPDATE NO ACTION
	        ON DELETE NO ACTION
	        NOT VALID
	);
	
	
	ALTER TABLE IF EXISTS public.menus
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-05 23:05:52.596 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'menus'::text AND nspname = 'public';
	
2023-12-05 23:05:52.597 PST [66779] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'menus'
2023-12-05 23:07:23.978 PST [36662] LOG:  checkpoint starting: time
2023-12-05 23:07:28.680 PST [36662] LOG:  checkpoint complete: wrote 46 buffers (0.3%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.681 s, sync=0.013 s, total=4.703 s; sync files=41, longest=0.002 s, average=0.001 s; distance=3229 kB, estimate=31056 kB
2023-12-05 23:12:06.814 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16514::oid
2023-12-05 23:12:06.816 PST [66779] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16514::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 23:12:18.225 PST [68373] LOG:  statement: COPY  public.menus ( id, restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:12:18.226 PST [68373] ERROR:  missing data for column "price"
2023-12-05 23:12:18.226 PST [68373] CONTEXT:  COPY menus, line 2: "1,Extra Large Pizza,Extra Large Meat Lovers,Whole pie.,15.99"
2023-12-05 23:12:18.226 PST [68373] STATEMENT:  COPY  public.menus ( id, restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:12:23.676 PST [36662] LOG:  checkpoint starting: time
2023-12-05 23:12:24.106 PST [36662] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.413 s, sync=0.006 s, total=0.431 s; sync files=4, longest=0.006 s, average=0.002 s; distance=19 kB, estimate=27953 kB
2023-12-05 23:12:42.473 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 23:12:42.477 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 23:12:42.489 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16514::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16514::oid ORDER BY rel.relname;
2023-12-05 23:12:42.501 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16514::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16514::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.502 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16514::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16514::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.504 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16514::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 23:12:42.511 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 23:12:42.513 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.514 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.516 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.519 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.521 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.523 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16514::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:12:42.524 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16514::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 23:12:42.527 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16519 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 23:12:42.528 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16519::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 23:12:42.529 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16514::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 23:12:42.531 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16514::oid
	ORDER BY conname
2023-12-05 23:12:42.534 PST [66779] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16514::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-05 23:12:42.535 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-05 23:12:42.535 PST [66779] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16514::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16514::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16514::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16514::oid
	   AND conname IS NULL
2023-12-05 23:12:42.539 PST [66779] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16519 , 1 , true) AS column
	
2023-12-05 23:12:42.539 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16514::oid
	
2023-12-05 23:12:42.541 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16514::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 23:12:42.768 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:12:42.787 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:12:42.803 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:12:42.817 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:12:42.831 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:12:42.850 PST [66779] LOG:  execute _pg3_8: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:14:02.496 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16514::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16514::oid ORDER BY rel.relname;
2023-12-05 23:14:02.508 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-05 23:14:02.510 PST [66779] LOG:  statement: DROP TABLE IF EXISTS public.menus CASCADE;
2023-12-05 23:14:02.514 PST [66779] LOG:  execute <unnamed>: DEALLOCATE ALL
2023-12-05 23:14:06.226 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 23:14:06.234 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 23:14:06.237 PST [66779] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-05 23:14:14.609 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:16:24.782 PST [66779] LOG:  statement: CREATE TABLE public.menus
	(
	    id serial NOT NULL,
	    restaurant_id character varying(255),
	    category text,
	    name character varying(255),
	    description text,
	    price numeric(255, 2),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.menus
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-05 23:16:24.799 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'menus'::text AND nspname = 'public';
	
2023-12-05 23:16:24.799 PST [66779] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'menus'
2023-12-05 23:16:29.268 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16527::oid
2023-12-05 23:16:29.269 PST [66779] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-05 23:16:35.240 PST [68483] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:16:35.439 PST [68483] ERROR:  unquoted carriage return found in data
2023-12-05 23:16:35.439 PST [68483] HINT:  Use quoted CSV field to represent carriage return.
2023-12-05 23:16:35.439 PST [68483] CONTEXT:  COPY menus, line 30556
2023-12-05 23:16:35.439 PST [68483] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:17:23.102 PST [36662] LOG:  checkpoint starting: time
2023-12-05 23:17:34.105 PST [36662] LOG:  checkpoint complete: wrote 108 buffers (0.7%); 0 WAL file(s) added, 0 removed, 0 recycled; write=10.975 s, sync=0.011 s, total=11.003 s; sync files=36, longest=0.002 s, average=0.001 s; distance=6727 kB, estimate=25830 kB
2023-12-05 23:24:06.066 PST [68714] LOG:  statement: COPY  public.menus ( id, restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:24:06.067 PST [68714] ERROR:  missing data for column "price"
2023-12-05 23:24:06.067 PST [68714] CONTEXT:  COPY menus, line 2: "1,Extra Large Pizza,Extra Large Meat Lovers,Whole pie.,15.99"
2023-12-05 23:24:06.067 PST [68714] STATEMENT:  COPY  public.menus ( id, restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:24:15.052 PST [66779] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-05 23:24:15.054 PST [66779] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-05 23:24:15.068 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-05 23:24:15.082 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.084 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.087 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-05 23:24:15.093 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-05 23:24:15.095 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.096 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.098 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.101 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.102 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.104 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-05 23:24:15.105 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-05 23:24:15.108 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-05 23:24:15.109 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16533::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-05 23:24:15.110 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-05 23:24:15.112 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16527::oid
	ORDER BY conname
2023-12-05 23:24:15.114 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16527::oid
	
2023-12-05 23:24:15.115 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-05 23:24:15.343 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:24:15.364 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:24:15.377 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:24:15.391 PST [66779] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:24:15.577 PST [66779] LOG:  execute _pg3_9: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:24:15.598 PST [66779] LOG:  execute _pg3_9: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-05 23:24:25.319 PST [68726] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:24:25.356 PST [68726] ERROR:  extra data after last expected column
2023-12-05 23:24:25.356 PST [68726] CONTEXT:  COPY menus, line 3654: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:24:25.356 PST [68726] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:26:00.494 PST [68770] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:26:00.523 PST [68770] ERROR:  extra data after last expected column
2023-12-05 23:26:00.523 PST [68770] CONTEXT:  COPY menus, line 3667: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:26:00.523 PST [68770] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:27:23.097 PST [36662] LOG:  checkpoint starting: time
2023-12-05 23:27:26.168 PST [36662] LOG:  checkpoint complete: wrote 31 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.054 s, sync=0.008 s, total=3.072 s; sync files=12, longest=0.002 s, average=0.001 s; distance=1589 kB, estimate=23406 kB
2023-12-05 23:33:02.976 PST [68960] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:33:02.995 PST [68960] ERROR:  extra data after last expected column
2023-12-05 23:33:02.995 PST [68960] CONTEXT:  COPY menus, line 3667: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:33:02.995 PST [68960] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:34:06.261 PST [68995] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:34:06.284 PST [68995] ERROR:  extra data after last expected column
2023-12-05 23:34:06.284 PST [68995] CONTEXT:  COPY menus, line 3666: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:34:06.284 PST [68995] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:34:55.367 PST [69022] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:34:55.390 PST [69022] ERROR:  extra data after last expected column
2023-12-05 23:34:55.390 PST [69022] CONTEXT:  COPY menus, line 3672: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:34:55.390 PST [69022] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:35:39.420 PST [69049] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:35:39.446 PST [69049] ERROR:  extra data after last expected column
2023-12-05 23:35:39.446 PST [69049] CONTEXT:  COPY menus, line 3672: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:35:39.446 PST [69049] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:36:45.479 PST [69086] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:36:45.498 PST [69086] ERROR:  extra data after last expected column
2023-12-05 23:36:45.498 PST [69086] CONTEXT:  COPY menus, line 3675: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:36:45.498 PST [69086] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:37:23.168 PST [36662] LOG:  checkpoint starting: time
2023-12-05 23:37:26.566 PST [36662] LOG:  checkpoint complete: wrote 34 buffers (0.2%); 0 WAL file(s) added, 1 removed, 0 recycled; write=3.350 s, sync=0.009 s, total=3.398 s; sync files=8, longest=0.003 s, average=0.002 s; distance=3831 kB, estimate=21448 kB
2023-12-05 23:37:52.666 PST [69124] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:37:52.685 PST [69124] ERROR:  extra data after last expected column
2023-12-05 23:37:52.685 PST [69124] CONTEXT:  COPY menus, line 3705: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:37:52.685 PST [69124] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:38:57.230 PST [69153] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:38:57.251 PST [69153] ERROR:  extra data after last expected column
2023-12-05 23:38:57.251 PST [69153] CONTEXT:  COPY menus, line 4182: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:38:57.251 PST [69153] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:39:56.967 PST [69179] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:39:56.989 PST [69179] ERROR:  extra data after last expected column
2023-12-05 23:39:56.989 PST [69179] CONTEXT:  COPY menus, line 4250: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-05 23:39:56.989 PST [69179] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-05 23:42:23.563 PST [36662] LOG:  checkpoint starting: time
2023-12-05 23:42:26.004 PST [36662] LOG:  checkpoint complete: wrote 25 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=2.425 s, sync=0.008 s, total=2.441 s; sync files=8, longest=0.002 s, average=0.001 s; distance=2319 kB, estimate=19535 kB
2023-12-06 00:11:44.072 PST [69920] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-06 00:11:44.095 PST [69920] ERROR:  extra data after last expected column
2023-12-06 00:11:44.095 PST [69920] CONTEXT:  COPY menus, line 4686: "Consuming raw or undercooked meats, poultry, seafood, shellfish or eggs may increase your risk of fo..."
2023-12-06 00:11:44.095 PST [69920] STATEMENT:  COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-06 00:12:23.981 PST [36662] LOG:  checkpoint starting: time
2023-12-06 00:12:25.629 PST [36662] LOG:  checkpoint complete: wrote 17 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.624 s, sync=0.011 s, total=1.649 s; sync files=8, longest=0.006 s, average=0.002 s; distance=792 kB, estimate=17661 kB
2023-12-06 00:12:56.252 PST [69949] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-06 00:13:05.741 PST [69954] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 00:13:05.755 PST [69954] LOG:  statement: SELECT version()
2023-12-06 00:13:05.757 PST [69954] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 00:13:05.774 PST [69954] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 00:13:05.782 PST [69954] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 00:13:05.814 PST [66779] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16527;
	
2023-12-06 00:13:05.882 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-06 00:13:05.892 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-06 00:13:05.907 PST [69954] LOG:  statement: SELECT * FROM public.menus
	ORDER BY id ASC 
2023-12-06 00:13:06.024 PST [69954] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-06 00:13:06.102 PST [69954] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-06 00:13:06.102 PST [69954] DETAIL:  parameters: $1 = '{23,1043,25,1043,25,1700}'
2023-12-06 00:13:36.899 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-06 00:13:36.920 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-06 00:13:36.922 PST [66779] LOG:  statement: TRUNCATE TABLE public.menus;
2023-12-06 00:13:39.598 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-06 00:13:39.603 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-06 00:13:39.606 PST [69954] LOG:  statement: SELECT * FROM public.menus
	ORDER BY id ASC 
2023-12-06 00:13:39.654 PST [69954] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-06 00:13:39.659 PST [69954] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-06 00:13:39.659 PST [69954] DETAIL:  parameters: $1 = '{23,1043,25,1043,25,1700}'
2023-12-06 00:14:06.489 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-06 00:14:06.503 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-06 00:14:06.505 PST [66779] LOG:  statement: TRUNCATE TABLE public.menus RESTART IDENTITY;
2023-12-06 00:14:15.733 PST [69987] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-06 00:14:20.742 PST [66779] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-06 00:14:20.752 PST [66779] LOG:  execute _pg3_10: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-06 00:14:20.754 PST [69954] LOG:  statement: SELECT * FROM public.menus
	ORDER BY id ASC 
2023-12-06 00:14:20.817 PST [69954] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-06 00:14:20.822 PST [69954] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-06 00:14:20.822 PST [69954] DETAIL:  parameters: $1 = '{23,1043,25,1043,25,1700}'
2023-12-06 00:14:40.066 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-06 00:14:40.074 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.077 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.080 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-06 00:14:40.086 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-06 00:14:40.090 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.092 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.093 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.096 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.098 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.100 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:40.101 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-06 00:14:40.104 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-06 00:14:40.105 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16533::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-06 00:14:40.106 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-06 00:14:40.108 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16527::oid
	ORDER BY conname
2023-12-06 00:14:40.110 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16527::oid
	
2023-12-06 00:14:40.111 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-06 00:14:44.066 PST [66779] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-06 00:14:52.552 PST [66779] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16465::OID
	
2023-12-06 00:14:57.934 PST [66779] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-06 00:14:57.941 PST [66779] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.943 PST [66779] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-06 00:14:57.943 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16527::oid;
	
2023-12-06 00:14:57.944 PST [66779] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-06 00:14:57.945 PST [66779] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16527::oid;
2023-12-06 00:14:57.949 PST [66779] LOG:  execute _pg3_11: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.950 PST [66779] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-06 00:14:57.957 PST [66779] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-06 00:14:57.959 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.960 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.962 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.963 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.964 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.965 PST [66779] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-06 00:14:57.967 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-06 00:14:57.969 PST [66779] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-06 00:14:57.970 PST [66779] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16533::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-06 00:14:57.971 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-06 00:14:57.974 PST [66779] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16527::oid
	ORDER BY conname
2023-12-06 00:14:57.975 PST [66779] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16527::oid
	
2023-12-06 00:14:57.976 PST [66779] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-06 00:14:57.980 PST [66779] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-06 00:14:57.984 PST [66779] LOG:  statement: ALTER TABLE IF EXISTS public.menus
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-06 00:14:57.987 PST [66779] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16527::oid;
	
2023-12-06 00:17:23.624 PST [36662] LOG:  checkpoint starting: time
2023-12-06 00:17:39.019 PST [36662] LOG:  checkpoint complete: wrote 148 buffers (0.9%); 0 WAL file(s) added, 0 removed, 0 recycled; write=15.378 s, sync=0.007 s, total=15.395 s; sync files=37, longest=0.002 s, average=0.001 s; distance=2195 kB, estimate=16114 kB
2023-12-06 00:25:49.145 PST [70148] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 00:25:49.149 PST [70148] LOG:  statement: SELECT version()
2023-12-06 00:25:49.149 PST [70148] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 00:25:49.152 PST [70148] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 00:25:49.153 PST [70148] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 00:25:49.168 PST [70149] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 00:25:49.171 PST [70149] LOG:  statement: SELECT version()
2023-12-06 00:25:49.171 PST [70149] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 00:25:49.172 PST [70149] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 00:25:49.173 PST [70149] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 00:25:49.186 PST [70150] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 00:25:49.188 PST [70150] LOG:  statement: SELECT version()
2023-12-06 00:25:49.188 PST [70150] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 00:25:49.189 PST [70150] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 00:25:49.190 PST [70150] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 07:02:54.278 PST [71893] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 07:02:54.282 PST [71893] LOG:  statement: SELECT version()
2023-12-06 07:02:54.284 PST [71893] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 07:02:54.299 PST [71893] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 07:02:54.302 PST [71893] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 07:02:54.353 PST [71894] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 07:02:54.357 PST [71894] LOG:  statement: SELECT version()
2023-12-06 07:02:54.357 PST [71894] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 07:02:54.359 PST [71894] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 07:02:54.359 PST [71894] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 07:02:54.379 PST [71895] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 07:02:54.383 PST [71895] LOG:  statement: SELECT version()
2023-12-06 07:02:54.383 PST [71895] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 07:02:54.385 PST [71895] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 07:02:54.386 PST [71895] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 09:03:32.615 PST [71928] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 09:03:32.617 PST [71928] LOG:  statement: SELECT version()
2023-12-06 09:03:32.618 PST [71928] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 09:03:32.619 PST [71928] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 09:03:32.621 PST [71928] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 09:03:32.636 PST [71929] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 09:03:32.638 PST [71929] LOG:  statement: SELECT version()
2023-12-06 09:03:32.638 PST [71929] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 09:03:32.639 PST [71929] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 09:03:32.640 PST [71929] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 09:03:32.661 PST [71930] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 09:03:32.664 PST [71930] LOG:  statement: SELECT version()
2023-12-06 09:03:32.664 PST [71930] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 09:03:32.666 PST [71930] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 09:03:32.666 PST [71930] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 12:12:13.445 PST [71974] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 12:12:13.449 PST [71974] LOG:  statement: SELECT version()
2023-12-06 12:12:13.449 PST [71974] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 12:12:13.451 PST [71974] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 12:12:13.453 PST [71974] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 12:12:13.467 PST [71975] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 12:12:13.469 PST [71975] LOG:  statement: SELECT version()
2023-12-06 12:12:13.470 PST [71975] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 12:12:13.471 PST [71975] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 12:12:13.472 PST [71975] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 12:12:13.488 PST [71976] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 12:12:13.492 PST [71976] LOG:  statement: SELECT version()
2023-12-06 12:12:13.494 PST [71976] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 12:12:13.501 PST [71976] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 12:12:13.512 PST [71976] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 15:45:12.329 PST [74821] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 15:45:12.331 PST [74821] LOG:  statement: SELECT version()
2023-12-06 15:45:12.331 PST [74821] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 15:45:12.338 PST [74821] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 15:45:12.339 PST [74821] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 15:45:12.363 PST [74822] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 15:45:12.365 PST [74822] LOG:  statement: SELECT version()
2023-12-06 15:45:12.365 PST [74822] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 15:45:12.366 PST [74822] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 15:45:12.367 PST [74822] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 15:45:12.379 PST [74823] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 15:45:12.381 PST [74823] LOG:  statement: SELECT version()
2023-12-06 15:45:12.382 PST [74823] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 15:45:12.383 PST [74823] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 15:45:12.384 PST [74823] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 15:50:57.542 PST [74884] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 15:50:57.543 PST [74884] LOG:  statement: SELECT version()
2023-12-06 15:50:57.544 PST [74884] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 15:50:57.544 PST [74884] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 15:50:57.545 PST [74884] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 15:50:57.556 PST [74885] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 15:50:57.559 PST [74885] LOG:  statement: SELECT version()
2023-12-06 15:50:57.560 PST [74885] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 15:50:57.561 PST [74885] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 15:50:57.562 PST [74885] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 15:50:57.574 PST [74886] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 15:50:57.576 PST [74886] LOG:  statement: SELECT version()
2023-12-06 15:50:57.576 PST [74886] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 15:50:57.577 PST [74886] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 15:50:57.577 PST [74886] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 16:44:37.897 PST [74952] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 16:44:37.899 PST [74952] LOG:  statement: SELECT version()
2023-12-06 16:44:37.899 PST [74952] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 16:44:37.900 PST [74952] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 16:44:37.901 PST [74952] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 16:44:37.918 PST [74953] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 16:44:37.920 PST [74953] LOG:  statement: SELECT version()
2023-12-06 16:44:37.921 PST [74953] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 16:44:37.922 PST [74953] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 16:44:37.922 PST [74953] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 16:44:37.947 PST [74954] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 16:44:37.950 PST [74954] LOG:  statement: SELECT version()
2023-12-06 16:44:37.950 PST [74954] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 16:44:37.951 PST [74954] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 16:44:37.952 PST [74954] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 16:49:21.702 PST [74985] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 16:49:21.705 PST [74985] LOG:  statement: SELECT version()
2023-12-06 16:49:21.705 PST [74985] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 16:49:21.706 PST [74985] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 16:49:21.708 PST [74985] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 16:49:21.733 PST [74986] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 16:49:21.735 PST [74986] LOG:  statement: SELECT version()
2023-12-06 16:49:21.735 PST [74986] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 16:49:21.737 PST [74986] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 16:49:21.737 PST [74986] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 16:49:21.754 PST [74987] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 16:49:21.756 PST [74987] LOG:  statement: SELECT version()
2023-12-06 16:49:21.757 PST [74987] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 16:49:21.758 PST [74987] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 16:49:21.759 PST [74987] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 17:16:37.317 PST [75081] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 17:16:37.318 PST [75081] LOG:  statement: SELECT version()
2023-12-06 17:16:37.319 PST [75081] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 17:16:37.320 PST [75081] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 17:16:37.321 PST [75081] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 17:16:37.336 PST [75082] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 17:16:37.338 PST [75082] LOG:  statement: SELECT version()
2023-12-06 17:16:37.338 PST [75082] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 17:16:37.339 PST [75082] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 17:16:37.340 PST [75082] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 17:16:37.370 PST [75083] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 17:16:37.373 PST [75083] LOG:  statement: SELECT version()
2023-12-06 17:16:37.373 PST [75083] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 17:16:37.374 PST [75083] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 17:16:37.375 PST [75083] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 19:33:24.224 PST [77430] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 19:33:24.226 PST [77430] LOG:  statement: SELECT version()
2023-12-06 19:33:24.227 PST [77430] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 19:33:24.228 PST [77430] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 19:33:24.229 PST [77430] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 19:33:24.243 PST [77431] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 19:33:24.245 PST [77431] LOG:  statement: SELECT version()
2023-12-06 19:33:24.246 PST [77431] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 19:33:24.247 PST [77431] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 19:33:24.248 PST [77431] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-06 19:33:24.261 PST [77432] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-06 19:33:24.263 PST [77432] LOG:  statement: SELECT version()
2023-12-06 19:33:24.264 PST [77432] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-06 19:33:24.265 PST [77432] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-06 19:33:24.265 PST [77432] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 01:29:35.646 PST [77735] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 01:29:35.684 PST [77735] LOG:  statement: SELECT version()
2023-12-07 01:29:35.687 PST [77735] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 01:29:35.695 PST [77735] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 01:29:35.699 PST [77735] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 01:29:35.746 PST [77737] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 01:29:35.753 PST [77737] LOG:  statement: SELECT version()
2023-12-07 01:29:35.754 PST [77737] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 01:29:35.757 PST [77737] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 01:29:35.760 PST [77737] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 01:29:35.810 PST [77738] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 01:29:35.819 PST [77738] LOG:  statement: SELECT version()
2023-12-07 01:29:35.820 PST [77738] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 01:29:35.824 PST [77738] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 01:29:35.827 PST [77738] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 11:16:01.783 PST [77801] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 11:16:01.799 PST [77801] LOG:  statement: SELECT version()
2023-12-07 11:16:01.801 PST [77801] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 11:16:01.805 PST [77801] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 11:16:01.808 PST [77801] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 11:16:01.842 PST [77803] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 11:16:01.845 PST [77803] LOG:  statement: SELECT version()
2023-12-07 11:16:01.847 PST [77803] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 11:16:01.849 PST [77803] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 11:16:01.851 PST [77803] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 11:16:01.866 PST [77804] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 11:16:01.869 PST [77804] LOG:  statement: SELECT version()
2023-12-07 11:16:01.870 PST [77804] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 11:16:01.871 PST [77804] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 11:16:01.873 PST [77804] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 18:37:33.275 PST [87735] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 18:37:33.278 PST [87735] LOG:  statement: SELECT version()
2023-12-07 18:37:33.279 PST [87735] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 18:37:33.294 PST [87735] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 18:37:33.297 PST [87735] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 18:37:33.335 PST [87736] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 18:37:33.339 PST [87736] LOG:  statement: SELECT version()
2023-12-07 18:37:33.339 PST [87736] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 18:37:33.343 PST [87736] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 18:37:33.345 PST [87736] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-07 18:37:33.360 PST [87737] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-07 18:37:33.366 PST [87737] LOG:  statement: SELECT version()
2023-12-07 18:37:33.366 PST [87737] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-07 18:37:33.370 PST [87737] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-07 18:37:33.371 PST [87737] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 00:53:05.634 PST [97134] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 00:53:05.641 PST [97134] LOG:  statement: SELECT version()
2023-12-08 00:53:05.643 PST [97134] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 00:53:05.678 PST [97134] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 00:53:05.679 PST [97134] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 00:53:05.729 PST [97135] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 00:53:05.733 PST [97135] LOG:  statement: SELECT version()
2023-12-08 00:53:05.733 PST [97135] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 00:53:05.736 PST [97135] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 00:53:05.737 PST [97135] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 00:53:05.754 PST [97136] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 00:53:05.758 PST [97136] LOG:  statement: SELECT version()
2023-12-08 00:53:05.759 PST [97136] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 00:53:05.761 PST [97136] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 00:53:05.763 PST [97136] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 06:25:19.090 PST [99547] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 06:25:19.125 PST [99547] LOG:  statement: SELECT version()
2023-12-08 06:25:19.131 PST [99547] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 06:25:19.141 PST [99547] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 06:25:19.146 PST [99547] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 06:25:19.224 PST [99548] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 06:25:19.239 PST [99548] LOG:  statement: SELECT version()
2023-12-08 06:25:19.240 PST [99548] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 06:25:19.249 PST [99548] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 06:25:19.254 PST [99548] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 06:25:19.369 PST [99549] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 06:25:19.401 PST [99549] LOG:  statement: SELECT version()
2023-12-08 06:25:19.403 PST [99549] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 06:25:19.410 PST [99549] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 06:25:19.414 PST [99549] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 08:25:43.855 PST [99569] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 08:25:43.859 PST [99569] LOG:  statement: SELECT version()
2023-12-08 08:25:43.861 PST [99569] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 08:25:43.871 PST [99569] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 08:25:43.880 PST [99569] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 08:25:43.906 PST [99570] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 08:25:43.911 PST [99570] LOG:  statement: SELECT version()
2023-12-08 08:25:43.912 PST [99570] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 08:25:43.914 PST [99570] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 08:25:43.916 PST [99570] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 08:25:43.978 PST [99571] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 08:25:43.984 PST [99571] LOG:  statement: SELECT version()
2023-12-08 08:25:43.984 PST [99571] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 08:25:43.986 PST [99571] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 08:25:43.988 PST [99571] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 10:25:42.727 PST [99601] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 10:25:42.738 PST [99601] LOG:  statement: SELECT version()
2023-12-08 10:25:42.740 PST [99601] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 10:25:42.747 PST [99601] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 10:25:42.750 PST [99601] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 10:25:42.818 PST [99602] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 10:25:42.829 PST [99602] LOG:  statement: SELECT version()
2023-12-08 10:25:42.832 PST [99602] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 10:25:42.841 PST [99602] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 10:25:42.845 PST [99602] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 10:25:42.916 PST [99603] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 10:25:42.931 PST [99603] LOG:  statement: SELECT version()
2023-12-08 10:25:42.936 PST [99603] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 10:25:42.944 PST [99603] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 10:25:42.948 PST [99603] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 10:44:48.300 PST [99634] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 10:44:48.313 PST [99634] LOG:  statement: SELECT version()
2023-12-08 10:44:48.315 PST [99634] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 10:44:48.319 PST [99634] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 10:44:48.322 PST [99634] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 10:44:48.352 PST [99635] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 10:44:48.358 PST [99635] LOG:  statement: SELECT version()
2023-12-08 10:44:48.358 PST [99635] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 10:44:48.361 PST [99635] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 10:44:48.362 PST [99635] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 10:44:48.388 PST [99636] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 10:44:48.392 PST [99636] LOG:  statement: SELECT version()
2023-12-08 10:44:48.393 PST [99636] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 10:44:48.394 PST [99636] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 10:44:48.395 PST [99636] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 11:15:27.228 PST [99683] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 11:15:27.231 PST [99683] LOG:  statement: SELECT version()
2023-12-08 11:15:27.232 PST [99683] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 11:15:27.233 PST [99683] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 11:15:27.234 PST [99683] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 11:15:27.255 PST [99684] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 11:15:27.258 PST [99684] LOG:  statement: SELECT version()
2023-12-08 11:15:27.259 PST [99684] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 11:15:27.261 PST [99684] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 11:15:27.262 PST [99684] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 11:15:27.283 PST [99685] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 11:15:27.286 PST [99685] LOG:  statement: SELECT version()
2023-12-08 11:15:27.287 PST [99685] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 11:15:27.289 PST [99685] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 11:15:27.290 PST [99685] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 18:57:12.370 PST [1889] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 18:57:12.381 PST [1889] LOG:  statement: SELECT version()
2023-12-08 18:57:12.383 PST [1889] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 18:57:12.387 PST [1889] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 18:57:12.389 PST [1889] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 18:57:12.417 PST [1890] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 18:57:12.421 PST [1890] LOG:  statement: SELECT version()
2023-12-08 18:57:12.421 PST [1890] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 18:57:12.423 PST [1890] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 18:57:12.423 PST [1890] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 18:57:12.439 PST [1891] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 18:57:12.443 PST [1891] LOG:  statement: SELECT version()
2023-12-08 18:57:12.443 PST [1891] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 18:57:12.445 PST [1891] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 18:57:12.446 PST [1891] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 19:33:24.875 PST [2998] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 19:33:24.881 PST [2998] LOG:  statement: SELECT version()
2023-12-08 19:33:24.882 PST [2998] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 19:33:24.890 PST [2998] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 19:33:24.892 PST [2998] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 19:33:24.923 PST [2999] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 19:33:24.926 PST [2999] LOG:  statement: SELECT version()
2023-12-08 19:33:24.927 PST [2999] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 19:33:24.928 PST [2999] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 19:33:24.929 PST [2999] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 19:33:24.948 PST [3000] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 19:33:24.952 PST [3000] LOG:  statement: SELECT version()
2023-12-08 19:33:24.953 PST [3000] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 19:33:24.956 PST [3000] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 19:33:24.956 PST [3000] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 19:48:53.895 PST [3085] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 19:48:53.901 PST [3085] LOG:  statement: SELECT version()
2023-12-08 19:48:53.902 PST [3085] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 19:48:53.903 PST [3085] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 19:48:53.905 PST [3085] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 19:48:53.930 PST [3086] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 19:48:53.932 PST [3086] LOG:  statement: SELECT version()
2023-12-08 19:48:53.933 PST [3086] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 19:48:53.934 PST [3086] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 19:48:53.936 PST [3086] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 19:48:53.956 PST [3087] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 19:48:53.960 PST [3087] LOG:  statement: SELECT version()
2023-12-08 19:48:53.960 PST [3087] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 19:48:53.964 PST [3087] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 19:48:53.970 PST [3087] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 20:57:43.865 PST [4161] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 20:57:43.869 PST [4161] LOG:  statement: SELECT version()
2023-12-08 20:57:43.869 PST [4161] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 20:57:43.880 PST [4161] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 20:57:43.881 PST [4161] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 20:57:43.926 PST [4162] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 20:57:43.930 PST [4162] LOG:  statement: SELECT version()
2023-12-08 20:57:43.930 PST [4162] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 20:57:43.932 PST [4162] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 20:57:43.933 PST [4162] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 20:57:43.951 PST [4163] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 20:57:43.955 PST [4163] LOG:  statement: SELECT version()
2023-12-08 20:57:43.956 PST [4163] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 20:57:43.958 PST [4163] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 20:57:43.959 PST [4163] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 21:41:59.642 PST [4163] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 21:41:59.712 PST [4163] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 21:41:59.720 PST [4163] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-08 21:42:28.451 PST [4163] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:44:26.604 PST [4163] LOG:  statement: CREATE TABLE public.payment
	(
	    payment_id character varying(255) NOT NULL,
	    order_id character varying(255),
	    amount numeric(255, 2),
	    PRIMARY KEY (payment_id)
	);
	
	
	ALTER TABLE IF EXISTS public.payment
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-08 21:44:26.683 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'payment'::text AND nspname = 'public';
	
2023-12-08 21:44:26.684 PST [4163] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'payment'
2023-12-08 21:44:36.551 PST [4163] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 21:44:36.553 PST [4163] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 21:44:36.572 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-08 21:44:36.720 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.722 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.725 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 21:44:36.782 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 21:44:36.794 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.799 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.803 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.806 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.807 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.808 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:44:36.810 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 21:44:36.822 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 21:44:36.823 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16533::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 21:44:36.826 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 21:44:36.829 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16527::oid
	ORDER BY conname
2023-12-08 21:44:36.833 PST [4163] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16527::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-08 21:44:36.834 PST [4163] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-08 21:44:36.836 PST [4163] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	   AND conname IS NULL
2023-12-08 21:44:36.843 PST [4163] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column
	
2023-12-08 21:44:36.845 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16527::oid
	
2023-12-08 21:44:36.849 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 21:44:37.065 PST [4163] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:44:37.085 PST [4163] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:44:37.100 PST [4163] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:44:37.114 PST [4163] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:44:37.129 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:44:37.143 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:46:10.285 PST [36662] LOG:  checkpoint starting: time
2023-12-08 21:46:13.422 PST [36662] LOG:  checkpoint complete: wrote 31 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.111 s, sync=0.005 s, total=3.138 s; sync files=30, longest=0.001 s, average=0.001 s; distance=163 kB, estimate=14519 kB
2023-12-08 21:59:54.270 PST [4163] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 21:59:54.272 PST [4163] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 21:59:54.284 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16507::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16507::oid ORDER BY rel.relname;
2023-12-08 21:59:54.292 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:59:54.294 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:59:54.295 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16507::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 21:59:54.302 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 21:59:54.304 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:59:54.305 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:59:54.307 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:59:54.308 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:59:54.309 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 21:59:54.311 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 21:59:54.313 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16511 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 21:59:54.314 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16511::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 21:59:54.316 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 21:59:54.319 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16507::oid
	ORDER BY conname
2023-12-08 21:59:54.320 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16507::oid
	
2023-12-08 21:59:54.321 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 21:59:54.632 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:59:54.648 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:59:54.666 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:59:54.681 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 21:59:54.697 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:00:04.129 PST [4163] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:00:04.134 PST [4163] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:00:04.135 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-08 22:00:04.144 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:00:04.145 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:00:04.147 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:00:04.152 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1042,25)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1042,25)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:00:04.154 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:00:04.155 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:00:04.156 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:00:04.157 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:00:04.158 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:00:04.161 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16470 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 22:00:04.162 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16470::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 22:00:04.163 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:00:04.165 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16465::oid
	ORDER BY conname
2023-12-08 22:00:04.167 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16465::oid
	
2023-12-08 22:00:04.168 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:00:04.452 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:00:04.473 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:00:04.486 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:00:04.501 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:00:15.103 PST [4163] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:00:15.112 PST [4163] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-08 22:00:15.120 PST [4163] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:00:59.470 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:02:41.983 PST [4163] LOG:  statement: CREATE TABLE public.orders
	(
	    order_id character varying(255),
	    user_id character varying(255),
	    restaurant_id character varying(255),
	    order_total numeric(255, 2)
	);
	
	
	ALTER TABLE IF EXISTS public.orders
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-08 22:02:41.994 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'orders'::text AND nspname = 'public';
	
2023-12-08 22:02:41.995 PST [4163] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'orders'
2023-12-08 22:02:48.960 PST [4163] LOG:  execute _pg3_1: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:02:48.963 PST [4163] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-08 22:02:48.967 PST [4163] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:03:00.667 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:04:35.470 PST [4163] LOG:  statement: CREATE TABLE public.address
	(
	    id integer NOT NULL,
	    user_id character varying(255),
	    street character varying(255),
	    pincode character varying(255),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.address
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-08 22:04:35.484 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'address'::text AND nspname = 'public';
	
2023-12-08 22:04:35.485 PST [4163] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'address'
2023-12-08 22:04:45.634 PST [4163] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:04:45.641 PST [4163] LOG:  execute _pg3_1: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:04:45.644 PST [4163] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-08 22:06:10.423 PST [36662] LOG:  checkpoint starting: time
2023-12-08 22:06:13.447 PST [36662] LOG:  checkpoint complete: wrote 29 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=2.993 s, sync=0.016 s, total=3.025 s; sync files=30, longest=0.002 s, average=0.001 s; distance=166 kB, estimate=13084 kB
2023-12-08 22:07:02.823 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:10:12.788 PST [4163] LOG:  statement: CREATE TABLE public.users
	(
	    user_id character varying(255) NOT NULL,
	    name character varying(255),
	    email character varying(255),
	    password character varying(255),
	    phone character varying(255),
	    PRIMARY KEY (user_id)
	);
	
	
	ALTER TABLE IF EXISTS public.users
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-08 22:10:12.795 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'users'::text AND nspname = 'public';
	
2023-12-08 22:10:12.796 PST [4163] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'users'
2023-12-08 22:11:10.474 PST [36662] LOG:  checkpoint starting: time
2023-12-08 22:11:14.701 PST [36662] LOG:  checkpoint complete: wrote 42 buffers (0.3%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.197 s, sync=0.019 s, total=4.228 s; sync files=31, longest=0.006 s, average=0.001 s; distance=257 kB, estimate=11801 kB
2023-12-08 22:15:50.697 PST [4163] LOG:  execute _pg3_1: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:15:50.702 PST [4163] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:15:50.704 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16565::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16565::oid ORDER BY rel.relname;
2023-12-08 22:15:50.720 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:15:50.723 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:15:50.726 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16565::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:15:50.735 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:15:50.737 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:15:50.740 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:15:50.742 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:15:50.745 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:15:50.747 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:15:50.752 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16570 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 22:15:50.759 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16570::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 22:15:50.761 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:15:50.766 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16565::oid
	ORDER BY conname
2023-12-08 22:15:50.767 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16565::oid
	
2023-12-08 22:15:50.769 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:15:51.093 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:15:51.107 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:15:51.123 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:15:51.146 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:02.709 PST [4163] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-08 22:16:12.001 PST [4163] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16572::OID
	
2023-12-08 22:16:17.920 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16565::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16565::oid ORDER BY rel.relname;
2023-12-08 22:16:17.929 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:17.931 PST [4163] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-08 22:16:17.939 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16565::oid;
	
2023-12-08 22:16:17.947 PST [4163] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-08 22:16:17.949 PST [4163] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16565::oid;
2023-12-08 22:16:17.950 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:17.952 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16565::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:16:17.958 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:16:17.960 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:17.961 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:17.963 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:17.964 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:17.965 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:16:17.968 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16570 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 22:16:17.968 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16570::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 22:16:17.969 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:16:17.972 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16565::oid
	ORDER BY conname
2023-12-08 22:16:17.974 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16565::oid
	
2023-12-08 22:16:17.975 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:16:17.983 PST [4163] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16572::oid
2023-12-08 22:16:17.987 PST [4163] LOG:  statement: ALTER TABLE IF EXISTS public.address
	    ADD FOREIGN KEY (user_id)
	    REFERENCES public.users (user_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-08 22:16:17.997 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16565::oid;
	
2023-12-08 22:16:23.257 PST [4163] LOG:  execute _pg3_1: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:16:23.260 PST [4163] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:16:23.266 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-08 22:16:23.272 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.274 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.276 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:16:23.282 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:16:23.283 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.285 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.286 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.287 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.288 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.289 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:23.290 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:16:23.293 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 22:16:23.294 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16533::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 22:16:23.295 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:16:23.297 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16527::oid
	ORDER BY conname
2023-12-08 22:16:23.298 PST [4163] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16527::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-08 22:16:23.299 PST [4163] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-08 22:16:23.300 PST [4163] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	   AND conname IS NULL
2023-12-08 22:16:23.303 PST [4163] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column
	
2023-12-08 22:16:23.303 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16527::oid
	
2023-12-08 22:16:23.304 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:16:23.614 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:23.626 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:23.640 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:23.651 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:23.664 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:23.677 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:36.571 PST [4163] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:16:36.575 PST [4163] LOG:  execute _pg3_1: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:16:36.577 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16560::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16560::oid ORDER BY rel.relname;
2023-12-08 22:16:36.584 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:36.586 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:36.588 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16560::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:16:36.594 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:16:36.595 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:36.596 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:36.597 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:36.598 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:16:36.599 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:16:36.601 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:16:36.603 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16560::oid
	ORDER BY conname
2023-12-08 22:16:36.604 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16560::oid
	
2023-12-08 22:16:36.605 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:16:36.927 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:36.940 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:36.953 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:37.135 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:16:51.148 PST [4163] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-08 22:17:06.351 PST [4163] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16572::OID
	
2023-12-08 22:17:24.043 PST [4163] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16572::OID
	
2023-12-08 22:17:32.539 PST [4163] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16465::OID
	
2023-12-08 22:17:37.679 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16560::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16560::oid ORDER BY rel.relname;
2023-12-08 22:17:37.687 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:37.689 PST [4163] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-08 22:17:37.690 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16560::oid;
	
2023-12-08 22:17:37.690 PST [4163] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-08 22:17:37.691 PST [4163] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16560::oid;
2023-12-08 22:17:37.691 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:37.693 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16560::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:17:37.700 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:17:37.701 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:37.702 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:37.703 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:37.704 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:37.705 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:17:37.707 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:17:37.709 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16560::oid
	ORDER BY conname
2023-12-08 22:17:37.710 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16560::oid
	
2023-12-08 22:17:37.711 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:17:37.716 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16560::oid
	    AND att.attnum = 1::int
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:17:37.956 PST [4163] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16572::oid
2023-12-08 22:17:37.957 PST [4163] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-08 22:17:37.959 PST [4163] LOG:  statement: ALTER TABLE IF EXISTS public.orders
	    ALTER COLUMN order_id SET NOT NULL;
	ALTER TABLE IF EXISTS public.orders
	    ADD PRIMARY KEY (order_id);
	ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (user_id)
	    REFERENCES public.users (user_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
	
	ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-08 22:17:37.963 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16560::oid;
	
2023-12-08 22:17:41.555 PST [4163] LOG:  execute _pg3_1: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:17:41.559 PST [4163] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:17:41.562 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16553::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16553::oid ORDER BY rel.relname;
2023-12-08 22:17:41.571 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:41.572 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:41.574 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16553::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:17:41.579 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:17:41.581 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:41.582 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:41.583 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:41.584 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:17:41.587 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16558 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 22:17:41.587 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16558::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 22:17:41.588 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:17:41.591 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16553::oid
	ORDER BY conname
2023-12-08 22:17:41.592 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16553::oid
	
2023-12-08 22:17:41.593 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:17:42.073 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:17:42.092 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:17:42.107 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:17:46.816 PST [4163] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-08 22:17:54.793 PST [4163] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16560::OID
	
2023-12-08 22:17:58.886 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16553::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16553::oid ORDER BY rel.relname;
2023-12-08 22:17:58.893 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:58.894 PST [4163] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-08 22:17:58.895 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16553::oid;
	
2023-12-08 22:17:58.896 PST [4163] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-08 22:17:58.896 PST [4163] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16553::oid;
2023-12-08 22:17:58.897 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:58.898 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16553::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:17:58.904 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:17:58.905 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:58.905 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:58.906 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:17:58.907 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:17:58.910 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16558 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 22:17:58.911 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16558::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 22:17:58.911 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:17:58.914 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16553::oid
	ORDER BY conname
2023-12-08 22:17:58.915 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16553::oid
	
2023-12-08 22:17:58.916 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:17:58.919 PST [4163] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16560::oid
2023-12-08 22:17:58.920 PST [4163] LOG:  statement: ALTER TABLE IF EXISTS public.payment
	    ADD FOREIGN KEY (order_id)
	    REFERENCES public.orders (order_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-08 22:17:58.923 PST [4163] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16553::oid;
	
2023-12-08 22:17:58.966 PST [36662] LOG:  checkpoint starting: time
2023-12-08 22:18:03.006 PST [36662] LOG:  checkpoint complete: wrote 40 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.019 s, sync=0.014 s, total=4.040 s; sync files=29, longest=0.006 s, average=0.001 s; distance=231 kB, estimate=10644 kB
2023-12-08 22:18:05.704 PST [4163] LOG:  execute _pg3_1: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 22:18:05.709 PST [4163] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16572::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16572::oid ORDER BY rel.relname;
2023-12-08 22:18:05.716 PST [4163] LOG:  execute _pg3_2: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 22:18:05.718 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:18:05.722 PST [4163] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:18:05.725 PST [4163] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16572::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 22:18:05.731 PST [4163] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043)
	) t
	GROUP BY t.main_oid;
2023-12-08 22:18:05.732 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:18:05.733 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:18:05.735 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:18:05.737 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:18:05.738 PST [4163] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 22:18:05.739 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16572::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 22:18:05.741 PST [4163] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16577 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 22:18:05.742 PST [4163] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16577::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 22:18:05.744 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16572::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 22:18:05.746 PST [4163] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16572::oid
	ORDER BY conname
2023-12-08 22:18:05.748 PST [4163] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16572::oid
	
2023-12-08 22:18:05.748 PST [4163] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16572::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 22:18:06.060 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:18:06.072 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:18:06.087 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:18:06.099 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:18:06.110 PST [4163] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 22:18:10.735 PST [4163] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-08 22:21:08.263 PST [6152] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 22:21:08.267 PST [6152] LOG:  statement: SELECT version()
2023-12-08 22:21:08.268 PST [6152] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 22:21:08.288 PST [6152] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 22:21:08.292 PST [6152] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 22:21:08.346 PST [6153] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 22:21:08.350 PST [6153] LOG:  statement: SELECT version()
2023-12-08 22:21:08.351 PST [6153] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 22:21:08.353 PST [6153] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 22:21:08.354 PST [6153] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 22:21:08.380 PST [6154] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 22:21:08.382 PST [6154] LOG:  statement: SELECT version()
2023-12-08 22:21:08.382 PST [6154] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 22:21:08.383 PST [6154] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 22:21:08.384 PST [6154] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 22:25:02.571 PST [36662] LOG:  checkpoint starting: time
2023-12-08 22:25:02.917 PST [36662] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.325 s, sync=0.007 s, total=0.347 s; sync files=3, longest=0.006 s, average=0.003 s; distance=20 kB, estimate=9582 kB
2023-12-08 22:37:23.365 PST [6487] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 22:37:23.366 PST [6487] LOG:  statement: SELECT version()
2023-12-08 22:37:23.368 PST [6487] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 22:37:23.370 PST [6487] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 22:37:23.371 PST [6487] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 22:37:23.383 PST [6488] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 22:37:23.385 PST [6488] LOG:  statement: SELECT version()
2023-12-08 22:37:23.385 PST [6488] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 22:37:23.386 PST [6488] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 22:37:23.387 PST [6488] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 22:37:23.401 PST [6489] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 22:37:23.403 PST [6489] LOG:  statement: SELECT version()
2023-12-08 22:37:23.403 PST [6489] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 22:37:23.404 PST [6489] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 22:37:23.405 PST [6489] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 23:12:08.732 PST [6489] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-08 23:12:08.751 PST [6489] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-08 23:12:08.754 PST [6489] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-08 23:12:08.847 PST [6489] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.850 PST [6489] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.855 PST [6489] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 23:12:08.884 PST [6489] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-08 23:12:08.887 PST [6489] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.889 PST [6489] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.890 PST [6489] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.891 PST [6489] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.893 PST [6489] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.895 PST [6489] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:12:08.896 PST [6489] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 23:12:08.901 PST [6489] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 23:12:08.902 PST [6489] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16533::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 23:12:08.904 PST [6489] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 23:12:08.906 PST [6489] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16527::oid
	ORDER BY conname
2023-12-08 23:12:08.908 PST [6489] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16527::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-08 23:12:08.909 PST [6489] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-08 23:12:08.911 PST [6489] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	   AND conname IS NULL
2023-12-08 23:12:08.914 PST [6489] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column
	
2023-12-08 23:12:08.915 PST [6489] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16527::oid
	
2023-12-08 23:12:08.916 PST [6489] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-08 23:12:09.070 PST [6489] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 23:12:09.088 PST [6489] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 23:12:09.105 PST [6489] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 23:12:09.120 PST [6489] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 23:12:09.139 PST [6489] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 23:12:09.154 PST [6489] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-08 23:13:49.363 PST [36662] LOG:  checkpoint starting: time
2023-12-08 23:13:49.594 PST [36662] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.211 s, sync=0.006 s, total=0.231 s; sync files=1, longest=0.006 s, average=0.006 s; distance=16 kB, estimate=8625 kB
2023-12-08 23:27:08.335 PST [7671] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 23:27:08.338 PST [7671] LOG:  statement: SELECT version()
2023-12-08 23:27:08.339 PST [7671] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 23:27:08.341 PST [7671] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 23:27:08.342 PST [7671] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 23:27:08.358 PST [7672] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 23:27:08.360 PST [7672] LOG:  statement: SELECT version()
2023-12-08 23:27:08.360 PST [7672] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 23:27:08.361 PST [7672] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 23:27:08.362 PST [7672] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 23:27:08.375 PST [7673] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-08 23:27:08.377 PST [7673] LOG:  statement: SELECT version()
2023-12-08 23:27:08.377 PST [7673] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-08 23:27:08.378 PST [7673] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-08 23:27:08.379 PST [7673] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-08 23:56:07.780 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16572::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16572::oid ORDER BY rel.relname;
2023-12-08 23:56:07.838 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:56:07.840 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16572::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:56:07.842 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16572::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-08 23:56:07.854 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043)
	) t
	GROUP BY t.main_oid;
2023-12-08 23:56:07.856 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:56:07.857 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:56:07.859 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:56:07.860 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:56:07.861 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16572::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-08 23:56:07.863 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16572::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-08 23:56:07.867 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16577 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-08 23:56:07.868 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16577::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-08 23:56:07.869 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16572::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-08 23:56:07.872 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16572::oid
	ORDER BY conname
2023-12-08 23:56:07.873 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16572::oid
	
2023-12-08 23:56:07.874 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16572::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:27:21.356 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:27:21.360 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:27:21.369 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16565::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16565::oid ORDER BY rel.relname;
2023-12-09 00:27:21.377 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:21.379 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16565::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:21.382 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16565::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:27:21.389 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:27:21.390 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:21.392 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:21.393 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:21.394 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16565::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:21.394 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:27:21.398 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16570 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:27:21.399 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16570::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:27:21.400 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:27:21.402 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16565::oid
	ORDER BY conname
2023-12-09 00:27:21.406 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16565::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16572::oid
	    AND a2.attnum=1
	
2023-12-09 00:27:21.407 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16572::oid
2023-12-09 00:27:21.408 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16565::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16565::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16565::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16565::oid
	   AND conname IS NULL
2023-12-09 00:27:21.411 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16570 , 1 , true) AS column
	
2023-12-09 00:27:21.412 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16565::oid
	
2023-12-09 00:27:21.414 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16565::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:27:22.175 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:22.198 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:22.215 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:22.232 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:34.233 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:27:34.236 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:27:34.238 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16560::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16560::oid ORDER BY rel.relname;
2023-12-09 00:27:34.247 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:34.248 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16560::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:34.250 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16560::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:27:34.256 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:27:34.257 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:34.258 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:34.259 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:34.260 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16560::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:34.262 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:27:34.266 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16584 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:27:34.266 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16584::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:27:34.267 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:27:34.269 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16560::oid
	ORDER BY conname
2023-12-09 00:27:34.270 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16560::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-09 00:27:34.271 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-09 00:27:34.272 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	   AND conname IS NULL
2023-12-09 00:27:34.274 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16584 , 1 , true) AS column
	
2023-12-09 00:27:34.275 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16560::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16572::oid
	    AND a2.attnum=1
	
2023-12-09 00:27:34.276 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16572::oid
2023-12-09 00:27:34.277 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16560::oid
	   AND conname IS NULL
2023-12-09 00:27:34.280 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16584 , 1 , true) AS column
	
2023-12-09 00:27:34.280 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16560::oid
	
2023-12-09 00:27:34.281 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16560::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:27:34.589 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:34.606 PST [7673] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:34.619 PST [7673] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:34.636 PST [7673] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:45.196 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:27:45.206 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16553::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16553::oid ORDER BY rel.relname;
2023-12-09 00:27:45.213 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:27:45.216 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:45.218 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16553::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:45.220 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16553::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:27:45.227 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:27:45.228 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:45.229 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:45.231 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16553::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:27:45.233 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:27:45.235 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16558 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:27:45.236 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16558::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:27:45.236 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:27:45.239 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16553::oid
	ORDER BY conname
2023-12-09 00:27:45.241 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16553::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16560::oid
	    AND a2.attnum=1
	
2023-12-09 00:27:45.242 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16560::oid
2023-12-09 00:27:45.244 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16553::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16553::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16553::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16553::oid
	   AND conname IS NULL
2023-12-09 00:27:45.248 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16558 , 1 , true) AS column
	
2023-12-09 00:27:45.249 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16553::oid
	
2023-12-09 00:27:45.250 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16553::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:27:45.613 PST [7673] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:45.629 PST [7673] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:45.649 PST [7673] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:27:58.633 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16565::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16565::oid ORDER BY rel.relname;
2023-12-09 00:27:58.640 PST [7673] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 00:27:58.649 PST [7673] LOG:  statement: DROP TABLE IF EXISTS public.address CASCADE;
2023-12-09 00:27:58.688 PST [7673] LOG:  execute <unnamed>: DEALLOCATE ALL
2023-12-09 00:28:20.446 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16560::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16560::oid ORDER BY rel.relname;
2023-12-09 00:28:20.453 PST [7673] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 00:28:20.454 PST [7673] LOG:  statement: DROP TABLE IF EXISTS public.orders CASCADE;
2023-12-09 00:28:26.011 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16553::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16553::oid ORDER BY rel.relname;
2023-12-09 00:28:26.018 PST [7673] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 00:28:26.019 PST [7673] LOG:  statement: DROP TABLE IF EXISTS public.payment CASCADE;
2023-12-09 00:28:32.370 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16572::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16572::oid ORDER BY rel.relname;
2023-12-09 00:28:32.376 PST [7673] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 00:28:32.377 PST [7673] LOG:  statement: DROP TABLE IF EXISTS public.users CASCADE;
2023-12-09 00:28:46.837 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:28:46.845 PST [7673] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 00:28:46.849 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:28:58.591 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:30:06.279 PST [7673] LOG:  statement: CREATE TABLE public.payment
	(
	    payment_id serial NOT NULL,
	    order_id integer,
	    amount numeric(255, 2),
	    PRIMARY KEY (payment_id)
	);
	
	
	ALTER TABLE IF EXISTS public.payment
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 00:30:06.292 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'payment'::text AND nspname = 'public';
	
2023-12-09 00:30:06.293 PST [7673] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'payment'
2023-12-09 00:30:11.380 PST [7673] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 00:30:11.384 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:30:11.386 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:30:22.361 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:31:27.066 PST [7673] LOG:  statement: CREATE TABLE public.orders
	(
	    order_id serial NOT NULL,
	    user_id integer,
	    restaurant_id character varying(255),
	    order_total numeric(255, 2),
	    PRIMARY KEY (order_id)
	);
	
	
	ALTER TABLE IF EXISTS public.orders
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 00:31:27.080 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'orders'::text AND nspname = 'public';
	
2023-12-09 00:31:27.080 PST [7673] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'orders'
2023-12-09 00:31:31.826 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:31:31.831 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:31:31.834 PST [7673] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 00:31:34.547 PST [36662] LOG:  checkpoint starting: time
2023-12-09 00:31:38.471 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:31:41.309 PST [36662] LOG:  checkpoint complete: wrote 67 buffers (0.4%); 0 WAL file(s) added, 0 removed, 0 recycled; write=6.728 s, sync=0.023 s, total=6.763 s; sync files=43, longest=0.006 s, average=0.001 s; distance=368 kB, estimate=7799 kB
2023-12-09 00:32:39.243 PST [7673] LOG:  statement: CREATE TABLE public.address
	(
	    id serial NOT NULL,
	    user_id integer,
	    street character varying(255),
	    pincode character varying(6),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.address
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 00:32:39.250 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'address'::text AND nspname = 'public';
	
2023-12-09 00:32:39.251 PST [7673] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'address'
2023-12-09 00:32:48.133 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:32:48.140 PST [7673] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 00:32:48.144 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:32:55.786 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:33:41.566 PST [7673] LOG:  statement: CREATE TABLE public.users
	(
	    user_id serial NOT NULL,
	    username character varying(255),
	    email character varying(255),
	    password character varying(255),
	    phone character varying(255),
	    PRIMARY KEY (user_id)
	);
	
	
	ALTER TABLE IF EXISTS public.users
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 00:33:41.588 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'users'::text AND nspname = 'public';
	
2023-12-09 00:33:41.589 PST [7673] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'users'
2023-12-09 00:33:49.607 PST [7673] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:33:49.613 PST [7673] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:33:49.614 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16617::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16617::oid ORDER BY rel.relname;
2023-12-09 00:33:49.626 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:33:49.627 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:33:49.629 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:33:49.636 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:33:49.637 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:33:49.638 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:33:49.639 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:33:49.640 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:33:49.641 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:33:49.643 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16621 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:33:49.644 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16621::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:33:49.645 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:33:49.647 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16617::oid
	ORDER BY conname
2023-12-09 00:33:49.648 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16617::oid
	
2023-12-09 00:33:49.649 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:33:50.211 PST [7673] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:33:50.228 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:33:50.241 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:33:50.254 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:33:57.713 PST [7673] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 00:34:28.422 PST [7673] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16624::OID
	
2023-12-09 00:34:38.564 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16617::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16617::oid ORDER BY rel.relname;
2023-12-09 00:34:38.571 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:38.573 PST [7673] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 00:34:38.573 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16617::oid;
	
2023-12-09 00:34:38.574 PST [7673] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 00:34:38.575 PST [7673] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16617::oid;
2023-12-09 00:34:38.575 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:38.577 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:34:38.583 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:34:38.584 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:38.585 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:38.587 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:38.588 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:38.589 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:34:38.591 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16621 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:34:38.591 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16621::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:34:38.592 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:34:38.594 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16617::oid
	ORDER BY conname
2023-12-09 00:34:38.596 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16617::oid
	
2023-12-09 00:34:38.596 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:34:38.606 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16624::oid
2023-12-09 00:34:38.607 PST [7673] LOG:  statement: ALTER TABLE IF EXISTS public.address
	    ADD FOREIGN KEY (user_id)
	    REFERENCES public.users (user_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 00:34:38.608 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16617::oid;
	
2023-12-09 00:34:48.084 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:34:48.086 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:34:48.087 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16603::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16603::oid ORDER BY rel.relname;
2023-12-09 00:34:48.095 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:48.096 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:48.098 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16603::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:34:48.103 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:34:48.105 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:48.106 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:48.107 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:34:48.109 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:34:48.111 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:34:48.111 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16607::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:34:48.112 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:34:48.114 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16603::oid
	ORDER BY conname
2023-12-09 00:34:48.115 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16603::oid
	
2023-12-09 00:34:48.116 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:34:48.469 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:34:48.485 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:34:48.500 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:34:55.737 PST [7673] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 00:35:12.387 PST [7673] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16610::OID
	
2023-12-09 00:35:17.607 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16603::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16603::oid ORDER BY rel.relname;
2023-12-09 00:35:17.622 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:17.624 PST [7673] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 00:35:17.625 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16603::oid;
	
2023-12-09 00:35:17.626 PST [7673] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 00:35:17.626 PST [7673] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16603::oid;
2023-12-09 00:35:17.627 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:17.629 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16603::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:35:17.635 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:35:17.636 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:17.638 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:17.639 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:17.641 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:35:17.643 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:35:17.644 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16607::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:35:17.645 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:35:17.647 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16603::oid
	ORDER BY conname
2023-12-09 00:35:17.649 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16603::oid
	
2023-12-09 00:35:17.665 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:35:17.679 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16610::oid
2023-12-09 00:35:17.688 PST [7673] LOG:  statement: ALTER TABLE IF EXISTS public.payment
	    ADD FOREIGN KEY (order_id)
	    REFERENCES public.orders (order_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 00:35:17.701 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16603::oid;
	
2023-12-09 00:35:23.775 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:35:23.779 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16610::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16610::oid ORDER BY rel.relname;
2023-12-09 00:35:23.786 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:35:23.787 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:23.789 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:23.791 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16610::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:35:23.799 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:35:23.801 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:23.802 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:23.803 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:23.804 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:35:23.806 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:35:23.808 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:35:23.808 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16614::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:35:23.809 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:35:23.812 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16610::oid
	ORDER BY conname
2023-12-09 00:35:23.813 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16610::oid
	
2023-12-09 00:35:23.814 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:35:24.194 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:35:24.207 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:35:24.222 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:35:24.235 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:35:29.456 PST [7673] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 00:35:53.039 PST [7673] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16624::OID
	
2023-12-09 00:36:05.749 PST [7673] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16624::OID
	
2023-12-09 00:36:15.531 PST [7673] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16465::OID
	
2023-12-09 00:36:34.309 PST [36662] LOG:  checkpoint starting: time
2023-12-09 00:36:34.388 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16610::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16610::oid ORDER BY rel.relname;
2023-12-09 00:36:34.395 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:34.397 PST [7673] LOG:  execute _pg3_4: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 00:36:34.398 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16610::oid;
	
2023-12-09 00:36:34.398 PST [7673] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 00:36:34.399 PST [7673] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16610::oid;
2023-12-09 00:36:34.399 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:34.401 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16610::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:36:34.407 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:36:34.408 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:34.409 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:34.410 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:34.411 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:34.412 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:36:34.415 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:36:34.415 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16614::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:36:34.416 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:36:34.418 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16610::oid
	ORDER BY conname
2023-12-09 00:36:34.420 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16610::oid
	
2023-12-09 00:36:34.421 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:36:34.424 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16624::oid
2023-12-09 00:36:34.425 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-09 00:36:34.427 PST [7673] LOG:  statement: ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (user_id)
	    REFERENCES public.users (user_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
	
	ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 00:36:34.430 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16610::oid;
	
2023-12-09 00:36:39.002 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 00:36:39.004 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 00:36:39.010 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16610::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16610::oid ORDER BY rel.relname;
2023-12-09 00:36:39.018 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:39.021 PST [7673] LOG:  execute _pg3_5: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:39.023 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16610::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 00:36:39.029 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 00:36:39.033 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:39.034 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:39.036 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:39.037 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 00:36:39.038 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 00:36:39.042 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 00:36:39.042 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16614::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 00:36:39.043 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 00:36:39.046 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16610::oid
	ORDER BY conname
2023-12-09 00:36:39.047 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16610::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-09 00:36:39.049 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-09 00:36:39.049 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	   AND conname IS NULL
2023-12-09 00:36:39.052 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column
	
2023-12-09 00:36:39.052 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16610::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16624::oid
	    AND a2.attnum=1
	
2023-12-09 00:36:39.053 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16624::oid
2023-12-09 00:36:39.054 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	   AND conname IS NULL
2023-12-09 00:36:39.057 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column
	
2023-12-09 00:36:39.058 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16610::oid
	
2023-12-09 00:36:39.059 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 00:36:39.433 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:36:39.457 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:36:39.471 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:36:39.487 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 00:36:39.682 PST [36662] LOG:  checkpoint complete: wrote 53 buffers (0.3%); 0 WAL file(s) added, 0 removed, 0 recycled; write=5.354 s, sync=0.013 s, total=5.373 s; sync files=42, longest=0.005 s, average=0.001 s; distance=275 kB, estimate=7047 kB
2023-12-09 00:45:07.970 PST [9944] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-09 00:54:39.187 PST [10218] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 00:54:39.194 PST [10218] LOG:  statement: SELECT version()
2023-12-09 00:54:39.197 PST [10218] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 00:54:39.206 PST [10218] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 00:54:39.220 PST [10218] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 00:54:39.254 PST [7673] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16624;
	
2023-12-09 00:54:39.318 PST [7673] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-09 00:54:39.326 PST [7673] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-09 00:54:39.334 PST [10218] LOG:  statement: SELECT * FROM public.users
	ORDER BY user_id ASC 
2023-12-09 00:54:39.465 PST [10218] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 00:54:39.559 PST [10218] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 00:54:39.559 PST [10218] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 00:56:34.743 PST [36662] LOG:  checkpoint starting: time
2023-12-09 00:56:35.488 PST [36662] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.727 s, sync=0.009 s, total=0.746 s; sync files=6, longest=0.006 s, average=0.002 s; distance=84 kB, estimate=6351 kB
2023-12-09 01:01:48.314 PST [10501] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:01:48.319 PST [10501] ERROR:  column "username" does not exist at character 27
2023-12-09 01:01:48.319 PST [10501] HINT:  Perhaps you meant to reference the column "users.user_name".
2023-12-09 01:01:48.319 PST [10501] STATEMENT:  SELECT * FROM users WHERE username = $1
2023-12-09 01:01:56.244 PST [10506] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:01:56.245 PST [10506] ERROR:  column "username" does not exist at character 27
2023-12-09 01:01:56.245 PST [10506] HINT:  Perhaps you meant to reference the column "users.user_name".
2023-12-09 01:01:56.245 PST [10506] STATEMENT:  SELECT * FROM users WHERE username = $1
2023-12-09 01:02:35.671 PST [7671] LOG:  statement: 
	SELECT
	    has_table_privilege(
	      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
	    ) has_priviledge
	WHERE EXISTS(
	    SELECT has_schema_privilege('pgagent', 'USAGE')
	    WHERE EXISTS(
	        SELECT cl.oid FROM pg_catalog.pg_class cl
	        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
	        WHERE relname='pga_job' AND nspname='pgagent'
	    )
	)
	
2023-12-09 01:02:35.776 PST [7671] LOG:  statement: SELECT
	    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
	    db.datistemplate AS is_template,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner,
	    descr.description
	FROM
	    pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE         db.oid > 16383::OID OR db.datname IN ('postgres', 'edb')
	
	ORDER BY datname;
2023-12-09 01:02:35.859 PST [7673] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-09 01:02:35.899 PST [7673] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-09 01:02:35.963 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-09 01:02:38.346 PST [7673] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-09 01:02:38.349 PST [7673] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-09 01:02:38.351 PST [10218] LOG:  statement: SELECT * FROM public.users
	ORDER BY user_id ASC 
2023-12-09 01:02:38.408 PST [10218] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:02:38.412 PST [10218] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:02:38.412 PST [10218] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 01:03:29.662 PST [10542] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 01:03:29.665 PST [10542] LOG:  statement: SELECT version()
2023-12-09 01:03:29.667 PST [10542] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 01:03:29.669 PST [10542] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 01:03:29.672 PST [10542] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 01:03:39.165 PST [10542] LOG:  statement: SELECT * FROM users WHERE username = 1
2023-12-09 01:03:39.166 PST [10542] ERROR:  operator does not exist: character varying = integer at character 36
2023-12-09 01:03:39.166 PST [10542] HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-12-09 01:03:39.166 PST [10542] STATEMENT:  SELECT * FROM users WHERE username = 1
2023-12-09 01:03:44.994 PST [10542] LOG:  statement: SELECT * FROM users WHERE username = 1;
2023-12-09 01:03:44.994 PST [10542] ERROR:  operator does not exist: character varying = integer at character 36
2023-12-09 01:03:44.994 PST [10542] HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
2023-12-09 01:03:44.994 PST [10542] STATEMENT:  SELECT * FROM users WHERE username = 1;
2023-12-09 01:04:14.890 PST [10562] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 01:04:14.893 PST [10562] LOG:  statement: SELECT version()
2023-12-09 01:04:14.894 PST [10562] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 01:04:14.897 PST [10562] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 01:04:14.898 PST [10562] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 01:04:14.902 PST [7673] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-09 01:04:14.907 PST [7673] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-09 01:04:14.912 PST [10562] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-09 01:04:15.300 PST [10562] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16507::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:04:15.315 PST [10562] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:04:15.315 PST [10562] DETAIL:  parameters: $1 = '{23,1043,1043,1700,1700}'
2023-12-09 01:04:20.965 PST [10565] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:04:20.965 PST [10565] LOG:  statement: SELECT pg_cancel_backend(10562);
2023-12-09 01:04:21.769 PST [7671] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-09 01:04:30.142 PST [10569] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:04:30.142 PST [10569] LOG:  statement: SELECT pg_cancel_backend(10218);
2023-12-09 01:04:30.155 PST [7671] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-09 01:04:36.923 PST [10572] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:04:36.923 PST [10572] LOG:  statement: SELECT pg_cancel_backend(10542);
2023-12-09 01:04:36.925 PST [7671] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-09 01:04:44.804 PST [10576] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 01:04:44.808 PST [10576] LOG:  statement: SELECT version()
2023-12-09 01:04:44.809 PST [10576] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 01:04:44.811 PST [10576] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 01:04:44.812 PST [10576] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 01:04:44.817 PST [7673] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16624;
	
2023-12-09 01:04:45.242 PST [7673] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-09 01:04:45.247 PST [7673] LOG:  execute _pg3_6: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-09 01:04:45.249 PST [10576] LOG:  statement: SELECT * FROM public.users
	ORDER BY user_id ASC 
2023-12-09 01:04:45.394 PST [10576] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:04:45.402 PST [10576] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:04:45.402 PST [10576] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 01:05:04.748 PST [10588] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:05:04.749 PST [10588] ERROR:  column "user_id" does not exist at character 27
2023-12-09 01:05:04.749 PST [10588] STATEMENT:  SELECT * FROM users WHERE user_id = $1
2023-12-09 01:05:36.744 PST [10627] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:05:36.744 PST [10627] ERROR:  column "user_id" does not exist at character 27
2023-12-09 01:05:36.744 PST [10627] STATEMENT:  SELECT * FROM users WHERE user_id = $1
2023-12-09 01:06:09.579 PST [10649] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 01:06:09.582 PST [10649] LOG:  statement: SELECT version()
2023-12-09 01:06:09.583 PST [10649] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 01:06:09.585 PST [10649] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 01:06:09.587 PST [10649] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 01:06:14.912 PST [10649] LOG:  statement: SELECT * FROM users WHERE user_id = 1
2023-12-09 01:06:14.997 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:06:15.001 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16624)::oid
	)::oid[])
2023-12-09 01:06:15.020 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:06:15.026 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16624;
	
2023-12-09 01:06:15.029 PST [10649] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:06:15.029 PST [10649] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 01:06:34.570 PST [36662] LOG:  checkpoint starting: time
2023-12-09 01:06:34.901 PST [36662] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.316 s, sync=0.003 s, total=0.331 s; sync files=2, longest=0.002 s, average=0.002 s; distance=18 kB, estimate=5717 kB
2023-12-09 01:10:51.093 PST [10766] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:10:51.094 PST [10766] ERROR:  column "username" does not exist at character 27
2023-12-09 01:10:51.094 PST [10766] HINT:  Perhaps you meant to reference the column "users.user_name".
2023-12-09 01:10:51.094 PST [10766] STATEMENT:  SELECT * FROM users WHERE username = $1
2023-12-09 01:11:50.956 PST [10809] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:11:50.957 PST [10809] ERROR:  column "username" does not exist at character 27
2023-12-09 01:11:50.957 PST [10809] HINT:  Perhaps you meant to reference the column "users.user_name".
2023-12-09 01:11:50.957 PST [10809] STATEMENT:  SELECT * FROM users WHERE "username" = $1
2023-12-09 01:12:50.606 PST [10649] LOG:  statement: SELECT * FROM users WHERE "username" = 'name'
2023-12-09 01:12:50.643 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:12:50.644 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16624)::oid
	)::oid[])
2023-12-09 01:12:50.646 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:12:50.650 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16624;
	
2023-12-09 01:12:50.652 PST [10649] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:12:50.652 PST [10649] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 01:16:21.599 PST [10930] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:16:21.600 PST [10930] ERROR:  column "username" does not exist at character 27
2023-12-09 01:16:21.600 PST [10930] HINT:  Perhaps you meant to reference the column "users.user_name".
2023-12-09 01:16:21.600 PST [10930] STATEMENT:  SELECT * FROM users WHERE username = $1
2023-12-09 01:19:19.217 PST [11007] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:19:19.218 PST [11007] ERROR:  column "user_id" does not exist at character 8
2023-12-09 01:19:19.218 PST [11007] STATEMENT:  SELECT user_id, username, email, password, phone FROM users WHERE username = $1
2023-12-09 01:22:10.429 PST [11085] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:22:10.429 PST [11085] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:22:10.429 PST [11085] STATEMENT:  INSERT INTO users ("username", "email", "password", "phone") VALUES ($1, $2, $3, $4) RETURNING "user_id"
2023-12-09 01:22:10.430 PST [11085] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:22:24.399 PST [11092] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:22:24.400 PST [11092] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:22:24.400 PST [11092] STATEMENT:  INSERT INTO users ("username", "email", "password", "phone") VALUES ($1, $2, $3, $4) RETURNING "user_id"
2023-12-09 01:22:24.400 PST [11092] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:22:29.918 PST [10649] LOG:  statement: SELECT * FROM users WHERE "username" = 'name'
2023-12-09 01:22:29.953 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:22:29.955 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16624)::oid
	)::oid[])
2023-12-09 01:22:29.957 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:22:29.961 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16624;
	
2023-12-09 01:22:29.963 PST [10649] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:22:29.963 PST [10649] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 01:22:34.771 PST [10649] LOG:  statement: SELECT * FROM users 
2023-12-09 01:22:34.810 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:22:34.812 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16624)::oid
	)::oid[])
2023-12-09 01:22:34.814 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:22:34.816 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16624;
	
2023-12-09 01:22:34.819 PST [10649] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:22:34.819 PST [10649] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 01:23:02.282 PST [11107] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:23:02.283 PST [11107] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:23:02.283 PST [11107] STATEMENT:  INSERT INTO users ("username", "email", "password", "phone") VALUES ($1, $2, $3, $4) RETURNING "user_id"
2023-12-09 01:23:02.283 PST [11107] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:27:47.430 PST [11241] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:27:47.431 PST [11241] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:27:47.431 PST [11241] STATEMENT:  INSERT INTO users ("username", "email", "password", "phone") VALUES ($1, $2, $3, $4) RETURNING "user_id"
2023-12-09 01:27:47.431 PST [11241] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:29:07.524 PST [11289] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:29:07.525 PST [11289] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:29:07.525 PST [11289] STATEMENT:  INSERT INTO users (username, email, password, phone_number) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:29:07.525 PST [11289] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:29:57.019 PST [11320] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:29:57.020 PST [11320] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:29:57.020 PST [11320] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:29:57.020 PST [11320] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:30:03.399 PST [11330] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:30:03.399 PST [11330] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:30:03.399 PST [11330] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:30:03.400 PST [11330] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:32:20.577 PST [11415] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:32:20.578 PST [11415] ERROR:  column "username" of relation "users" does not exist at character 22
2023-12-09 01:32:20.578 PST [11415] STATEMENT:  INSERT INTO "users" (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:32:20.579 PST [11415] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:32:29.586 PST [11421] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:32:29.587 PST [11421] ERROR:  column "username" of relation "users" does not exist at character 22
2023-12-09 01:32:29.587 PST [11421] STATEMENT:  INSERT INTO "users" (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:32:29.587 PST [11421] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:33:03.930 PST [10649] LOG:  statement: SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';
	
2023-12-09 01:33:04.002 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=13559::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:33:04.006 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=13559::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (13559)::oid
	)::oid[])
2023-12-09 01:33:04.009 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 13559::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:33:04.014 PST [10649] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:33:04.014 PST [10649] DETAIL:  parameters: $1 = '{19,1043}'
2023-12-09 01:34:17.898 PST [11474] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:34:17.899 PST [11474] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:34:17.899 PST [11474] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:34:17.899 PST [11474] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:35:09.673 PST [11519] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:35:09.673 PST [11519] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:35:09.673 PST [11519] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:35:09.674 PST [11519] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:36:34.963 PST [36662] LOG:  checkpoint starting: time
2023-12-09 01:36:35.090 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.103 s, sync=0.007 s, total=0.128 s; sync files=1, longest=0.007 s, average=0.007 s; distance=5 kB, estimate=5146 kB
2023-12-09 01:36:57.258 PST [10649] LOG:  statement: SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';
	
2023-12-09 01:36:57.332 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=13559::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:36:57.338 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=13559::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (13559)::oid
	)::oid[])
2023-12-09 01:36:57.341 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 13559::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:36:57.348 PST [10649] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:36:57.348 PST [10649] DETAIL:  parameters: $1 = '{19,1043}'
2023-12-09 01:38:40.856 PST [10649] LOG:  statement: INSERT INTO users (username, email, password, phone) VALUES ('mhdayan', 'mhdayaan@gmail.com', '123456789', '1234567890')
2023-12-09 01:39:29.294 PST [11622] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:39:29.295 PST [11622] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:39:29.295 PST [11622] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:39:29.295 PST [11622] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:39:35.655 PST [11628] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:39:35.656 PST [11628] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:39:35.656 PST [11628] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4) RETURNING user_id
2023-12-09 01:39:35.656 PST [11628] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:40:51.392 PST [11665] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:40:51.393 PST [11665] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:40:51.393 PST [11665] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:40:51.394 PST [11665] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:40:57.927 PST [11671] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:40:57.928 PST [11671] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:40:57.928 PST [11671] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:40:57.928 PST [11671] LOG:  execute <unnamed>: ROLLBACK
2023-12-09 01:41:34.097 PST [36662] LOG:  checkpoint starting: time
2023-12-09 01:41:34.529 PST [36662] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.415 s, sync=0.009 s, total=0.433 s; sync files=4, longest=0.006 s, average=0.003 s; distance=0 kB, estimate=4632 kB
2023-12-09 01:44:34.332 PST [11791] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:44:34.333 PST [11791] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:44:34.333 PST [11791] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:44:47.663 PST [11801] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:44:47.664 PST [11801] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:44:47.664 PST [11801] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:46:07.616 PST [11847] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:46:07.617 PST [11847] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:46:07.617 PST [11847] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:46:28.444 PST [10649] LOG:  statement: SELECT * FROM users
2023-12-09 01:46:28.507 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:46:28.509 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16624::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16624)::oid
	)::oid[])
2023-12-09 01:46:28.511 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:46:28.514 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16624;
	
2023-12-09 01:46:28.517 PST [10649] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:46:28.517 PST [10649] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 01:46:34.535 PST [36662] LOG:  checkpoint starting: time
2023-12-09 01:46:34.654 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.102 s, sync=0.006 s, total=0.120 s; sync files=1, longest=0.006 s, average=0.006 s; distance=0 kB, estimate=4168 kB
2023-12-09 01:48:44.145 PST [11921] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:48:44.146 PST [11921] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:48:44.146 PST [11921] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:50:31.526 PST [10649] LOG:  statement: SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';
	
2023-12-09 01:50:31.561 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=13559::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 01:50:31.564 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=13559::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (13559)::oid
	)::oid[])
2023-12-09 01:50:31.567 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 13559::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 01:50:31.573 PST [10649] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 01:50:31.573 PST [10649] DETAIL:  parameters: $1 = '{19,1043}'
2023-12-09 01:52:49.024 PST [12044] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:52:49.025 PST [12044] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:52:49.025 PST [12044] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:52:55.090 PST [12048] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:52:55.091 PST [12048] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:52:55.091 PST [12048] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:56:08.113 PST [12170] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:56:08.114 PST [12170] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:56:08.114 PST [12170] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:56:14.100 PST [12176] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:56:14.101 PST [12176] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:56:14.101 PST [12176] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 01:59:00.966 PST [12277] LOG:  execute <unnamed>: BEGIN
2023-12-09 01:59:00.967 PST [12277] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 01:59:00.967 PST [12277] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 02:00:01.448 PST [7671] LOG:  statement: SELECT
	    ts.oid AS oid, spcname AS name, spcowner as owner,
	    pg_catalog.shobj_description(oid, 'pg_tablespace') AS description
	FROM
	    pg_catalog.pg_tablespace ts
	ORDER BY name;
2023-12-09 02:00:01.457 PST [7673] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-09 02:00:01.463 PST [7671] LOG:  statement: SELECT
		r.oid, r.rolname, r.rolcanlogin, r.rolsuper,
		pg_catalog.shobj_description(r.oid, 'pg_authid') AS description
	FROM
		pg_catalog.pg_roles r
	ORDER BY r.rolcanlogin, r.rolname
2023-12-09 02:00:01.464 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 02:00:01.465 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16624::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16624::oid ORDER BY rel.relname;
2023-12-09 02:00:01.495 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 02:00:01.497 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16624::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16624::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:00:01.500 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16624::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16624::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:00:01.503 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16624::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 02:00:01.510 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 02:00:01.514 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:00:01.516 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:00:01.519 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:00:01.520 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:00:01.521 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16624::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:00:01.522 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16624::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 02:00:01.526 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16630 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 02:00:01.526 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16630::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 02:00:01.527 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16624::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 02:00:01.530 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16624::oid
	ORDER BY conname
2023-12-09 02:00:01.531 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16624::oid
	
2023-12-09 02:00:01.534 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16624::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 02:00:01.922 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:00:01.941 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:00:01.958 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:00:02.089 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:00:02.108 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:00:35.461 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16624::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16624::oid ORDER BY rel.relname;
2023-12-09 02:00:35.468 PST [7673] LOG:  execute _pg3_4: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 02:00:35.470 PST [7673] LOG:  statement: DROP TABLE IF EXISTS public.users CASCADE;
2023-12-09 02:00:41.568 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 02:00:41.574 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 02:00:41.579 PST [7673] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 02:00:46.884 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:01:34.680 PST [36662] LOG:  checkpoint starting: time
2023-12-09 02:01:35.738 PST [36662] LOG:  checkpoint complete: wrote 11 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.035 s, sync=0.007 s, total=1.059 s; sync files=10, longest=0.003 s, average=0.001 s; distance=58 kB, estimate=3757 kB
2023-12-09 02:02:00.577 PST [7673] LOG:  statement: CREATE TABLE public.users
	(
	    user_id serial NOT NULL,
	    username character varying(255),
	    email character varying(255),
	    password character varying(255),
	    phone character varying(255),
	    PRIMARY KEY (user_id)
	);
	
	
	ALTER TABLE IF EXISTS public.users
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 02:02:00.589 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'users'::text AND nspname = 'public';
	
2023-12-09 02:02:00.590 PST [7673] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'users'
2023-12-09 02:02:19.183 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 02:02:19.185 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 02:02:19.196 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16610::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16610::oid ORDER BY rel.relname;
2023-12-09 02:02:19.205 PST [7673] LOG:  execute _pg3_5: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:19.207 PST [7673] LOG:  execute _pg3_5: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:19.209 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16610::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 02:02:19.215 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 02:02:19.217 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:19.218 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:19.219 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:19.220 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:19.221 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 02:02:19.224 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 02:02:19.225 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16614::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 02:02:19.226 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 02:02:19.228 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16610::oid
	ORDER BY conname
2023-12-09 02:02:19.229 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16610::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-09 02:02:19.230 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-09 02:02:19.232 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	   AND conname IS NULL
2023-12-09 02:02:19.235 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column
	
2023-12-09 02:02:19.236 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16610::oid
	
2023-12-09 02:02:19.237 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 02:02:19.655 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:19.674 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:19.693 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:19.707 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:25.739 PST [7673] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 02:02:32.993 PST [7673] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16653::OID
	
2023-12-09 02:02:38.095 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16610::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16610::oid ORDER BY rel.relname;
2023-12-09 02:02:38.103 PST [7673] LOG:  execute _pg3_5: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:38.104 PST [7673] LOG:  execute _pg3_4: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 02:02:38.104 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16610::oid;
	
2023-12-09 02:02:38.105 PST [7673] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 02:02:38.105 PST [7673] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16610::oid;
2023-12-09 02:02:38.106 PST [7673] LOG:  execute _pg3_5: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:38.107 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16610::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 02:02:38.112 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 02:02:38.114 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:38.115 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:38.116 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:38.117 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:38.118 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 02:02:38.120 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 02:02:38.120 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16614::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 02:02:38.121 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 02:02:38.123 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16610::oid
	ORDER BY conname
2023-12-09 02:02:38.124 PST [7673] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16610::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-09 02:02:38.125 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-09 02:02:38.126 PST [7673] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	   AND conname IS NULL
2023-12-09 02:02:38.128 PST [7673] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column
	
2023-12-09 02:02:38.129 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16610::oid
	
2023-12-09 02:02:38.130 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 02:02:38.133 PST [7673] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16653::oid
2023-12-09 02:02:38.134 PST [7673] LOG:  statement: ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (user_id)
	    REFERENCES public.users (user_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 02:02:38.135 PST [7673] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16610::oid;
	
2023-12-09 02:02:44.646 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 02:02:44.655 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 02:02:44.662 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16617::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16617::oid ORDER BY rel.relname;
2023-12-09 02:02:44.672 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:44.676 PST [7673] LOG:  execute _pg3_7: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:44.677 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 02:02:44.683 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 02:02:44.685 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:44.686 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:44.687 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:44.689 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:44.691 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 02:02:44.694 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16621 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 02:02:44.694 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16621::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 02:02:44.695 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 02:02:44.699 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16617::oid
	ORDER BY conname
2023-12-09 02:02:44.701 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16617::oid
	
2023-12-09 02:02:44.702 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 02:02:45.357 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:45.375 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:45.390 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:45.408 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:57.108 PST [7673] LOG:  execute _pg3_3: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 02:02:57.111 PST [7673] LOG:  execute _pg3_2: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 02:02:57.113 PST [7673] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16653::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16653::oid ORDER BY rel.relname;
2023-12-09 02:02:57.121 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:57.122 PST [7673] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:57.124 PST [7673] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16653::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 02:02:57.131 PST [7673] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 02:02:57.132 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:57.133 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:57.134 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:57.135 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:57.137 PST [7673] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 02:02:57.138 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16653::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 02:02:57.141 PST [7673] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16659 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 02:02:57.141 PST [7673] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16659::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 02:02:57.142 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16653::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 02:02:57.145 PST [7673] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16653::oid
	ORDER BY conname
2023-12-09 02:02:57.147 PST [7673] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16653::oid
	
2023-12-09 02:02:57.147 PST [7673] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16653::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 02:02:57.593 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:57.618 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:57.630 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:57.643 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:02:57.661 PST [7673] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 02:04:58.631 PST [12442] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:04:58.632 PST [12442] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 02:04:58.632 PST [12442] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 02:05:46.082 PST [12478] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:05:46.083 PST [12478] ERROR:  relation "schema_name.users" does not exist at character 13
2023-12-09 02:05:46.083 PST [12478] STATEMENT:  INSERT INTO schema_name.users ("username", "email", "password", "phone") VALUES ($1, $2, $3, $4)
2023-12-09 02:06:34.746 PST [36662] LOG:  checkpoint starting: time
2023-12-09 02:06:38.786 PST [36662] LOG:  checkpoint complete: wrote 40 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.023 s, sync=0.006 s, total=4.041 s; sync files=37, longest=0.001 s, average=0.001 s; distance=203 kB, estimate=3402 kB
2023-12-09 02:06:46.776 PST [12518] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:06:46.776 PST [12518] ERROR:  relation "schema_name.users" does not exist at character 13
2023-12-09 02:06:46.776 PST [12518] STATEMENT:  INSERT INTO "schema_name".users ("username", "email", "password", "phone") VALUES ($1, $2, $3, $4)
2023-12-09 02:08:32.144 PST [12589] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:08:32.145 PST [12589] ERROR:  column "username" of relation "users" does not exist at character 20
2023-12-09 02:08:32.145 PST [12589] STATEMENT:  INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 02:10:22.037 PST [12651] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:10:22.039 PST [12651] LOG:  execute <unnamed>: INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 02:10:22.039 PST [12651] DETAIL:  parameters: $1 = 'mhdayaan', $2 = 'mhdayaan@gmail.com', $3 = '123456789', $4 = '1234567890'
2023-12-09 02:10:22.042 PST [12651] LOG:  execute <unnamed>: COMMIT
2023-12-09 02:11:10.017 PST [10649] LOG:  statement: SELECT * FROM users
2023-12-09 02:11:10.090 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16653::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 02:11:10.094 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16653::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16653)::oid
	)::oid[])
2023-12-09 02:11:10.100 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16653::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 02:11:10.107 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16653;
	
2023-12-09 02:11:10.111 PST [10649] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 02:11:10.111 PST [10649] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-09 02:11:34.793 PST [36662] LOG:  checkpoint starting: time
2023-12-09 02:11:35.319 PST [36662] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.512 s, sync=0.003 s, total=0.527 s; sync files=5, longest=0.002 s, average=0.001 s; distance=5 kB, estimate=3062 kB
2023-12-09 02:38:05.179 PST [13595] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:38:05.179 PST [13595] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:40:02.188 PST [10649] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:40:02.560 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 02:40:02.563 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16465)::oid
	)::oid[])
2023-12-09 02:40:02.567 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 02:40:02.573 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16465;
	
2023-12-09 02:40:02.577 PST [10649] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 02:40:02.577 PST [10649] DETAIL:  parameters: $1 = '{1043,1042,1043,25}'
2023-12-09 02:41:19.004 PST [13700] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:41:19.005 PST [13700] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:41:22.336 PST [13704] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:41:22.337 PST [13704] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:41:34.317 PST [36662] LOG:  checkpoint starting: time
2023-12-09 02:41:34.444 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.113 s, sync=0.002 s, total=0.128 s; sync files=1, longest=0.002 s, average=0.002 s; distance=4 kB, estimate=2756 kB
2023-12-09 02:42:18.458 PST [13730] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:42:18.459 PST [13730] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:42:54.683 PST [13750] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:42:54.684 PST [13750] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:43:31.586 PST [10649] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:43:31.784 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 02:43:31.786 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16465)::oid
	)::oid[])
2023-12-09 02:43:31.794 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 02:43:31.802 PST [10649] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16465;
	
2023-12-09 02:43:31.807 PST [10649] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 02:43:31.807 PST [10649] DETAIL:  parameters: $1 = '{1043,1042,1043,25}'
2023-12-09 02:43:59.738 PST [13778] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:43:59.739 PST [13778] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:45:32.284 PST [13815] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:45:32.284 PST [13815] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:49:18.884 PST [13930] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:49:18.884 PST [13930] LOG:  statement: SELECT * FROM restaurants
2023-12-09 02:50:12.223 PST [13965] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:50:12.224 PST [13965] LOG:  statement: SELECT name FROM restaurants
2023-12-09 02:50:51.452 PST [10649] LOG:  statement: SELECT name FROM restaurants
2023-12-09 02:50:51.598 PST [10649] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 02:50:51.600 PST [10649] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16465)::oid
	)::oid[])
2023-12-09 02:50:51.605 PST [10649] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 02:50:51.611 PST [10649] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 02:50:51.611 PST [10649] DETAIL:  parameters: $1 = '{1042}'
2023-12-09 02:52:25.379 PST [14021] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:52:25.380 PST [14021] LOG:  statement: SELECT name FROM restaurants
2023-12-09 02:53:28.687 PST [14055] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:53:28.687 PST [14055] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 02:53:32.073 PST [14057] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:53:32.074 PST [14057] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 02:53:36.471 PST [14061] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:53:36.471 PST [14061] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 02:53:44.866 PST [14068] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:53:44.867 PST [14068] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 02:56:16.658 PST [14156] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:56:16.658 PST [14156] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 02:56:21.087 PST [14161] LOG:  execute <unnamed>: BEGIN
2023-12-09 02:56:21.087 PST [14161] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 06:21:20.736 PST [14478] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 06:21:20.771 PST [14478] LOG:  statement: SELECT version()
2023-12-09 06:21:20.775 PST [14478] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 06:21:20.790 PST [14478] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 06:21:20.800 PST [14478] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 06:21:20.938 PST [14481] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 06:21:20.963 PST [14481] LOG:  statement: SELECT version()
2023-12-09 06:21:20.965 PST [14481] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 06:21:20.996 PST [14481] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 06:21:21.001 PST [14481] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 06:21:21.120 PST [14482] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 06:21:21.138 PST [14482] LOG:  statement: SELECT version()
2023-12-09 06:21:21.147 PST [14482] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 06:21:21.156 PST [14482] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 06:21:21.160 PST [14482] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 08:22:00.279 PST [14509] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 08:22:00.282 PST [14509] LOG:  statement: SELECT version()
2023-12-09 08:22:00.283 PST [14509] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 08:22:00.286 PST [14509] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 08:22:00.288 PST [14509] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 08:22:00.305 PST [14510] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 08:22:00.307 PST [14510] LOG:  statement: SELECT version()
2023-12-09 08:22:00.308 PST [14510] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 08:22:00.310 PST [14510] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 08:22:00.311 PST [14510] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 08:22:00.327 PST [14511] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 08:22:00.330 PST [14511] LOG:  statement: SELECT version()
2023-12-09 08:22:00.330 PST [14511] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 08:22:00.332 PST [14511] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 08:22:00.333 PST [14511] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 10:25:34.838 PST [14541] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 10:25:34.862 PST [14541] LOG:  statement: SELECT version()
2023-12-09 10:25:34.867 PST [14541] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 10:25:34.877 PST [14541] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 10:25:34.883 PST [14541] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 10:25:34.960 PST [14542] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 10:25:34.975 PST [14542] LOG:  statement: SELECT version()
2023-12-09 10:25:34.978 PST [14542] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 10:25:34.983 PST [14542] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 10:25:34.986 PST [14542] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 10:25:35.061 PST [14543] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 10:25:35.066 PST [14543] LOG:  statement: SELECT version()
2023-12-09 10:25:35.066 PST [14543] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 10:25:35.068 PST [14543] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 10:25:35.070 PST [14543] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:01:25.299 PST [14584] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:01:25.302 PST [14584] LOG:  statement: SELECT version()
2023-12-09 12:01:25.302 PST [14584] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:01:25.303 PST [14584] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:01:25.304 PST [14584] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:01:25.320 PST [14585] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:01:25.323 PST [14585] LOG:  statement: SELECT version()
2023-12-09 12:01:25.324 PST [14585] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:01:25.326 PST [14585] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:01:25.327 PST [14585] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:01:25.342 PST [14586] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:01:25.344 PST [14586] LOG:  statement: SELECT version()
2023-12-09 12:01:25.344 PST [14586] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:01:25.345 PST [14586] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:01:25.346 PST [14586] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:06:28.152 PST [14622] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:06:28.157 PST [14622] LOG:  statement: SELECT version()
2023-12-09 12:06:28.158 PST [14622] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:06:28.161 PST [14622] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:06:28.163 PST [14622] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:06:28.184 PST [14623] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:06:28.187 PST [14623] LOG:  statement: SELECT version()
2023-12-09 12:06:28.188 PST [14623] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:06:28.190 PST [14623] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:06:28.191 PST [14623] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:06:28.214 PST [14624] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:06:28.217 PST [14624] LOG:  statement: SELECT version()
2023-12-09 12:06:28.217 PST [14624] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:06:28.219 PST [14624] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:06:28.221 PST [14624] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:08:13.461 PST [14682] LOG:  execute <unnamed>: BEGIN
2023-12-09 12:08:13.461 PST [14682] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 12:09:39.286 PST [14731] LOG:  execute <unnamed>: BEGIN
2023-12-09 12:09:39.287 PST [14731] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 12:10:51.438 PST [14849] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:10:51.440 PST [14849] LOG:  statement: SELECT version()
2023-12-09 12:10:51.442 PST [14849] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:10:51.444 PST [14849] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:10:51.447 PST [14849] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:10:51.454 PST [14849] LOG:  statement: SELECT name FROM restaurants LIMIT 100
2023-12-09 12:10:51.487 PST [14849] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 12:10:51.531 PST [14849] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16465)::oid
	)::oid[])
2023-12-09 12:10:51.550 PST [14849] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 12:10:51.591 PST [14849] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 12:10:51.591 PST [14849] DETAIL:  parameters: $1 = '{1042}'
2023-12-09 12:14:32.713 PST [15007] LOG:  execute <unnamed>: BEGIN
2023-12-09 12:14:32.713 PST [15007] LOG:  statement: SELECT * FROM restaurants
2023-12-09 12:18:41.131 PST [15153] LOG:  execute <unnamed>: BEGIN
2023-12-09 12:18:41.132 PST [15153] LOG:  statement: SELECT * FROM restaurants limit 50
2023-12-09 12:22:54.093 PST [15295] LOG:  execute <unnamed>: BEGIN
2023-12-09 12:22:54.093 PST [15295] LOG:  statement: SELECT * FROM restaurants limit 50
2023-12-09 12:23:24.619 PST [15319] LOG:  execute <unnamed>: BEGIN
2023-12-09 12:23:24.619 PST [15319] LOG:  statement: SELECT name FROM restaurants limit 50
2023-12-09 12:24:11.919 PST [15377] LOG:  execute <unnamed>: BEGIN
2023-12-09 12:24:11.919 PST [15377] LOG:  statement: SELECT name FROM restaurants limit 50
2023-12-09 12:30:45.196 PST [14849] LOG:  statement: SELECT * FROM restaurants LIMIT 100
2023-12-09 12:30:45.224 PST [14849] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 12:30:45.229 PST [14849] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16465::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16465)::oid
	)::oid[])
2023-12-09 12:30:45.232 PST [14849] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 12:30:45.241 PST [14849] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16465;
	
2023-12-09 12:30:45.244 PST [14849] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 12:30:45.244 PST [14849] DETAIL:  parameters: $1 = '{1043,1042,1043,25}'
2023-12-09 12:34:09.064 PST [15594] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:34:09.066 PST [15594] LOG:  statement: SELECT version()
2023-12-09 12:34:09.066 PST [15594] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:34:09.069 PST [15594] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:34:09.071 PST [15594] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:34:09.090 PST [15595] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:34:09.094 PST [15595] LOG:  statement: SELECT version()
2023-12-09 12:34:09.094 PST [15595] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:34:09.096 PST [15595] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:34:09.096 PST [15595] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 12:34:09.117 PST [15596] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 12:34:09.122 PST [15596] LOG:  statement: SELECT version()
2023-12-09 12:34:09.123 PST [15596] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 12:34:09.126 PST [15596] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 12:34:09.127 PST [15596] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 16:49:58.022 PST [15642] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 16:49:58.027 PST [15642] LOG:  statement: SELECT version()
2023-12-09 16:49:58.034 PST [15642] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 16:49:58.037 PST [15642] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 16:49:58.039 PST [15642] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 16:49:58.080 PST [15643] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 16:49:58.084 PST [15643] LOG:  statement: SELECT version()
2023-12-09 16:49:58.085 PST [15643] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 16:49:58.086 PST [15643] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 16:49:58.088 PST [15643] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 16:49:58.121 PST [15644] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 16:49:58.125 PST [15644] LOG:  statement: SELECT version()
2023-12-09 16:49:58.126 PST [15644] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 16:49:58.131 PST [15644] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 16:49:58.135 PST [15644] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 16:51:21.314 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 16:51:21.332 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-09 16:51:21.474 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 16:51:21.482 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:21.487 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16465::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:21.490 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16465::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 16:51:21.554 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (1043,1042,25)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (1043,1042,25)
	) t
	GROUP BY t.main_oid;
2023-12-09 16:51:21.571 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:21.579 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:21.583 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:21.586 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16465::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:21.589 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 16:51:21.607 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16470 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 16:51:21.610 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16470::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 16:51:21.611 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 16:51:21.617 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16465::oid
	ORDER BY conname
2023-12-09 16:51:21.619 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16465::oid
	
2023-12-09 16:51:21.623 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16465::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 16:51:21.872 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:21.893 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:21.914 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:21.933 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:35.445 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 16:51:35.449 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-09 16:51:35.456 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 16:51:35.458 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.460 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16527::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.462 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16527::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 16:51:35.471 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 16:51:35.472 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.473 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.475 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.476 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.477 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.479 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16527::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:35.480 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 16:51:35.483 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 16:51:35.483 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16533::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 16:51:35.485 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 16:51:35.487 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16527::oid
	ORDER BY conname
2023-12-09 16:51:35.490 PST [15644] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16527::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16465::oid
	    AND a2.attnum=1
	
2023-12-09 16:51:35.491 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16465::oid
2023-12-09 16:51:35.492 PST [15644] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16527::oid
	   AND conname IS NULL
2023-12-09 16:51:35.495 PST [15644] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16533 , 1 , true) AS column
	
2023-12-09 16:51:35.495 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16527::oid
	
2023-12-09 16:51:35.496 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16527::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 16:51:36.024 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:36.047 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:36.071 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:36.089 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:36.111 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:36.127 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:51.130 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 16:51:51.136 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16507::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16507::oid ORDER BY rel.relname;
2023-12-09 16:51:51.144 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 16:51:51.146 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:51.148 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16507::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:51.152 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16507::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 16:51:51.160 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 16:51:51.161 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:51.162 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:51.164 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:51.165 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:51.167 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16507::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 16:51:51.169 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 16:51:51.171 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16511 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 16:51:51.172 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16511::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 16:51:51.173 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 16:51:51.176 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16507::oid
	ORDER BY conname
2023-12-09 16:51:51.178 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16507::oid
	
2023-12-09 16:51:51.179 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16507::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 16:51:51.698 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:51.716 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:51.737 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:51.753 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:51:51.771 PST [15644] LOG:  execute _pg3_0: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:52:20.508 PST [15742] LOG:  execute <unnamed>: BEGIN
2023-12-09 16:52:20.508 PST [15742] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 16:56:19.163 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16465::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16465::oid ORDER BY rel.relname;
2023-12-09 16:56:19.169 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 16:56:19.174 PST [15644] LOG:  statement: DROP TABLE IF EXISTS public.restaurants CASCADE;
2023-12-09 16:56:19.212 PST [15644] LOG:  execute <unnamed>: DEALLOCATE ALL
2023-12-09 16:56:26.810 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16527::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16527::oid ORDER BY rel.relname;
2023-12-09 16:56:26.816 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 16:56:26.817 PST [15644] LOG:  statement: DROP TABLE IF EXISTS public.menus CASCADE;
2023-12-09 16:56:33.318 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16507::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16507::oid ORDER BY rel.relname;
2023-12-09 16:56:33.324 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 16:56:33.325 PST [15644] LOG:  statement: DROP TABLE IF EXISTS public.ratings CASCADE;
2023-12-09 16:56:41.196 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 16:56:41.205 PST [15644] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 16:56:41.207 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 16:57:02.289 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 16:58:23.975 PST [36662] LOG:  checkpoint starting: time
2023-12-09 16:58:27.064 PST [36662] LOG:  checkpoint complete: wrote 31 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.059 s, sync=0.009 s, total=3.089 s; sync files=15, longest=0.006 s, average=0.001 s; distance=197 kB, estimate=2500 kB
2023-12-09 16:59:01.493 PST [15644] LOG:  statement: CREATE TABLE public.ratings
	(
	    id serial NOT NULL,
	    restaurant_id integer,
	    restaurant_name character varying(255),
	    ratings numeric(255, 2),
	    score numeric(255, 2),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.ratings
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 16:59:01.512 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'ratings'::text AND nspname = 'public';
	
2023-12-09 16:59:01.514 PST [15644] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'ratings'
2023-12-09 16:59:06.465 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16667::oid
2023-12-09 16:59:06.474 PST [15642] LOG:  statement: SELECT * FROM
	(SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
	FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
	WHERE encoding != '' ORDER BY encoding;
	
	
2023-12-09 16:59:06.476 PST [15644] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 16:59:21.304 PST [15948] LOG:  statement: COPY  public.ratings ( restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 16:59:21.307 PST [15948] ERROR:  extra data after last expected column
2023-12-09 16:59:21.307 PST [15948] CONTEXT:  COPY ratings, line 2: "1,Extra Large Pizza,Extra Large Meat Lovers,Whole pie.,15.99"
2023-12-09 16:59:21.307 PST [15948] STATEMENT:  COPY  public.ratings ( restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 17:00:22.089 PST [15983] LOG:  statement: COPY  public.ratings ( id, restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 17:00:22.090 PST [15983] ERROR:  invalid input syntax for type integer: "Extra Large Pizza"
2023-12-09 17:00:22.090 PST [15983] CONTEXT:  COPY ratings, line 2, column restaurant_id: "Extra Large Pizza"
2023-12-09 17:00:22.090 PST [15983] STATEMENT:  COPY  public.ratings ( id, restaurant_id, restaurant_name, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 17:50:21.801 PST [36662] LOG:  checkpoint starting: time
2023-12-09 17:50:26.079 PST [36662] LOG:  checkpoint complete: wrote 40 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.268 s, sync=0.006 s, total=4.279 s; sync files=32, longest=0.002 s, average=0.001 s; distance=195 kB, estimate=2270 kB
2023-12-09 17:51:47.660 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 17:51:47.666 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 17:51:47.677 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-09 17:51:47.690 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:47.692 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:47.694 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 17:51:47.701 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 17:51:47.703 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:47.704 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:47.705 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:47.707 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:47.708 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:47.709 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 17:51:47.712 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 17:51:47.713 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16671::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 17:51:47.714 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 17:51:47.716 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16667::oid
	ORDER BY conname
2023-12-09 17:51:47.717 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16667::oid
	
2023-12-09 17:51:47.718 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 17:51:48.388 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:51:48.401 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:51:48.423 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:51:48.436 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:51:48.451 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:51:54.941 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-09 17:51:54.949 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:54.950 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 17:51:54.952 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16667::oid;
	
2023-12-09 17:51:54.953 PST [15644] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 17:51:54.954 PST [15644] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16667::oid;
2023-12-09 17:51:54.955 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:54.957 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 17:51:54.964 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 17:51:54.965 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:54.967 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:54.968 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:54.969 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:54.970 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:51:54.972 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 17:51:54.975 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 17:51:54.976 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16671::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 17:51:54.977 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 17:51:54.979 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16667::oid
	ORDER BY conname
2023-12-09 17:51:54.981 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16667::oid
	
2023-12-09 17:51:54.982 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 17:51:54.993 PST [15644] LOG:  statement: ALTER TABLE IF EXISTS public.ratings DROP COLUMN IF EXISTS restaurant_name;
2023-12-09 17:51:54.995 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16667::oid;
	
2023-12-09 17:53:24.481 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 17:53:24.485 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 17:53:24.487 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-09 17:53:24.498 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:53:24.502 PST [15644] LOG:  execute _pg3_2: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:53:24.502 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 17:53:24.508 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 17:53:24.509 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:53:24.510 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:53:24.512 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:53:24.513 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:53:24.514 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 17:53:24.517 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 17:53:24.517 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16671::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 17:53:24.518 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 17:53:24.520 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16667::oid
	ORDER BY conname
2023-12-09 17:53:24.521 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16667::oid
	
2023-12-09 17:53:24.522 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 17:53:25.048 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:53:25.062 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:53:25.075 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:53:25.088 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:53:39.148 PST [16175] LOG:  statement: COPY  public.ratings ( restaurant_id, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 17:53:52.513 PST [16180] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 17:53:52.516 PST [16180] LOG:  statement: SELECT version()
2023-12-09 17:53:52.517 PST [16180] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 17:53:52.519 PST [16180] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 17:53:52.521 PST [16180] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 17:53:52.526 PST [15644] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16667;
	
2023-12-09 17:53:52.631 PST [15644] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-09 17:53:52.634 PST [15644] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-09 17:53:52.638 PST [16180] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-09 17:53:52.783 PST [16180] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 17:53:52.805 PST [16180] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 17:53:52.805 PST [16180] DETAIL:  parameters: $1 = '{23,23,1700,1700}'
2023-12-09 17:55:21.091 PST [36662] LOG:  checkpoint starting: time
2023-12-09 17:55:25.007 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 17:55:25.014 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 17:55:25.015 PST [15644] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 17:55:40.680 PST [36662] LOG:  checkpoint complete: wrote 194 buffers (1.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=19.569 s, sync=0.006 s, total=19.589 s; sync files=16, longest=0.003 s, average=0.001 s; distance=1935 kB, estimate=2236 kB
2023-12-09 17:56:01.274 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:58:51.918 PST [15644] LOG:  statement: CREATE TABLE public.menus
	(
	    id serial NOT NULL,
	    restaurant_id integer,
	    category text,
	    name character varying(255),
	    description text,
	    price numeric(255, 2),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.menus
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 17:58:51.936 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'menus'::text AND nspname = 'public';
	
2023-12-09 17:58:51.938 PST [15644] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'menus'
2023-12-09 17:59:04.604 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16674::oid
2023-12-09 17:59:04.606 PST [15644] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16674::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 17:59:22.922 PST [16332] LOG:  statement: COPY  public.menus ( id, restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 17:59:22.924 PST [16332] ERROR:  invalid input syntax for type integer: "Extra Large Pizza"
2023-12-09 17:59:22.924 PST [16332] CONTEXT:  COPY menus, line 2, column restaurant_id: "Extra Large Pizza"
2023-12-09 17:59:22.924 PST [16332] STATEMENT:  COPY  public.menus ( id, restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 17:59:39.486 PST [16341] LOG:  statement: COPY  public.menus ( restaurant_id, category, name, description, price ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 17:59:54.730 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 17:59:54.731 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 17:59:54.742 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16674::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16674::oid ORDER BY rel.relname;
2023-12-09 17:59:54.749 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.751 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.753 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16674::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 17:59:54.758 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,25,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,25,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 17:59:54.759 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.760 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.761 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.762 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.763 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.764 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 17:59:54.765 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 17:59:54.768 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16680 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 17:59:54.768 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16680::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 17:59:54.769 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 17:59:54.772 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16674::oid
	ORDER BY conname
2023-12-09 17:59:54.773 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16674::oid
	
2023-12-09 17:59:54.774 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 17:59:55.344 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:59:55.358 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:59:55.376 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:59:55.390 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:59:55.403 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 17:59:55.419 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:00:13.424 PST [15644] LOG:  execute _pg3_3: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:00:13.427 PST [15644] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 18:00:13.431 PST [15644] LOG:  execute _pg3_4: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:00:21.685 PST [36662] LOG:  checkpoint starting: time
2023-12-09 18:00:34.612 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:00:38.570 PST [36662] LOG:  checkpoint complete: wrote 167 buffers (1.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=16.874 s, sync=0.004 s, total=16.885 s; sync files=41, longest=0.002 s, average=0.001 s; distance=1289 kB, estimate=2142 kB
2023-12-09 18:01:48.547 PST [15644] LOG:  statement: CREATE TABLE public.restaurants
	(
	    id integer NOT NULL,
	    name character varying(255),
	    address character varying(255),
	    category text,
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.restaurants
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 18:01:48.565 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'restaurants'::text AND nspname = 'public';
	
2023-12-09 18:01:48.566 PST [15644] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'restaurants'
2023-12-09 18:01:58.428 PST [15644] LOG:  execute _pg3_4: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:01:58.431 PST [15644] LOG:  execute _pg3_3: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:01:58.436 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16617::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16617::oid ORDER BY rel.relname;
2023-12-09 18:01:58.442 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:01:58.443 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:01:58.445 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:01:58.451 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:01:58.452 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:01:58.453 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:01:58.454 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:01:58.455 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:01:58.457 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:01:58.459 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16621 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:01:58.460 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16621::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:01:58.460 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:01:58.463 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16617::oid
	ORDER BY conname
2023-12-09 18:01:58.464 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16617::oid
	
2023-12-09 18:01:58.465 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:01:59.090 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:01:59.108 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:01:59.129 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:01:59.145 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:16.439 PST [15644] LOG:  execute _pg3_3: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:02:16.442 PST [15644] LOG:  execute _pg3_4: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:02:16.449 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16610::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16610::oid ORDER BY rel.relname;
2023-12-09 18:02:16.455 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:16.457 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16610::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:16.459 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16610::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:02:16.464 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:02:16.465 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:16.466 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:16.467 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:16.468 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16610::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:16.469 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:02:16.472 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:02:16.473 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16614::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:02:16.474 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:02:16.478 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16610::oid
	ORDER BY conname
2023-12-09 18:02:16.479 PST [15644] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16610::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16653::oid
	    AND a2.attnum=1
	
2023-12-09 18:02:16.480 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16653::oid
2023-12-09 18:02:16.481 PST [15644] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16610::oid
	   AND conname IS NULL
2023-12-09 18:02:16.484 PST [15644] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16614 , 1 , true) AS column
	
2023-12-09 18:02:16.484 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16610::oid
	
2023-12-09 18:02:16.485 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16610::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:02:17.093 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:17.107 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:17.123 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:17.137 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:31.075 PST [15644] LOG:  execute _pg3_3: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:02:31.080 PST [15644] LOG:  execute _pg3_4: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:02:31.081 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16603::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16603::oid ORDER BY rel.relname;
2023-12-09 18:02:31.088 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:31.090 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:31.092 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16603::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:02:31.098 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:02:31.099 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:31.100 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:31.101 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:31.103 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:02:31.105 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:02:31.106 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16607::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:02:31.106 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:02:31.109 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16603::oid
	ORDER BY conname
2023-12-09 18:02:31.111 PST [15644] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16603::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16610::oid
	    AND a2.attnum=1
	
2023-12-09 18:02:31.111 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16610::oid
2023-12-09 18:02:31.112 PST [15644] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	   AND conname IS NULL
2023-12-09 18:02:31.115 PST [15644] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column
	
2023-12-09 18:02:31.115 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16603::oid
	
2023-12-09 18:02:31.116 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:02:31.818 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:31.831 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:31.845 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:49.172 PST [15644] LOG:  execute _pg3_4: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:02:49.174 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16653::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16653::oid ORDER BY rel.relname;
2023-12-09 18:02:49.181 PST [15644] LOG:  execute _pg3_3: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:02:49.183 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:49.185 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16653::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:49.187 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16653::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:02:49.193 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:02:49.194 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:49.195 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:49.196 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:49.197 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:49.198 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16653::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:02:49.200 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16653::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:02:49.202 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16659 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:02:49.203 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16659::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:02:49.203 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16653::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:02:49.205 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16653::oid
	ORDER BY conname
2023-12-09 18:02:49.207 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16653::oid
	
2023-12-09 18:02:49.208 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16653::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:02:49.863 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:49.880 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:49.895 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:49.909 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:02:49.925 PST [15644] LOG:  execute _pg3_1: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:03:03.396 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16610::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16610::oid ORDER BY rel.relname;
2023-12-09 18:03:03.403 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 18:03:03.404 PST [15644] LOG:  statement: DROP TABLE IF EXISTS public.orders CASCADE;
2023-12-09 18:03:03.409 PST [15644] LOG:  execute <unnamed>: DEALLOCATE ALL
2023-12-09 18:03:15.379 PST [15644] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 18:03:15.383 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:03:15.394 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:03:27.209 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:04:12.372 PST [15644] LOG:  statement: CREATE TABLE public.orders
	(
	    id serial NOT NULL,
	    user_id integer,
	    restaurant_id integer,
	    order_total numeric(255, 2),
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.orders
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 18:04:12.377 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'orders'::text AND nspname = 'public';
	
2023-12-09 18:04:12.377 PST [15644] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'orders'
2023-12-09 18:04:24.226 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:04:24.231 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:04:24.232 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16617::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16617::oid ORDER BY rel.relname;
2023-12-09 18:04:24.240 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:24.241 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:24.243 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:04:24.248 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:04:24.249 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:24.250 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:24.251 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:24.252 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:24.253 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:04:24.255 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16621 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:04:24.256 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16621::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:04:24.256 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:04:24.258 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16617::oid
	ORDER BY conname
2023-12-09 18:04:24.260 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16617::oid
	
2023-12-09 18:04:24.260 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:04:24.992 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:04:25.006 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:04:25.022 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:04:25.036 PST [15644] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:04:35.008 PST [15644] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 18:04:49.033 PST [15644] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16653::OID
	
2023-12-09 18:04:59.255 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16617::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16617::oid ORDER BY rel.relname;
2023-12-09 18:04:59.262 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:59.264 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 18:04:59.265 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16617::oid;
	
2023-12-09 18:04:59.265 PST [15644] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 18:04:59.266 PST [15644] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16617::oid;
2023-12-09 18:04:59.266 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16617::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:59.268 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:04:59.274 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:04:59.275 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:59.276 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:59.277 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:59.278 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16617::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:04:59.279 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:04:59.281 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16621 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:04:59.282 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16621::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:04:59.283 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:04:59.285 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16617::oid
	ORDER BY conname
2023-12-09 18:04:59.287 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16617::oid
	
2023-12-09 18:04:59.288 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16617::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:04:59.293 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16653::oid
2023-12-09 18:04:59.294 PST [15644] LOG:  statement: ALTER TABLE IF EXISTS public.address
	    ADD FOREIGN KEY (user_id)
	    REFERENCES public.users (user_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 18:04:59.299 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16617::oid;
	
2023-12-09 18:05:21.575 PST [36662] LOG:  checkpoint starting: time
2023-12-09 18:05:26.316 PST [36662] LOG:  checkpoint complete: wrote 47 buffers (0.3%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.725 s, sync=0.010 s, total=4.741 s; sync files=39, longest=0.006 s, average=0.001 s; distance=228 kB, estimate=1950 kB
2023-12-09 18:05:27.481 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:05:27.486 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:05:27.487 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16674::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16674::oid ORDER BY rel.relname;
2023-12-09 18:05:27.494 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.496 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.498 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16674::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:05:27.504 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,25,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,25,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:05:27.505 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.506 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.507 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.508 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.509 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.510 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:05:27.511 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:05:27.513 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16680 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:05:27.514 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16680::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:05:27.514 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:05:27.517 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16674::oid
	ORDER BY conname
2023-12-09 18:05:27.518 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16674::oid
	
2023-12-09 18:05:27.519 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:05:28.240 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:05:28.254 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:05:28.270 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:05:28.283 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:05:28.295 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:05:28.310 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:05:39.136 PST [15644] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 18:05:50.924 PST [15644] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16686::OID
	
2023-12-09 18:06:10.943 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16674::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16674::oid ORDER BY rel.relname;
2023-12-09 18:06:10.950 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.952 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 18:06:10.953 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16674::oid;
	
2023-12-09 18:06:10.953 PST [15644] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 18:06:10.954 PST [15644] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16674::oid;
2023-12-09 18:06:10.954 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16674::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.956 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16674::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:06:10.961 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,25,1043,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,25,1043,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:06:10.963 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.964 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.965 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.966 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.967 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.968 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 6::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16674::oid
	        AND att.attnum = 6::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:10.969 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:06:10.971 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16680 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:06:10.972 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16680::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:06:10.973 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:06:10.975 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16674::oid
	ORDER BY conname
2023-12-09 18:06:10.976 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16674::oid
	
2023-12-09 18:06:10.977 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16674::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:06:10.980 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16686::oid
2023-12-09 18:06:10.981 PST [15644] LOG:  statement: ALTER TABLE IF EXISTS public.menus
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 18:06:10.984 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16674::oid;
	
2023-12-09 18:06:23.413 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:06:23.418 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16694::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16694::oid ORDER BY rel.relname;
2023-12-09 18:06:23.424 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:06:23.426 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:23.428 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:23.430 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:06:23.436 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:06:23.438 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:23.439 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:23.440 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:23.441 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:06:23.443 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:06:23.445 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:06:23.446 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16698::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:06:23.447 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:06:23.449 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16694::oid
	ORDER BY conname
2023-12-09 18:06:23.451 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16694::oid
	
2023-12-09 18:06:23.451 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:06:24.148 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:06:24.162 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:06:24.180 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:06:24.194 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:06:31.641 PST [15644] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 18:06:53.350 PST [15644] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16653::OID
	
2023-12-09 18:07:04.233 PST [15644] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16653::OID
	
2023-12-09 18:07:10.159 PST [15644] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16686::OID
	
2023-12-09 18:07:14.495 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16694::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16694::oid ORDER BY rel.relname;
2023-12-09 18:07:14.502 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:14.504 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 18:07:14.505 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16694::oid;
	
2023-12-09 18:07:14.505 PST [15644] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 18:07:14.506 PST [15644] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16694::oid;
2023-12-09 18:07:14.506 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:14.508 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:07:14.514 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:07:14.515 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:14.516 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:14.517 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:14.519 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:14.520 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:07:14.522 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:07:14.523 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16698::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:07:14.524 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:07:14.527 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16694::oid
	ORDER BY conname
2023-12-09 18:07:14.528 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16694::oid
	
2023-12-09 18:07:14.529 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:07:14.532 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16653::oid
2023-12-09 18:07:14.533 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16686::oid
2023-12-09 18:07:14.534 PST [15644] LOG:  statement: ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (user_id)
	    REFERENCES public.users (user_id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
	
	ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 18:07:14.535 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16694::oid;
	
2023-12-09 18:07:27.362 PST [15644] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:07:27.366 PST [15644] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:07:27.367 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16603::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16603::oid ORDER BY rel.relname;
2023-12-09 18:07:27.375 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:27.377 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:27.379 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16603::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:07:27.384 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:07:27.386 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:27.387 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:27.388 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:27.389 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:07:27.391 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:07:27.392 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16607::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:07:27.393 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:07:27.395 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16603::oid
	ORDER BY conname
2023-12-09 18:07:27.396 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16603::oid
	
2023-12-09 18:07:27.397 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:07:28.116 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:07:28.129 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:07:28.143 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:07:39.000 PST [15644] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 18:07:47.701 PST [15644] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16694::OID
	
2023-12-09 18:07:56.906 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16603::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16603::oid ORDER BY rel.relname;
2023-12-09 18:07:56.912 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:56.914 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 18:07:56.915 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16603::oid;
	
2023-12-09 18:07:56.916 PST [15644] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 18:07:56.916 PST [15644] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16603::oid;
2023-12-09 18:07:56.917 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:56.919 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16603::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:07:56.924 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:07:56.925 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:56.926 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:56.927 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:07:56.928 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:07:56.931 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:07:56.932 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16607::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:07:56.932 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:07:56.935 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16603::oid
	ORDER BY conname
2023-12-09 18:07:56.936 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16603::oid
	
2023-12-09 18:07:56.937 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:07:56.940 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16694::oid
2023-12-09 18:07:56.941 PST [15644] LOG:  statement: ALTER TABLE IF EXISTS public.payment
	    ADD FOREIGN KEY (order_id)
	    REFERENCES public.orders (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 18:07:56.944 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16603::oid;
	
2023-12-09 18:08:09.958 PST [15644] LOG:  execute _pg3_6: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:08:09.960 PST [15644] LOG:  execute _pg3_7: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:08:09.961 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-09 18:08:09.968 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:09.971 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:09.973 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:08:09.978 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:08:09.980 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:09.981 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:09.982 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:09.983 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:09.984 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:08:09.987 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:08:09.987 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16671::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:08:09.988 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:08:09.990 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16667::oid
	ORDER BY conname
2023-12-09 18:08:09.991 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16667::oid
	
2023-12-09 18:08:09.992 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:08:10.716 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:08:10.731 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:08:10.745 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:08:10.759 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:08:21.780 PST [15644] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 18:08:36.268 PST [15644] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16686::OID
	
2023-12-09 18:08:41.584 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-09 18:08:41.590 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:41.591 PST [15644] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 18:08:41.592 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16667::oid;
	
2023-12-09 18:08:41.593 PST [15644] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 18:08:41.593 PST [15644] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16667::oid;
2023-12-09 18:08:41.594 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:41.596 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:08:41.603 PST [15644] LOG:  execute _pg3_8: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:08:41.603 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:41.604 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:41.605 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:41.607 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:41.608 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:08:41.610 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:08:41.610 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16671::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:08:41.611 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:08:41.614 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16667::oid
	ORDER BY conname
2023-12-09 18:08:41.615 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16667::oid
	
2023-12-09 18:08:41.616 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:08:41.620 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16686::oid
2023-12-09 18:08:41.621 PST [15644] LOG:  statement: ALTER TABLE IF EXISTS public.ratings
	    ADD FOREIGN KEY (restaurant_id)
	    REFERENCES public.restaurants (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-09 18:08:41.622 PST [15644] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16667::oid;
	
2023-12-09 18:08:58.198 PST [15644] LOG:  execute _pg3_7: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 18:08:58.204 PST [15644] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16686::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16686::oid ORDER BY rel.relname;
2023-12-09 18:08:58.210 PST [15644] LOG:  execute _pg3_6: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 18:08:58.212 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16686::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16686::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:58.214 PST [15644] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16686::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16686::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:58.216 PST [15644] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16686::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 18:08:58.221 PST [15644] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1043,25)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1043,25)
	) t
	GROUP BY t.main_oid;
2023-12-09 18:08:58.222 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:58.223 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:58.224 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:58.226 PST [15644] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16686::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 18:08:58.227 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16686::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 18:08:58.230 PST [15644] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16691 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 18:08:58.230 PST [15644] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16691::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 18:08:58.231 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16686::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 18:08:58.233 PST [15644] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16686::oid
	ORDER BY conname
2023-12-09 18:08:58.234 PST [15644] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16686::oid
	
2023-12-09 18:08:58.235 PST [15644] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16686::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 18:08:59.051 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:08:59.064 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:08:59.078 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:08:59.093 PST [15644] LOG:  execute _pg3_5: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 18:09:09.754 PST [15644] LOG:  execute _pg3_9: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-09 18:10:13.667 PST [16626] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:10:13.668 PST [16626] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:10:21.323 PST [36662] LOG:  checkpoint starting: time
2023-12-09 18:10:24.833 PST [36662] LOG:  checkpoint complete: wrote 35 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.501 s, sync=0.003 s, total=3.511 s; sync files=19, longest=0.001 s, average=0.001 s; distance=215 kB, estimate=1777 kB
2023-12-09 18:10:46.505 PST [16649] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:10:46.505 PST [16649] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:22:20.025 PST [16949] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:22:20.025 PST [16949] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:30:17.708 PST [17164] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:30:17.708 PST [17164] LOG:  statement: SELECT * FROM restaurants limit 50
2023-12-09 18:32:46.771 PST [17286] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:32:46.771 PST [17286] LOG:  statement: SELECT * FROM restaurants limit 50
2023-12-09 18:34:24.970 PST [17364] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:34:24.971 PST [17364] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:36:52.031 PST [17445] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:36:52.031 PST [17445] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:37:46.588 PST [17470] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:37:46.589 PST [17470] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:39:11.910 PST [17514] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:39:11.911 PST [17514] LOG:  statement: SELECT id, name FROM restaurants
2023-12-09 18:39:13.580 PST [17515] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:39:13.580 PST [17515] LOG:  statement: SELECT id, name FROM restaurants
2023-12-09 18:39:14.290 PST [17516] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:39:14.290 PST [17516] LOG:  statement: SELECT id, name FROM restaurants
2023-12-09 18:39:14.580 PST [17517] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:39:14.580 PST [17517] LOG:  statement: SELECT id, name FROM restaurants
2023-12-09 18:39:14.960 PST [17519] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:39:14.960 PST [17519] LOG:  statement: SELECT id, name FROM restaurants
2023-12-09 18:39:41.449 PST [17552] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:39:41.450 PST [17552] LOG:  statement: SELECT id, name FROM restaurants
2023-12-09 18:40:22.945 PST [17571] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 18:40:22.949 PST [17571] LOG:  statement: SELECT version()
2023-12-09 18:40:22.950 PST [17571] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 18:40:22.953 PST [17571] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 18:40:22.956 PST [17571] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 18:40:26.427 PST [17571] LOG:  statement: SELECT id, name FROM restaurants;
	
2023-12-09 18:40:26.463 PST [17571] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 18:40:26.504 PST [17571] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16686)::oid
	)::oid[])
2023-12-09 18:40:26.531 PST [17571] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16686::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 18:40:26.571 PST [17571] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16686;
	
2023-12-09 18:40:26.576 PST [17571] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 18:40:26.576 PST [17571] DETAIL:  parameters: $1 = '{23,1043}'
2023-12-09 18:40:46.473 PST [15644] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16686::oid
2023-12-09 18:40:46.483 PST [15644] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16686::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 18:41:00.224 PST [17597] LOG:  statement: COPY  public.restaurants ( id, name, address, category ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-09 18:41:05.966 PST [17571] LOG:  statement: SELECT id, name FROM restaurants;
	
2023-12-09 18:41:06.067 PST [17571] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 18:41:06.069 PST [17571] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16686)::oid
	)::oid[])
2023-12-09 18:41:06.072 PST [17571] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16686::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 18:41:06.077 PST [17571] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16686;
	
2023-12-09 18:41:06.080 PST [17571] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 18:41:06.080 PST [17571] DETAIL:  parameters: $1 = '{23,1043}'
2023-12-09 18:41:14.287 PST [17602] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:41:14.287 PST [17602] LOG:  statement: SELECT id, name FROM restaurants
2023-12-09 18:43:31.932 PST [17697] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:43:31.932 PST [17697] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:43:56.200 PST [17571] LOG:  statement: SELECT id, name FROM restaurants limit 50
	
2023-12-09 18:43:56.237 PST [17571] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 18:43:56.238 PST [17571] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16686)::oid
	)::oid[])
2023-12-09 18:43:56.242 PST [17571] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16686::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 18:43:56.246 PST [17571] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16686;
	
2023-12-09 18:43:56.249 PST [17571] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 18:43:56.249 PST [17571] DETAIL:  parameters: $1 = '{23,1043}'
2023-12-09 18:44:01.032 PST [17571] LOG:  statement: EXPLAIN (FORMAT JSON, ANALYZE false, VERBOSE false, COSTS false, TIMING false, BUFFERS false, SUMMARY false, SETTINGS false, WAL false) SELECT id, name FROM restaurants limit 50
	
2023-12-09 18:44:01.058 PST [17571] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 18:44:01.058 PST [17571] DETAIL:  parameters: $1 = '{114}'
2023-12-09 18:44:04.829 PST [17571] LOG:  statement: EXPLAIN (FORMAT JSON, ANALYZE false, VERBOSE false, COSTS false, TIMING false, BUFFERS false, SUMMARY false, SETTINGS false, WAL false) SELECT id, name FROM restaurants limit 50
	
2023-12-09 18:44:04.868 PST [17571] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 18:44:04.868 PST [17571] DETAIL:  parameters: $1 = '{114}'
2023-12-09 18:44:19.031 PST [17571] LOG:  statement: SELECT id, name FROM restaurants limit 50
	
2023-12-09 18:44:19.061 PST [17571] LOG:  statement: SELECT at.attname, ty.typname, at.attnum
	    FROM pg_catalog.pg_attribute at
	    LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	    JOIN pg_catalog.pg_class as cl ON cl.oid=at.attrelid
	    JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	at.attnum > 0
	AND at.attisdropped = FALSE
2023-12-09 18:44:19.063 PST [17571] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    attrelid=16686::oid AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.oid = (16686)::oid
	)::oid[])
2023-12-09 18:44:19.065 PST [17571] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16686::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 18:44:19.068 PST [17571] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16686;
	
2023-12-09 18:44:19.072 PST [17571] LOG:  execute _pg3_0: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 18:44:19.072 PST [17571] DETAIL:  parameters: $1 = '{23,1043}'
2023-12-09 18:45:21.886 PST [36662] LOG:  checkpoint starting: time
2023-12-09 18:45:37.863 PST [17761] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:45:37.864 PST [17761] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:46:47.648 PST [36662] LOG:  checkpoint complete: wrote 853 buffers (5.2%); 0 WAL file(s) added, 0 removed, 1 recycled; write=85.739 s, sync=0.008 s, total=85.762 s; sync files=13, longest=0.006 s, average=0.001 s; distance=7650 kB, estimate=7650 kB
2023-12-09 18:47:59.710 PST [17841] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:47:59.710 PST [17841] ERROR:  syntax error at end of input at character 39
2023-12-09 18:47:59.710 PST [17841] STATEMENT:  SELECT id, name FROM restaurants limit
2023-12-09 18:48:11.907 PST [17856] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:48:11.907 PST [17856] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:49:32.214 PST [17896] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:49:32.214 PST [17896] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:50:48.208 PST [17931] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:50:48.208 PST [17931] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:53:24.355 PST [17997] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:53:24.355 PST [17997] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:53:26.059 PST [18001] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:53:26.059 PST [18001] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:53:30.103 PST [18002] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:53:30.103 PST [18002] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:55:01.189 PST [18052] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:55:01.190 PST [18052] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:55:02.325 PST [18054] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:55:02.326 PST [18054] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:56:02.694 PST [18109] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:56:02.695 PST [18109] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:57:06.229 PST [18139] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:57:06.230 PST [18139] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:57:54.675 PST [18167] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:57:54.675 PST [18167] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 18:58:59.185 PST [18201] LOG:  execute <unnamed>: BEGIN
2023-12-09 18:58:59.185 PST [18201] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 19:03:37.422 PST [18348] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:03:37.422 PST [18348] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 19:05:38.383 PST [18395] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:05:38.383 PST [18395] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 19:09:30.910 PST [18497] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:09:30.910 PST [18497] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 19:10:33.289 PST [18526] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:10:33.289 PST [18526] LOG:  statement: SELECT id, name FROM restaurants limit 50
2023-12-09 19:12:36.274 PST [18587] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:12:36.275 PST [18587] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 19:13:18.485 PST [18616] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:13:18.486 PST [18616] ERROR:  syntax error at or near "distinct" at character 12
2023-12-09 19:13:18.486 PST [18616] STATEMENT:  SELECT id, distinct(name) FROM restaurants limit 1000
2023-12-09 19:13:56.345 PST [18639] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:13:56.345 PST [18639] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 19:16:18.323 PST [18700] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:16:18.323 PST [18700] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 19:17:14.976 PST [18726] LOG:  execute <unnamed>: BEGIN
2023-12-09 19:17:14.977 PST [18726] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 19:47:35.583 PST [19526] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 19:47:35.590 PST [19526] LOG:  statement: SELECT version()
2023-12-09 19:47:35.591 PST [19526] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 19:47:35.603 PST [19526] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 19:47:35.606 PST [19526] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 19:47:35.644 PST [19528] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 19:47:35.650 PST [19528] LOG:  statement: SELECT version()
2023-12-09 19:47:35.651 PST [19528] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 19:47:35.655 PST [19528] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 19:47:35.656 PST [19528] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 19:47:35.672 PST [19529] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 19:47:35.675 PST [19529] LOG:  statement: SELECT version()
2023-12-09 19:47:35.675 PST [19529] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 19:47:35.676 PST [19529] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 19:47:35.677 PST [19529] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 19:51:40.986 PST [19577] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 19:51:40.991 PST [19577] LOG:  statement: SELECT version()
2023-12-09 19:51:40.995 PST [19577] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 19:51:40.996 PST [19577] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 19:51:40.998 PST [19577] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 19:51:41.020 PST [19579] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 19:51:41.022 PST [19579] LOG:  statement: SELECT version()
2023-12-09 19:51:41.023 PST [19579] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 19:51:41.024 PST [19579] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 19:51:41.025 PST [19579] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 19:51:41.043 PST [19580] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 19:51:41.046 PST [19580] LOG:  statement: SELECT version()
2023-12-09 19:51:41.046 PST [19580] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 19:51:41.047 PST [19580] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 19:51:41.048 PST [19580] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 19:59:17.488 PST [19778] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 19:59:17.491 PST [19778] LOG:  statement: SELECT version()
2023-12-09 19:59:17.492 PST [19778] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 19:59:17.494 PST [19778] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 19:59:17.496 PST [19778] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 19:59:17.503 PST [19580] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16674;
	
2023-12-09 19:59:17.640 PST [19580] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-09 19:59:17.714 PST [19580] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-09 19:59:17.722 PST [19778] LOG:  statement: SELECT * FROM public.menus
	ORDER BY id ASC 
2023-12-09 19:59:17.868 PST [19778] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16674::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 19:59:17.935 PST [19778] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 19:59:17.935 PST [19778] DETAIL:  parameters: $1 = '{23,23,25,1043,25,1700}'
2023-12-09 20:00:05.752 PST [36662] LOG:  checkpoint starting: time
2023-12-09 20:00:05.901 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.125 s, sync=0.003 s, total=0.150 s; sync files=1, longest=0.003 s, average=0.003 s; distance=3 kB, estimate=6885 kB
2023-12-09 20:00:33.784 PST [19809] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:00:33.786 PST [19809] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:00:33.786 PST [19809] DETAIL:  parameters: $1 = '12'
2023-12-09 20:03:11.251 PST [19884] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:03:11.256 PST [19884] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:03:11.256 PST [19884] DETAIL:  parameters: $1 = '12'
2023-12-09 20:05:38.593 PST [19946] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:05:38.596 PST [19946] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:05:38.596 PST [19946] DETAIL:  parameters: $1 = '12'
2023-12-09 20:07:42.398 PST [19999] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:07:42.400 PST [19999] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:07:42.400 PST [19999] DETAIL:  parameters: $1 = '12'
2023-12-09 20:22:20.991 PST [20362] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:22:20.994 PST [20362] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:22:20.994 PST [20362] DETAIL:  parameters: $1 = '12'
2023-12-09 20:22:53.621 PST [20379] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:22:53.623 PST [20379] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:22:53.623 PST [20379] DETAIL:  parameters: $1 = '12'
2023-12-09 20:24:17.236 PST [20410] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:24:17.238 PST [20410] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:24:17.238 PST [20410] DETAIL:  parameters: $1 = '12'
2023-12-09 20:25:58.013 PST [20453] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:25:58.015 PST [20453] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:25:58.015 PST [20453] DETAIL:  parameters: $1 = '12'
2023-12-09 20:26:00.613 PST [20456] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:26:00.615 PST [20456] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:26:00.615 PST [20456] DETAIL:  parameters: $1 = '12'
2023-12-09 20:26:06.593 PST [20462] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:26:06.596 PST [20462] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:26:06.596 PST [20462] DETAIL:  parameters: $1 = '12'
2023-12-09 20:30:09.748 PST [20560] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:30:09.751 PST [20560] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:30:09.751 PST [20560] DETAIL:  parameters: $1 = '12'
2023-12-09 20:31:02.694 PST [20582] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:31:02.697 PST [20582] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:31:02.697 PST [20582] DETAIL:  parameters: $1 = '12'
2023-12-09 20:32:02.821 PST [20614] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:32:02.825 PST [20614] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:32:02.825 PST [20614] DETAIL:  parameters: $1 = '12'
2023-12-09 20:33:52.615 PST [20666] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:33:52.617 PST [20666] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:33:52.617 PST [20666] DETAIL:  parameters: $1 = '12'
2023-12-09 20:35:37.897 PST [20710] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:35:37.899 PST [20710] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:35:37.899 PST [20710] DETAIL:  parameters: $1 = '12'
2023-12-09 20:38:09.700 PST [20799] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:38:09.703 PST [20799] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:38:09.703 PST [20799] DETAIL:  parameters: $1 = '12'
2023-12-09 20:38:11.202 PST [20802] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:38:11.204 PST [20802] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:38:11.204 PST [20802] DETAIL:  parameters: $1 = '12'
2023-12-09 20:40:12.274 PST [20853] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:40:12.277 PST [20853] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:40:12.277 PST [20853] DETAIL:  parameters: $1 = '12'
2023-12-09 20:40:15.751 PST [20858] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:40:15.753 PST [20858] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:40:15.753 PST [20858] DETAIL:  parameters: $1 = '12'
2023-12-09 20:40:20.574 PST [20863] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:40:20.576 PST [20863] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:40:20.576 PST [20863] DETAIL:  parameters: $1 = '12'
2023-12-09 20:41:40.048 PST [20928] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:41:40.055 PST [20928] LOG:  execute <unnamed>: INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-09 20:41:40.055 PST [20928] DETAIL:  parameters: $1 = 'ayaan', $2 = 'ayaan@gmail.com', $3 = '12345678', $4 = '0987654321'
2023-12-09 20:41:40.063 PST [20928] LOG:  execute <unnamed>: COMMIT
2023-12-09 20:41:40.080 PST [20929] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:41:40.080 PST [20929] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 20:41:48.866 PST [20940] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:41:48.870 PST [20940] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:41:48.870 PST [20940] DETAIL:  parameters: $1 = '2'
2023-12-09 20:43:18.266 PST [20986] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:43:18.269 PST [20986] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:43:18.269 PST [20986] DETAIL:  parameters: $1 = '2'
2023-12-09 20:43:19.403 PST [20989] LOG:  execute <unnamed>: BEGIN
2023-12-09 20:43:19.405 PST [20989] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 20:43:19.405 PST [20989] DETAIL:  parameters: $1 = '2'
2023-12-09 20:45:05.957 PST [36662] LOG:  checkpoint starting: time
2023-12-09 20:45:06.309 PST [36662] LOG:  checkpoint complete: wrote 4 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.330 s, sync=0.005 s, total=0.353 s; sync files=4, longest=0.003 s, average=0.002 s; distance=0 kB, estimate=6197 kB
2023-12-09 21:13:34.313 PST [21829] LOG:  execute <unnamed>: BEGIN
2023-12-09 21:13:34.313 PST [21829] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 21:17:36.798 PST [21950] LOG:  execute <unnamed>: BEGIN
2023-12-09 21:17:36.798 PST [21950] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 21:17:44.719 PST [21959] LOG:  execute <unnamed>: BEGIN
2023-12-09 21:17:44.719 PST [21959] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 21:19:39.496 PST [22014] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 21:19:39.503 PST [22014] LOG:  statement: SELECT version()
2023-12-09 21:19:39.506 PST [22014] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 21:19:39.510 PST [22014] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 21:19:39.513 PST [22014] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 21:19:39.520 PST [19580] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16694;
	
2023-12-09 21:19:39.615 PST [19580] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-09 21:19:39.626 PST [19580] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-09 21:19:39.629 PST [22014] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-09 21:19:39.716 PST [22014] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 21:19:39.736 PST [22014] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 21:19:39.736 PST [22014] DETAIL:  parameters: $1 = '{23,23,23,1700}'
2023-12-09 21:20:05.353 PST [36662] LOG:  checkpoint starting: time
2023-12-09 21:20:05.477 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.104 s, sync=0.006 s, total=0.124 s; sync files=1, longest=0.006 s, average=0.006 s; distance=3 kB, estimate=5577 kB
2023-12-09 21:20:54.004 PST [19580] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 21:20:54.016 PST [19580] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16603::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16603::oid ORDER BY rel.relname;
2023-12-09 21:20:54.097 PST [19580] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 21:20:54.099 PST [19580] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 21:20:54.102 PST [19580] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16603::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 21:20:54.109 PST [19580] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16603::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 21:20:54.131 PST [19580] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 21:20:54.141 PST [19580] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 21:20:54.142 PST [19580] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 21:20:54.143 PST [19580] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16603::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 21:20:54.144 PST [19580] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 21:20:54.152 PST [19580] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-09 21:20:54.154 PST [19580] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16607::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-09 21:20:54.155 PST [19580] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 21:20:54.158 PST [19580] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16603::oid
	ORDER BY conname
2023-12-09 21:20:54.160 PST [19580] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16603::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16694::oid
	    AND a2.attnum=1
	
2023-12-09 21:20:54.161 PST [19580] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16694::oid
2023-12-09 21:20:54.162 PST [19580] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16603::oid
	   AND conname IS NULL
2023-12-09 21:20:54.165 PST [19580] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16607 , 1 , true) AS column
	
2023-12-09 21:20:54.165 PST [19580] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16603::oid
	
2023-12-09 21:20:54.167 PST [19580] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16603::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 21:20:54.789 PST [19580] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 21:20:54.811 PST [19580] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 21:20:54.824 PST [19580] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 21:22:08.079 PST [19580] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16603::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16603::oid ORDER BY rel.relname;
2023-12-09 21:22:08.086 PST [19580] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 21:22:08.090 PST [19580] LOG:  statement: DROP TABLE IF EXISTS public.payment CASCADE;
2023-12-09 21:22:18.083 PST [19580] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 21:22:18.095 PST [19580] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-09 21:22:18.101 PST [19580] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 21:22:27.272 PST [19580] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 21:25:05.489 PST [36662] LOG:  checkpoint starting: time
2023-12-09 21:25:08.657 PST [36662] LOG:  checkpoint complete: wrote 32 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.161 s, sync=0.003 s, total=3.169 s; sync files=16, longest=0.001 s, average=0.001 s; distance=197 kB, estimate=5039 kB
2023-12-09 21:25:53.452 PST [19580] LOG:  statement: CREATE TABLE public.menu_items
	(
	    id integer NOT NULL,
	    item_name bit varying(255),
	    qty integer,
	    price numeric(255, 2)
	);
	
	
	ALTER TABLE IF EXISTS public.menu_items
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-09 21:25:53.468 PST [19580] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'menu_items'::text AND nspname = 'public';
	
2023-12-09 21:25:53.469 PST [19580] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'menu_items'
2023-12-09 21:30:05.664 PST [36662] LOG:  checkpoint starting: time
2023-12-09 21:30:07.438 PST [36662] LOG:  checkpoint complete: wrote 18 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.752 s, sync=0.009 s, total=1.775 s; sync files=16, longest=0.006 s, average=0.001 s; distance=90 kB, estimate=4544 kB
2023-12-09 22:01:11.781 PST [22659] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 22:01:11.784 PST [22659] LOG:  statement: SELECT version()
2023-12-09 22:01:11.785 PST [22659] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 22:01:11.788 PST [22659] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 22:01:11.789 PST [22659] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 22:01:11.813 PST [22660] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 22:01:11.821 PST [22660] LOG:  statement: SELECT version()
2023-12-09 22:01:11.821 PST [22660] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 22:01:11.826 PST [22660] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 22:01:11.828 PST [22660] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 22:01:11.844 PST [22661] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 22:01:11.846 PST [22661] LOG:  statement: SELECT version()
2023-12-09 22:01:11.847 PST [22661] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 22:01:11.847 PST [22661] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 22:01:11.848 PST [22661] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 22:02:36.220 PST [36662] LOG:  checkpoint starting: time
2023-12-09 22:02:36.339 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.110 s, sync=0.002 s, total=0.119 s; sync files=1, longest=0.002 s, average=0.002 s; distance=8 kB, estimate=4091 kB
2023-12-09 22:04:36.180 PST [22744] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-09 22:04:36.183 PST [22744] LOG:  statement: SELECT version()
2023-12-09 22:04:36.184 PST [22744] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-09 22:04:36.187 PST [22744] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-09 22:04:36.188 PST [22744] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-09 22:04:36.194 PST [22661] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16736;
	
2023-12-09 22:04:36.303 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:04:36.368 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:04:36.377 PST [22744] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-09 22:04:36.426 PST [22744] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 22:04:36.455 PST [22744] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 22:04:36.455 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700}'
2023-12-09 22:05:08.476 PST [22661] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-09 22:05:08.478 PST [22661] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-09 22:05:08.486 PST [22661] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16736::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16736::oid ORDER BY rel.relname;
2023-12-09 22:05:08.505 PST [22661] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:05:08.507 PST [22661] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:05:08.509 PST [22661] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 22:05:08.518 PST [22661] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1562,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1562,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 22:05:08.521 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:05:08.523 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:05:08.524 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:05:08.525 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:05:08.526 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 22:05:08.529 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 22:05:08.531 PST [22661] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16736::oid
	ORDER BY conname
2023-12-09 22:05:08.532 PST [22661] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16736::oid
	
2023-12-09 22:05:08.533 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 22:05:09.262 PST [22661] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 22:05:09.279 PST [22661] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 22:05:09.295 PST [22661] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 22:05:09.312 PST [22661] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-09 22:06:47.367 PST [22661] LOG:  statement: SELECT --nspname, collname,
	    CASE WHEN length(nspname::text) > 0 AND length(collname::text) > 0  THEN
	        pg_catalog.concat(pg_catalog.quote_ident(nspname), '.', pg_catalog.quote_ident(collname))
	    ELSE '' END AS copy_collation
	FROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n
	WHERE c.collnamespace=n.oid
	ORDER BY nspname, collname;
2023-12-09 22:06:51.463 PST [22661] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16736::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16736::oid ORDER BY rel.relname;
2023-12-09 22:06:51.472 PST [22661] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:06:51.474 PST [22661] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-09 22:06:51.481 PST [22661] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16736::oid;
	
2023-12-09 22:06:51.483 PST [22661] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-09 22:06:51.483 PST [22661] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16736::oid;
2023-12-09 22:06:51.484 PST [22661] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:06:51.486 PST [22661] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-09 22:06:51.491 PST [22661] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1562,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1562,1700)
	) t
	GROUP BY t.main_oid;
2023-12-09 22:06:51.493 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:06:51.494 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:06:51.495 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:06:51.496 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-09 22:06:51.497 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-09 22:06:51.499 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-09 22:06:51.501 PST [22661] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16736::oid
	ORDER BY conname
2023-12-09 22:06:51.503 PST [22661] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16736::oid
	
2023-12-09 22:06:51.504 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-09 22:06:51.513 PST [22661] LOG:  statement: ALTER TABLE IF EXISTS public.menu_items
	    ADD COLUMN user_id integer;
2023-12-09 22:06:51.519 PST [22661] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16736::oid;
	
2023-12-09 22:06:55.173 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:06:55.176 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:06:55.179 PST [22744] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-09 22:06:55.284 PST [22744] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 22:06:55.298 PST [22744] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 22:06:55.298 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 22:07:36.344 PST [36662] LOG:  checkpoint starting: time
2023-12-09 22:07:37.883 PST [36662] LOG:  checkpoint complete: wrote 16 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.524 s, sync=0.005 s, total=1.539 s; sync files=12, longest=0.002 s, average=0.001 s; distance=82 kB, estimate=3690 kB
2023-12-09 22:10:03.019 PST [22952] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:10:03.019 PST [22952] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 22:10:08.488 PST [22957] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:10:08.499 PST [22957] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:10:08.499 PST [22957] DETAIL:  parameters: $1 = '2'
2023-12-09 22:10:11.148 PST [22960] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:10:11.148 PST [22960] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 22:10:14.459 PST [22965] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:10:14.462 PST [22965] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:10:14.462 PST [22965] DETAIL:  parameters: $1 = '3'
2023-12-09 22:10:16.441 PST [22969] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:10:16.441 PST [22969] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 22:10:22.501 PST [22975] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:10:22.503 PST [22975] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:10:22.503 PST [22975] DETAIL:  parameters: $1 = '11'
2023-12-09 22:18:54.895 PST [23195] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:18:54.899 PST [23195] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:18:54.899 PST [23195] DETAIL:  parameters: $1 = '11'
2023-12-09 22:21:02.424 PST [23267] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:21:02.426 PST [23267] ERROR:  column "id" does not exist at character 8
2023-12-09 22:21:02.426 PST [23267] STATEMENT:  SELECT id FROM users WHERE username = $1
2023-12-09 22:21:07.737 PST [23278] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:21:07.741 PST [23278] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:21:07.741 PST [23278] DETAIL:  parameters: $1 = '11'
2023-12-09 22:21:13.046 PST [23283] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:21:13.047 PST [23283] ERROR:  column "id" does not exist at character 8
2023-12-09 22:21:13.047 PST [23283] STATEMENT:  SELECT id FROM users WHERE username = $1
2023-12-09 22:21:23.140 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:21:23.148 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:21:23.150 PST [22744] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-09 22:21:23.194 PST [22744] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 22:21:23.199 PST [22744] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 22:21:23.199 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 22:26:02.178 PST [23411] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:26:02.179 PST [23411] ERROR:  column "id" does not exist at character 8
2023-12-09 22:26:02.179 PST [23411] STATEMENT:  SELECT id FROM users WHERE username = $1
2023-12-09 22:26:06.497 PST [23416] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:26:06.500 PST [23416] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:26:06.500 PST [23416] DETAIL:  parameters: $1 = '11'
2023-12-09 22:26:13.501 PST [23425] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:26:13.502 PST [23425] ERROR:  column "id" does not exist at character 8
2023-12-09 22:26:13.502 PST [23425] STATEMENT:  SELECT id FROM users WHERE username = $1
2023-12-09 22:28:03.563 PST [23479] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:28:03.565 PST [23479] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:28:03.565 PST [23479] DETAIL:  parameters: $1 = '11'
2023-12-09 22:28:09.120 PST [23484] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:28:09.130 PST [23484] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:28:09.130 PST [23484] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:28:09.136 PST [23485] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:28:09.136 PST [23485] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:28:09.147 PST [23486] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:28:09.148 PST [23486] ERROR:  column "item_id" of relation "menu_items" does not exist at character 38
2023-12-09 22:28:09.148 PST [23486] STATEMENT:  INSERT INTO menu_items (id, user_id, item_id, qty) VALUES ($1, $2, $3, $4)
2023-12-09 22:29:49.548 PST [23543] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:29:49.557 PST [23543] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:29:49.557 PST [23543] DETAIL:  parameters: $1 = '11'
2023-12-09 22:29:54.736 PST [23549] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:29:54.739 PST [23549] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:29:54.739 PST [23549] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:29:54.747 PST [23552] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:29:54.747 PST [23552] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:29:54.756 PST [23553] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:29:54.757 PST [23553] ERROR:  "3" is not a valid binary digit
2023-12-09 22:29:54.757 PST [23553] CONTEXT:  unnamed portal parameter $3 = '...'
2023-12-09 22:29:54.757 PST [23553] STATEMENT:  INSERT INTO menu_items (id, user_id, item_name, qty) VALUES ($1, $2, $3, $4)
2023-12-09 22:31:54.692 PST [23612] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:31:54.694 PST [23612] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:31:54.694 PST [23612] DETAIL:  parameters: $1 = '11'
2023-12-09 22:31:59.392 PST [23617] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:31:59.394 PST [23617] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:31:59.394 PST [23617] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:31:59.400 PST [23618] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:31:59.400 PST [23618] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:31:59.408 PST [23619] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:31:59.409 PST [23619] ERROR:  "3" is not a valid binary digit
2023-12-09 22:31:59.409 PST [23619] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-09 22:31:59.409 PST [23619] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, user_id) VALUES ($1, $2, $3, $4)
2023-12-09 22:32:32.420 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:32:32.422 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:32:32.430 PST [22744] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-09 22:32:32.473 PST [22744] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 22:32:32.479 PST [22744] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 22:32:32.479 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 22:32:37.304 PST [36662] LOG:  checkpoint starting: time
2023-12-09 22:32:37.422 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.103 s, sync=0.002 s, total=0.118 s; sync files=1, longest=0.002 s, average=0.002 s; distance=0 kB, estimate=3321 kB
2023-12-09 22:32:56.307 PST [23649] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:32:56.308 PST [23649] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 22:33:01.301 PST [23654] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:33:01.304 PST [23654] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:33:01.304 PST [23654] DETAIL:  parameters: $1 = '3'
2023-12-09 22:33:09.085 PST [23663] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:33:09.088 PST [23663] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:33:09.088 PST [23663] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:33:09.095 PST [23664] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:33:09.095 PST [23664] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:33:09.103 PST [23665] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:33:09.104 PST [23665] ERROR:  "2" is not a valid binary digit
2023-12-09 22:33:09.104 PST [23665] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-09 22:33:09.104 PST [23665] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, user_id) VALUES ($1, $2, $3, $4)
2023-12-09 22:34:47.829 PST [23712] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:34:47.831 PST [23712] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:34:47.831 PST [23712] DETAIL:  parameters: $1 = '3'
2023-12-09 22:34:51.311 PST [23716] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:34:51.313 PST [23716] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:34:51.313 PST [23716] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:34:51.319 PST [23717] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:34:51.319 PST [23717] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:34:51.328 PST [23718] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:34:51.330 PST [23718] ERROR:  "9" is not a valid binary digit
2023-12-09 22:34:51.330 PST [23718] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-09 22:34:51.330 PST [23718] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, user_id) VALUES ($1, $2, $3, $4)
2023-12-09 22:39:09.461 PST [23828] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:39:09.464 PST [23828] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:39:09.464 PST [23828] DETAIL:  parameters: $1 = '3'
2023-12-09 22:39:16.652 PST [23834] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:39:16.654 PST [23834] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:39:16.654 PST [23834] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:39:16.661 PST [23835] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:39:16.662 PST [23835] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:39:16.671 PST [23836] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:39:16.673 PST [23836] ERROR:  "2" is not a valid binary digit
2023-12-09 22:39:16.673 PST [23836] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-09 22:39:16.673 PST [23836] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-09 22:43:54.505 PST [23956] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:43:54.509 PST [23956] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:43:54.509 PST [23956] DETAIL:  parameters: $1 = '3'
2023-12-09 22:43:58.701 PST [23962] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:43:58.704 PST [23962] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:43:58.704 PST [23962] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:43:58.712 PST [23963] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:43:58.712 PST [23963] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:43:58.734 PST [23965] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:43:58.735 PST [23965] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 22:43:58.735 PST [23965] DETAIL:  parameters: $1 = '1'
2023-12-09 22:44:17.700 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:44:17.707 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:44:17.709 PST [22744] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-09 22:44:17.794 PST [22744] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 22:44:17.818 PST [22744] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 22:44:17.818 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 22:45:07.735 PST [24006] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:45:07.735 PST [24006] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 22:45:13.130 PST [24013] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:45:13.133 PST [24013] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:45:13.133 PST [24013] DETAIL:  parameters: $1 = '7'
2023-12-09 22:45:19.997 PST [24021] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:45:20.000 PST [24021] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:45:20.000 PST [24021] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:45:20.007 PST [24022] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:45:20.007 PST [24022] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:45:20.029 PST [24024] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:45:20.031 PST [24024] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 22:45:20.031 PST [24024] DETAIL:  parameters: $1 = '1'
2023-12-09 22:45:33.586 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:45:33.590 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:45:33.592 PST [22744] LOG:  execute _pg3_0: SELECT * FROM public.menu_items
	
2023-12-09 22:45:33.643 PST [22744] LOG:  execute _pg3_1: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 22:45:33.647 PST [22744] LOG:  execute _pg3_2: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 22:45:33.647 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 22:48:54.989 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:48:54.990 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 22:48:54.992 PST [22744] LOG:  execute _pg3_0: SELECT * FROM public.menu_items
	
2023-12-09 22:48:55.043 PST [22744] LOG:  execute _pg3_1: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 22:48:55.046 PST [22744] LOG:  execute _pg3_2: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 22:48:55.046 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 22:55:55.471 PST [24308] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:55:55.471 PST [24308] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 22:56:00.384 PST [24313] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:56:00.387 PST [24313] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:56:00.387 PST [24313] DETAIL:  parameters: $1 = '2'
2023-12-09 22:56:04.903 PST [24318] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:56:04.906 PST [24318] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:56:04.906 PST [24318] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:56:04.913 PST [24319] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:56:04.913 PST [24319] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:56:04.923 PST [24320] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:56:04.924 PST [24320] LOG:  execute <unnamed>: SELECT name, price FROM menus WHERE id = $1
2023-12-09 22:56:04.924 PST [24320] DETAIL:  parameters: $1 = '75'
2023-12-09 22:56:04.927 PST [24320] ERROR:  "A" is not a valid binary digit
2023-12-09 22:56:04.927 PST [24320] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-09 22:56:04.927 PST [24320] STATEMENT:  INSERT INTO menu_items (id, item_name, price, qty, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-09 22:57:43.381 PST [24371] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:57:43.383 PST [24371] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 22:57:43.383 PST [24371] DETAIL:  parameters: $1 = '2'
2023-12-09 22:57:47.464 PST [24373] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:57:47.466 PST [24373] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 22:57:47.466 PST [24373] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 22:57:47.472 PST [24374] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:57:47.473 PST [24374] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 22:57:47.480 PST [24375] LOG:  execute <unnamed>: BEGIN
2023-12-09 22:57:47.482 PST [24375] LOG:  execute <unnamed>: SELECT name, price FROM menus WHERE id = $1
2023-12-09 22:57:47.482 PST [24375] DETAIL:  parameters: $1 = '75'
2023-12-09 22:57:47.483 PST [24375] ERROR:  "A" is not a valid binary digit
2023-12-09 22:57:47.483 PST [24375] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-09 22:57:47.483 PST [24375] STATEMENT:  INSERT INTO menu_items (id, item_name, price, qty, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-09 23:01:18.001 PST [24468] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:01:18.005 PST [24468] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:01:18.005 PST [24468] DETAIL:  parameters: $1 = '2'
2023-12-09 23:01:21.841 PST [24472] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:01:21.844 PST [24472] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:01:21.844 PST [24472] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:01:21.853 PST [24473] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:01:21.853 PST [24473] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:01:21.875 PST [24475] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:01:21.876 PST [24475] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:01:21.876 PST [24475] DETAIL:  parameters: $1 = '1'
2023-12-09 23:07:14.711 PST [24632] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:07:14.712 PST [24632] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:07:45.221 PST [24646] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:07:45.224 PST [24646] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:07:45.224 PST [24646] DETAIL:  parameters: $1 = '1'
2023-12-09 23:07:48.170 PST [24650] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:07:48.173 PST [24650] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:07:48.173 PST [24650] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:07:48.179 PST [24651] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:07:48.179 PST [24651] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:07:48.199 PST [24653] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:07:48.201 PST [24653] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:07:48.201 PST [24653] DETAIL:  parameters: $1 = '1'
2023-12-09 23:07:59.266 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 23:07:59.270 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 23:07:59.276 PST [22744] LOG:  execute _pg3_0: SELECT * FROM public.menu_items
	
2023-12-09 23:07:59.332 PST [22744] LOG:  execute _pg3_1: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 23:07:59.339 PST [22744] LOG:  execute _pg3_2: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 23:07:59.339 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 23:10:13.887 PST [24720] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:10:13.887 PST [24720] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:10:19.480 PST [24727] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:10:19.483 PST [24727] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:10:19.483 PST [24727] DETAIL:  parameters: $1 = '3'
2023-12-09 23:10:23.237 PST [24731] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:10:23.239 PST [24731] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:10:23.239 PST [24731] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:10:23.245 PST [24732] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:10:23.246 PST [24732] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:10:23.267 PST [24734] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:10:23.270 PST [24734] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:10:23.270 PST [24734] DETAIL:  parameters: $1 = '1'
2023-12-09 23:13:10.699 PST [24811] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:13:10.699 PST [24811] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:13:15.673 PST [24818] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:13:15.675 PST [24818] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:13:15.675 PST [24818] DETAIL:  parameters: $1 = '2'
2023-12-09 23:13:19.984 PST [24822] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:13:19.987 PST [24822] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:13:19.987 PST [24822] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:13:19.994 PST [24823] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:13:19.995 PST [24823] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:13:20.016 PST [24825] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:13:20.017 PST [24825] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:13:20.017 PST [24825] DETAIL:  parameters: $1 = '1'
2023-12-09 23:16:31.995 PST [24937] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:16:31.996 PST [24937] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:16:36.470 PST [24944] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:16:36.473 PST [24944] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:16:36.473 PST [24944] DETAIL:  parameters: $1 = '3'
2023-12-09 23:16:45.884 PST [24953] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:16:45.891 PST [24953] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:16:45.891 PST [24953] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:16:45.897 PST [24954] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:16:45.897 PST [24954] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:16:45.919 PST [24956] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:16:45.921 PST [24956] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:16:45.921 PST [24956] DETAIL:  parameters: $1 = '1'
2023-12-09 23:19:19.596 PST [25028] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:19:19.596 PST [25028] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:19:25.159 PST [25033] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:19:25.162 PST [25033] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:19:25.162 PST [25033] DETAIL:  parameters: $1 = '1'
2023-12-09 23:19:28.458 PST [25036] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:19:28.461 PST [25036] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:19:28.461 PST [25036] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:19:28.469 PST [25037] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:19:28.469 PST [25037] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:19:28.492 PST [25039] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:19:28.494 PST [25039] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:19:28.494 PST [25039] DETAIL:  parameters: $1 = '1'
2023-12-09 23:23:55.321 PST [25160] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:23:55.322 PST [25160] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:23:59.738 PST [25165] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:23:59.740 PST [25165] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:23:59.740 PST [25165] DETAIL:  parameters: $1 = '1'
2023-12-09 23:24:07.783 PST [25171] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:24:07.786 PST [25171] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:24:07.786 PST [25171] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:24:07.793 PST [25172] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:24:07.793 PST [25172] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:24:07.817 PST [25174] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:24:07.819 PST [25174] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:24:07.819 PST [25174] DETAIL:  parameters: $1 = '1'
2023-12-09 23:26:36.380 PST [25257] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:26:36.380 PST [25257] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:26:41.270 PST [25263] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:26:41.273 PST [25263] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:26:41.273 PST [25263] DETAIL:  parameters: $1 = '2'
2023-12-09 23:26:51.218 PST [25270] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:26:51.222 PST [25270] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:26:51.222 PST [25270] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:26:51.228 PST [25271] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:26:51.229 PST [25271] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:26:51.255 PST [25273] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:26:51.256 PST [25273] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:26:51.256 PST [25273] DETAIL:  parameters: $1 = '1'
2023-12-09 23:28:01.653 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 23:28:01.655 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-09 23:28:01.658 PST [22744] LOG:  execute _pg3_0: SELECT * FROM public.menu_items
	
2023-12-09 23:28:01.707 PST [22744] LOG:  execute _pg3_1: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-09 23:28:01.714 PST [22744] LOG:  execute _pg3_2: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-09 23:28:01.714 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-09 23:29:18.735 PST [25349] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:29:18.736 PST [25349] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:29:24.308 PST [25354] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:29:24.311 PST [25354] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:29:24.311 PST [25354] DETAIL:  parameters: $1 = '1'
2023-12-09 23:29:35.057 PST [25361] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:29:35.061 PST [25361] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:29:35.061 PST [25361] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:29:35.069 PST [25362] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:29:35.069 PST [25362] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:29:35.093 PST [25364] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:29:35.095 PST [25364] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:29:35.095 PST [25364] DETAIL:  parameters: $1 = '1'
2023-12-09 23:32:24.891 PST [25458] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:32:24.891 PST [25458] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:32:29.071 PST [25467] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:32:29.073 PST [25467] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:32:29.073 PST [25467] DETAIL:  parameters: $1 = '3'
2023-12-09 23:32:34.828 PST [25471] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:32:34.831 PST [25471] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:32:34.831 PST [25471] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:32:34.838 PST [25472] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:32:34.839 PST [25472] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:32:34.860 PST [25474] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:32:34.861 PST [25474] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:32:34.861 PST [25474] DETAIL:  parameters: $1 = '1'
2023-12-09 23:33:41.027 PST [25512] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:33:41.027 PST [25512] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:33:45.327 PST [25517] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:33:45.329 PST [25517] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:33:45.329 PST [25517] DETAIL:  parameters: $1 = '1'
2023-12-09 23:33:50.662 PST [25522] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:33:50.666 PST [25522] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:33:50.666 PST [25522] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:33:50.672 PST [25523] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:33:50.672 PST [25523] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:33:50.694 PST [25525] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:33:50.696 PST [25525] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:33:50.696 PST [25525] DETAIL:  parameters: $1 = '1'
2023-12-09 23:36:03.168 PST [25581] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:36:03.168 PST [25581] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:36:13.440 PST [25594] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:36:13.443 PST [25594] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:36:13.443 PST [25594] DETAIL:  parameters: $1 = '7'
2023-12-09 23:36:30.669 PST [25605] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:36:30.677 PST [25605] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:36:30.677 PST [25605] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:36:30.684 PST [25606] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:36:30.684 PST [25606] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:36:30.706 PST [25608] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:36:30.708 PST [25608] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:36:30.708 PST [25608] DETAIL:  parameters: $1 = '1'
2023-12-09 23:49:45.273 PST [25915] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:49:45.274 PST [25915] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-09 23:49:50.376 PST [25922] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:49:50.379 PST [25922] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-09 23:49:50.379 PST [25922] DETAIL:  parameters: $1 = '7'
2023-12-09 23:50:06.318 PST [25943] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:50:06.321 PST [25943] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-09 23:50:06.321 PST [25943] DETAIL:  parameters: $1 = 'ayaan'
2023-12-09 23:50:06.328 PST [25944] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:50:06.328 PST [25944] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-09 23:50:06.348 PST [25946] LOG:  execute <unnamed>: BEGIN
2023-12-09 23:50:06.350 PST [25946] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-09 23:50:06.350 PST [25946] DETAIL:  parameters: $1 = '1'
2023-12-10 00:05:10.370 PST [26337] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:05:10.370 PST [26337] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 00:05:15.309 PST [26344] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:05:15.312 PST [26344] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:05:15.312 PST [26344] DETAIL:  parameters: $1 = '2'
2023-12-10 00:05:27.806 PST [26351] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:05:27.810 PST [26351] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:05:27.810 PST [26351] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:05:27.817 PST [26352] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:05:27.817 PST [26352] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:05:27.827 PST [26353] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:05:27.832 PST [26353] ERROR:  "T" is not a valid binary digit
2023-12-10 00:05:27.832 PST [26353] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:05:27.832 PST [26353] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:08:01.843 PST [26421] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:08:01.846 PST [26421] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:08:01.846 PST [26421] DETAIL:  parameters: $1 = '2'
2023-12-10 00:08:19.702 PST [26432] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:08:19.705 PST [26432] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:08:19.705 PST [26432] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:08:19.713 PST [26433] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:08:19.713 PST [26433] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:08:19.719 PST [26434] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:08:19.720 PST [26434] ERROR:  "N" is not a valid binary digit
2023-12-10 00:08:19.720 PST [26434] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:08:19.720 PST [26434] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:10:17.848 PST [26483] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:10:17.857 PST [26483] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:10:17.857 PST [26483] DETAIL:  parameters: $1 = '2'
2023-12-10 00:10:31.706 PST [26490] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:10:31.709 PST [26490] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:10:31.709 PST [26490] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:10:31.716 PST [26491] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:10:31.716 PST [26491] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:10:31.725 PST [26492] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:10:31.726 PST [26492] ERROR:  "T" is not a valid binary digit
2023-12-10 00:10:31.726 PST [26492] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:10:31.726 PST [26492] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:10:58.197 PST [26511] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:10:58.199 PST [26511] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:10:58.199 PST [26511] DETAIL:  parameters: $1 = '2'
2023-12-10 00:11:10.565 PST [26523] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:11:10.567 PST [26523] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:11:10.567 PST [26523] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:11:10.574 PST [26524] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:11:10.575 PST [26524] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:11:10.584 PST [26525] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:11:10.585 PST [26525] ERROR:  "N" is not a valid binary digit
2023-12-10 00:11:10.585 PST [26525] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:11:10.585 PST [26525] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:12:28.491 PST [26564] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:12:28.492 PST [26564] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:12:28.492 PST [26564] DETAIL:  parameters: $1 = '2'
2023-12-10 00:12:37.922 PST [26573] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:12:37.924 PST [26573] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:12:37.924 PST [26573] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:12:37.930 PST [26574] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:12:37.931 PST [26574] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:12:37.938 PST [26575] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:12:37.940 PST [26575] ERROR:  "T" is not a valid binary digit
2023-12-10 00:12:37.940 PST [26575] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:12:37.940 PST [26575] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:14:48.062 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:14:48.068 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:14:48.081 PST [22744] LOG:  execute _pg3_0: SELECT * FROM public.menu_items
	
2023-12-10 00:14:48.129 PST [22744] LOG:  execute _pg3_1: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 00:14:48.137 PST [22744] LOG:  execute _pg3_2: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 00:14:48.137 PST [22744] DETAIL:  parameters: $1 = '{23,1562,23,1700,23}'
2023-12-10 00:21:59.132 PST [26796] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:21:59.139 PST [26796] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:21:59.139 PST [26796] DETAIL:  parameters: $1 = '2'
2023-12-10 00:22:17.864 PST [26806] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:22:17.869 PST [26806] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:22:17.869 PST [26806] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:22:17.875 PST [26807] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:22:17.875 PST [26807] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:22:17.885 PST [26808] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:22:17.886 PST [26808] ERROR:  "T" is not a valid binary digit
2023-12-10 00:22:17.886 PST [26808] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:22:17.886 PST [26808] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:23:24.328 PST [26838] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:23:24.330 PST [26838] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:23:24.330 PST [26838] DETAIL:  parameters: $1 = '2'
2023-12-10 00:23:35.714 PST [26845] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:23:35.716 PST [26845] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:23:35.716 PST [26845] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:23:35.722 PST [26846] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:23:35.722 PST [26846] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:23:35.731 PST [26847] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:23:35.732 PST [26847] ERROR:  "N" is not a valid binary digit
2023-12-10 00:23:35.732 PST [26847] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:23:35.732 PST [26847] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:26:40.188 PST [26927] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:26:40.190 PST [26927] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:26:40.190 PST [26927] DETAIL:  parameters: $1 = '2'
2023-12-10 00:26:48.817 PST [26933] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:26:48.820 PST [26933] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:26:48.820 PST [26933] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:26:48.828 PST [26934] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:26:48.828 PST [26934] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:26:48.836 PST [26935] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:26:48.837 PST [26935] ERROR:  "J" is not a valid binary digit
2023-12-10 00:26:48.837 PST [26935] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:26:48.837 PST [26935] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:38:59.904 PST [27239] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:38:59.908 PST [27239] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:38:59.908 PST [27239] DETAIL:  parameters: $1 = '2'
2023-12-10 00:39:08.049 PST [27246] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:39:08.052 PST [27246] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:39:08.052 PST [27246] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:39:08.058 PST [27247] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:39:08.058 PST [27247] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:39:08.068 PST [27248] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:39:08.070 PST [27248] ERROR:  "T" is not a valid binary digit
2023-12-10 00:39:08.070 PST [27248] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:39:08.070 PST [27248] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:40:06.592 PST [27280] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:40:06.594 PST [27280] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:40:06.594 PST [27280] DETAIL:  parameters: $1 = '2'
2023-12-10 00:40:17.653 PST [27287] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:40:17.655 PST [27287] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:40:17.655 PST [27287] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:40:17.662 PST [27288] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:40:17.663 PST [27288] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:40:17.671 PST [27289] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:40:17.673 PST [27289] ERROR:  "N" is not a valid binary digit
2023-12-10 00:40:17.673 PST [27289] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:40:17.673 PST [27289] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:41:17.758 PST [27322] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:41:17.761 PST [27322] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:41:17.761 PST [27322] DETAIL:  parameters: $1 = '2'
2023-12-10 00:44:00.353 PST [27397] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:44:00.355 PST [27397] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:44:00.355 PST [27397] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:44:00.359 PST [27398] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:44:00.360 PST [27398] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:44:00.369 PST [27399] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:44:00.370 PST [27399] ERROR:  "J" is not a valid binary digit
2023-12-10 00:44:00.370 PST [27399] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:44:00.370 PST [27399] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:44:02.696 PST [27400] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:44:02.698 PST [27400] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:44:02.698 PST [27400] DETAIL:  parameters: $1 = '2'
2023-12-10 00:44:10.295 PST [27408] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:44:10.297 PST [27408] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:44:10.297 PST [27408] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:44:10.303 PST [27409] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:44:10.304 PST [27409] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:44:10.313 PST [27410] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:44:10.314 PST [27410] ERROR:  "J" is not a valid binary digit
2023-12-10 00:44:10.314 PST [27410] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:44:10.314 PST [27410] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:46:29.644 PST [27475] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:46:29.647 PST [27475] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:46:29.647 PST [27475] DETAIL:  parameters: $1 = '2'
2023-12-10 00:46:34.461 PST [27479] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:46:34.464 PST [27479] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:46:34.464 PST [27479] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:46:34.470 PST [27480] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:46:34.470 PST [27480] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:46:34.477 PST [27481] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:46:34.479 PST [27481] ERROR:  "J" is not a valid binary digit
2023-12-10 00:46:34.479 PST [27481] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:46:34.479 PST [27481] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:49:47.992 PST [27566] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:49:48.002 PST [27566] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:49:48.002 PST [27566] DETAIL:  parameters: $1 = '2'
2023-12-10 00:49:52.052 PST [27573] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:49:52.054 PST [27573] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:49:52.054 PST [27573] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:49:52.059 PST [27574] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:49:52.059 PST [27574] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:49:52.068 PST [27575] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:49:52.069 PST [27575] ERROR:  "J" is not a valid binary digit
2023-12-10 00:49:52.069 PST [27575] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:49:52.069 PST [27575] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:51:50.882 PST [27642] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:51:50.884 PST [27642] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:51:50.884 PST [27642] DETAIL:  parameters: $1 = '2'
2023-12-10 00:51:55.470 PST [27647] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:51:55.473 PST [27647] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:51:55.473 PST [27647] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:51:55.480 PST [27648] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:51:55.480 PST [27648] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:51:55.488 PST [27649] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:51:55.490 PST [27649] ERROR:  "J" is not a valid binary digit
2023-12-10 00:51:55.490 PST [27649] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:51:55.490 PST [27649] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:53:45.215 PST [27703] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:53:45.217 PST [27703] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:53:45.217 PST [27703] DETAIL:  parameters: $1 = '2'
2023-12-10 00:53:50.318 PST [27706] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:53:50.320 PST [27706] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:53:50.320 PST [27706] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:53:50.325 PST [27707] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:53:50.325 PST [27707] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:53:50.334 PST [27708] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:53:50.335 PST [27708] ERROR:  "J" is not a valid binary digit
2023-12-10 00:53:50.335 PST [27708] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:53:50.335 PST [27708] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:55:32.735 PST [27782] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:55:32.737 PST [27782] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:55:32.737 PST [27782] DETAIL:  parameters: $1 = '2'
2023-12-10 00:55:38.040 PST [27788] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:55:38.042 PST [27788] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:55:38.042 PST [27788] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:55:38.049 PST [27789] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:55:38.049 PST [27789] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:55:38.059 PST [27790] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:55:38.060 PST [27790] ERROR:  "J" is not a valid binary digit
2023-12-10 00:55:38.060 PST [27790] CONTEXT:  unnamed portal parameter $2 = '...'
2023-12-10 00:55:38.060 PST [27790] STATEMENT:  INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:56:47.633 PST [22661] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 00:56:47.651 PST [22661] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16736::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16736::oid ORDER BY rel.relname;
2023-12-10 00:56:47.701 PST [22661] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 00:56:47.705 PST [22661] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:56:47.713 PST [22661] LOG:  execute _pg3_1: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:56:47.718 PST [22661] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 00:56:47.730 PST [22661] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1562,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1562,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 00:56:47.737 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:56:47.740 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:56:47.741 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:56:47.742 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:56:47.743 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:56:47.745 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 00:56:47.748 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 00:56:47.750 PST [22661] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16736::oid
	ORDER BY conname
2023-12-10 00:56:47.752 PST [22661] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16736::oid
	
2023-12-10 00:56:47.754 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 00:56:48.416 PST [22661] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 00:56:48.438 PST [22661] LOG:  execute _pg3_2: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 00:56:48.454 PST [22661] LOG:  execute _pg3_2: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 00:56:48.468 PST [22661] LOG:  execute _pg3_2: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 00:56:48.482 PST [22661] LOG:  execute _pg3_2: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 00:57:17.100 PST [22661] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16736::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16736::oid ORDER BY rel.relname;
2023-12-10 00:57:17.113 PST [22661] LOG:  execute _pg3_1: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:57:17.113 PST [22661] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-10 00:57:17.115 PST [22661] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16736::oid;
	
2023-12-10 00:57:17.115 PST [22661] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-10 00:57:17.115 PST [22661] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16736::oid;
2023-12-10 00:57:17.116 PST [22661] LOG:  execute _pg3_1: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16736::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:57:17.117 PST [22661] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 00:57:17.124 PST [22661] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1562,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1562,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 00:57:17.125 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:57:17.126 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:57:17.127 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:57:17.128 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:57:17.129 PST [22661] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16736::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 00:57:17.130 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 00:57:17.132 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 00:57:17.134 PST [22661] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16736::oid
	ORDER BY conname
2023-12-10 00:57:17.135 PST [22661] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16736::oid
	
2023-12-10 00:57:17.136 PST [22661] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16736::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 00:57:17.146 PST [22661] LOG:  statement: ALTER TABLE IF EXISTS public.menu_items DROP COLUMN IF EXISTS item_name;
	
	ALTER TABLE IF EXISTS public.menu_items
	    ADD COLUMN item_name character varying(255);
2023-12-10 00:57:17.154 PST [22661] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16736::oid;
	
2023-12-10 00:57:21.894 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:21.896 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:21.903 PST [22744] ERROR:  cached plan must not change result type
2023-12-10 00:57:21.903 PST [22744] STATEMENT:  SELECT * FROM public.menu_items
	
2023-12-10 00:57:24.794 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:24.795 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:24.797 PST [22744] ERROR:  cached plan must not change result type
2023-12-10 00:57:24.797 PST [22744] STATEMENT:  SELECT * FROM public.menu_items
	
2023-12-10 00:57:34.051 PST [27839] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 00:57:34.054 PST [27839] LOG:  statement: SELECT version()
2023-12-10 00:57:34.055 PST [27839] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 00:57:34.058 PST [27839] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 00:57:34.064 PST [27839] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 00:57:34.073 PST [22661] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16736;
	
2023-12-10 00:57:34.156 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:34.158 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:34.162 PST [27839] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-10 00:57:34.297 PST [27839] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 00:57:34.330 PST [27839] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 00:57:34.330 PST [27839] DETAIL:  parameters: $1 = '{23,23,1700,23,1043}'
2023-12-10 00:57:37.591 PST [36662] LOG:  checkpoint starting: time
2023-12-10 00:57:38.029 PST [36662] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.418 s, sync=0.003 s, total=0.439 s; sync files=5, longest=0.003 s, average=0.001 s; distance=18 kB, estimate=2990 kB
2023-12-10 00:57:47.914 PST [27846] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:57:47.915 PST [27846] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:57:47.915 PST [27846] DETAIL:  parameters: $1 = '2'
2023-12-10 00:57:53.385 PST [27851] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:57:53.388 PST [27851] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:57:53.388 PST [27851] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:57:53.393 PST [27852] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:57:53.394 PST [27852] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:57:53.403 PST [27853] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:57:53.404 PST [27853] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:57:53.404 PST [27853] DETAIL:  parameters: $1 = '1', $2 = 'Jimmy Jam Smoothie', $3 = '1', $4 = '5.49', $5 = '2'
2023-12-10 00:57:53.405 PST [27853] LOG:  execute <unnamed>: COMMIT
2023-12-10 00:57:53.430 PST [27854] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:57:53.433 PST [27854] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-10 00:57:53.433 PST [27854] DETAIL:  parameters: $1 = '1'
2023-12-10 00:57:58.596 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:58.598 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:57:58.600 PST [27839] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-10 00:57:59.153 PST [27839] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 00:57:59.158 PST [27839] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 00:57:59.158 PST [27839] DETAIL:  parameters: $1 = '{23,23,1700,23,1043}'
2023-12-10 00:58:53.632 PST [27885] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:58:53.633 PST [27885] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 00:58:59.009 PST [27890] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:58:59.012 PST [27890] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 00:58:59.012 PST [27890] DETAIL:  parameters: $1 = '1'
2023-12-10 00:59:09.934 PST [27898] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:59:09.943 PST [27898] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 00:59:09.943 PST [27898] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 00:59:09.949 PST [27899] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:59:09.949 PST [27899] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 00:59:09.957 PST [27900] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:59:09.958 PST [27900] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:59:09.958 PST [27900] DETAIL:  parameters: $1 = '2', $2 = 'Extra Large Pepperoni', $3 = '1', $4 = '14.99', $5 = '2'
2023-12-10 00:59:09.959 PST [27900] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 00:59:09.959 PST [27900] DETAIL:  parameters: $1 = '2', $2 = 'Extra Large Meat Lovers Slice', $3 = '3', $4 = '3.99', $5 = '2'
2023-12-10 00:59:09.959 PST [27900] LOG:  execute <unnamed>: COMMIT
2023-12-10 00:59:09.976 PST [27901] LOG:  execute <unnamed>: BEGIN
2023-12-10 00:59:09.977 PST [27901] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-10 00:59:09.977 PST [27901] DETAIL:  parameters: $1 = '2'
2023-12-10 00:59:14.840 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:59:14.844 PST [22661] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 00:59:14.845 PST [27839] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-10 00:59:14.891 PST [27839] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 00:59:14.903 PST [27839] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 00:59:14.903 PST [27839] DETAIL:  parameters: $1 = '{23,23,1700,23,1043}'
2023-12-10 01:02:37.034 PST [36662] LOG:  checkpoint starting: time
2023-12-10 01:02:40.413 PST [36662] LOG:  checkpoint complete: wrote 34 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.343 s, sync=0.028 s, total=3.379 s; sync files=8, longest=0.010 s, average=0.004 s; distance=204 kB, estimate=2712 kB
2023-12-10 01:03:46.316 PST [28025] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:03:46.319 PST [28025] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 01:03:46.319 PST [28025] DETAIL:  parameters: $1 = '2'
2023-12-10 01:04:02.977 PST [28037] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:04:02.977 PST [28037] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 01:04:08.508 PST [28044] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:04:08.511 PST [28044] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 01:04:08.511 PST [28044] DETAIL:  parameters: $1 = '1'
2023-12-10 01:04:17.067 PST [28052] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:04:17.071 PST [28052] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:04:17.071 PST [28052] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 01:04:17.077 PST [28053] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:04:17.077 PST [28053] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 01:04:17.085 PST [28054] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:04:17.087 PST [28054] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:04:17.087 PST [28054] DETAIL:  parameters: $1 = '3', $2 = 'Extra Large BBQ Chicken & Bacon', $3 = '1', $4 = '15.99', $5 = '2'
2023-12-10 01:04:17.088 PST [28054] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:04:17.088 PST [28054] DETAIL:  parameters: $1 = '3', $2 = 'Extra Large Meat Lovers Slice', $3 = '1', $4 = '3.99', $5 = '2'
2023-12-10 01:04:17.088 PST [28054] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:04:17.103 PST [28055] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:04:17.105 PST [28055] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 01:04:17.105 PST [28055] DETAIL:  parameters: $1 = '3'
2023-12-10 01:07:02.594 PST [28127] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:07:02.596 PST [28127] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 01:07:02.596 PST [28127] DETAIL:  parameters: $1 = '3'
2023-12-10 01:07:37.420 PST [36662] LOG:  checkpoint starting: time
2023-12-10 01:07:37.539 PST [36662] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.102 s, sync=0.008 s, total=0.120 s; sync files=2, longest=0.006 s, average=0.004 s; distance=0 kB, estimate=2441 kB
2023-12-10 01:13:44.518 PST [28283] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 01:13:44.520 PST [28283] LOG:  statement: SELECT version()
2023-12-10 01:13:44.522 PST [28283] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 01:13:44.525 PST [28283] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 01:13:44.526 PST [28283] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 01:13:44.531 PST [22661] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16686;
	
2023-12-10 01:13:44.631 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'restaurants' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'restaurants' AND nsp.nspname='public'
	)::oid[])
2023-12-10 01:13:44.635 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'restaurants' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'restaurants' AND nsp.nspname='public'
	)::oid[])
2023-12-10 01:13:44.642 PST [28283] LOG:  statement: SELECT * FROM public.restaurants
	ORDER BY id ASC 
2023-12-10 01:13:44.989 PST [28283] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16686::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 01:13:45.036 PST [28283] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 01:13:45.036 PST [28283] DETAIL:  parameters: $1 = '{23,1043,1043,25}'
2023-12-10 01:13:53.976 PST [28287] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 01:13:53.985 PST [28287] LOG:  statement: SELECT version()
2023-12-10 01:13:53.987 PST [28287] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 01:13:53.989 PST [28287] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 01:13:53.992 PST [28287] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 01:13:54.004 PST [22661] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16617;
	
2023-12-10 01:13:54.091 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'address' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'address' AND nsp.nspname='public'
	)::oid[])
2023-12-10 01:13:54.093 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'address' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'address' AND nsp.nspname='public'
	)::oid[])
2023-12-10 01:13:54.099 PST [28287] LOG:  statement: SELECT * FROM public.address
	ORDER BY id ASC 
2023-12-10 01:13:54.226 PST [28287] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 01:13:54.252 PST [28287] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 01:13:54.252 PST [28287] DETAIL:  parameters: $1 = '{23,23,1043,1043}'
2023-12-10 01:17:37.551 PST [36662] LOG:  checkpoint starting: time
2023-12-10 01:17:37.689 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.120 s, sync=0.001 s, total=0.138 s; sync files=1, longest=0.001 s, average=0.001 s; distance=8 kB, estimate=2197 kB
2023-12-10 01:19:32.079 PST [28444] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:19:32.079 PST [28444] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 01:19:37.627 PST [28450] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:19:37.630 PST [28450] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 01:19:37.630 PST [28450] DETAIL:  parameters: $1 = '2'
2023-12-10 01:19:47.562 PST [28458] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:19:47.566 PST [28458] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:19:47.566 PST [28458] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 01:19:47.573 PST [28459] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:19:47.574 PST [28459] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 01:19:47.584 PST [28460] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:19:47.586 PST [28460] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:19:47.586 PST [28460] DETAIL:  parameters: $1 = '4', $2 = 'Jimmy Jam Smoothie', $3 = '1', $4 = '5.49', $5 = '2'
2023-12-10 01:19:47.587 PST [28460] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:19:47.587 PST [28460] DETAIL:  parameters: $1 = '4', $2 = 'Dayton 500 Smoothie', $3 = '3', $4 = '5.49', $5 = '2'
2023-12-10 01:19:47.587 PST [28460] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:22:18.417 PST [28540] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:22:18.420 PST [28540] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:22:18.420 PST [28540] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 01:22:18.428 PST [28541] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:22:18.428 PST [28541] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 01:22:18.437 PST [28542] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:22:18.438 PST [28542] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:22:18.438 PST [28542] DETAIL:  parameters: $1 = '5', $2 = 'Jimmy Jam Smoothie', $3 = '1', $4 = '5.49', $5 = '2'
2023-12-10 01:22:18.439 PST [28542] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:22:18.439 PST [28542] DETAIL:  parameters: $1 = '5', $2 = 'Dayton 500 Smoothie', $3 = '3', $4 = '5.49', $5 = '2'
2023-12-10 01:22:18.439 PST [28542] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:22:18.455 PST [28543] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:22:18.457 PST [28543] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-10 01:22:18.457 PST [28543] DETAIL:  parameters: $1 = '5'
2023-12-10 01:22:26.470 PST [28548] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:22:26.472 PST [28548] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-10 01:22:26.472 PST [28548] DETAIL:  parameters: $1 = '5'
2023-12-10 01:22:37.695 PST [36662] LOG:  checkpoint starting: time
2023-12-10 01:22:37.808 PST [36662] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.102 s, sync=0.006 s, total=0.113 s; sync files=2, longest=0.005 s, average=0.003 s; distance=1 kB, estimate=1978 kB
2023-12-10 01:26:50.430 PST [28664] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:26:50.432 PST [28664] LOG:  execute <unnamed>: SELECT * FROM menu_items WHERE id = $1
2023-12-10 01:26:50.432 PST [28664] DETAIL:  parameters: $1 = '5'
2023-12-10 01:34:04.040 PST [28845] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:34:04.042 PST [28845] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 01:34:04.042 PST [28845] DETAIL:  parameters: $1 = '5'
2023-12-10 01:37:41.177 PST [28938] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:37:41.180 PST [28938] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:37:41.180 PST [28938] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 01:37:41.184 PST [28939] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:37:41.187 PST [28939] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 01:37:41.187 PST [28939] DETAIL:  parameters: $1 = '2', $2 = '41 collge dr', $3 = '87632'
2023-12-10 01:37:41.195 PST [28939] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:40:31.031 PST [29046] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:40:31.033 PST [29046] LOG:  execute <unnamed>: INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-10 01:40:31.033 PST [29046] DETAIL:  parameters: $1 = 'sanu', $2 = 'sanu@gmail.com', $3 = 'minusanu', $4 = '1236547890'
2023-12-10 01:40:31.035 PST [29046] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:40:31.053 PST [29047] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:40:31.053 PST [29047] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 01:40:39.015 PST [29056] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:40:39.018 PST [29056] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 01:40:39.018 PST [29056] DETAIL:  parameters: $1 = '3'
2023-12-10 01:40:57.834 PST [29066] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:40:57.837 PST [29066] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:40:57.837 PST [29066] DETAIL:  parameters: $1 = 'sanu'
2023-12-10 01:40:57.843 PST [29067] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:40:57.843 PST [29067] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 01:40:57.853 PST [29068] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:40:57.855 PST [29068] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:40:57.855 PST [29068] DETAIL:  parameters: $1 = '6', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '3'
2023-12-10 01:40:57.855 PST [29068] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:40:57.855 PST [29068] DETAIL:  parameters: $1 = '6', $2 = 'French Fries', $3 = '3', $4 = '4.78', $5 = '3'
2023-12-10 01:40:57.856 PST [29068] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:40:57.871 PST [29069] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:40:57.872 PST [29069] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 01:40:57.872 PST [29069] DETAIL:  parameters: $1 = '6'
2023-12-10 01:41:20.165 PST [29086] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:41:20.167 PST [29086] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:41:20.167 PST [29086] DETAIL:  parameters: $1 = 'sanu'
2023-12-10 01:41:20.175 PST [29087] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:41:20.176 PST [29087] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 01:41:20.176 PST [29087] DETAIL:  parameters: $1 = '3', $2 = '123 street apple road', $3 = '123456'
2023-12-10 01:41:20.178 PST [29087] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:42:31.693 PST [29129] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:42:31.694 PST [29129] LOG:  execute <unnamed>: INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-10 01:42:31.694 PST [29129] DETAIL:  parameters: $1 = 'syed', $2 = 'syednishad111@gmail.com', $3 = '220234', $4 = '9257919627'
2023-12-10 01:42:31.695 PST [29129] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:42:31.710 PST [29130] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:42:31.710 PST [29130] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 01:42:37.831 PST [36662] LOG:  checkpoint starting: time
2023-12-10 01:42:38.677 PST [36662] LOG:  checkpoint complete: wrote 9 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.825 s, sync=0.010 s, total=0.846 s; sync files=8, longest=0.006 s, average=0.002 s; distance=3 kB, estimate=1780 kB
2023-12-10 01:43:10.013 PST [29153] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:43:10.015 PST [29153] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 01:43:10.015 PST [29153] DETAIL:  parameters: $1 = '232'
2023-12-10 01:43:35.808 PST [29168] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:43:35.808 PST [29168] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 01:43:43.269 PST [29174] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:43:43.272 PST [29174] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 01:43:43.272 PST [29174] DETAIL:  parameters: $1 = '2'
2023-12-10 01:43:58.689 PST [29185] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:43:58.692 PST [29185] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:43:58.692 PST [29185] DETAIL:  parameters: $1 = 'syed'
2023-12-10 01:43:58.698 PST [29186] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:43:58.698 PST [29186] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 01:43:58.707 PST [29187] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:43:58.709 PST [29187] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 01:43:58.709 PST [29187] DETAIL:  parameters: $1 = '7', $2 = 'K Blend Smoothie', $3 = '4', $4 = '8.49', $5 = '4'
2023-12-10 01:43:58.709 PST [29187] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:43:58.725 PST [29188] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:43:58.727 PST [29188] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 01:43:58.727 PST [29188] DETAIL:  parameters: $1 = '7'
2023-12-10 01:44:25.645 PST [29205] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:44:25.647 PST [29205] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 01:44:25.647 PST [29205] DETAIL:  parameters: $1 = 'syed'
2023-12-10 01:44:25.655 PST [29206] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:44:25.656 PST [29206] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 01:44:25.656 PST [29206] DETAIL:  parameters: $1 = '4', $2 = '76543', $3 = '677899'
2023-12-10 01:44:25.660 PST [29206] LOG:  execute <unnamed>: COMMIT
2023-12-10 01:44:42.311 PST [29224] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:44:42.313 PST [29224] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 01:44:42.313 PST [29224] DETAIL:  parameters: $1 = '2'
2023-12-10 01:44:42.489 PST [29225] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:44:42.489 PST [29225] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 01:44:46.962 PST [29233] LOG:  execute <unnamed>: BEGIN
2023-12-10 01:44:46.964 PST [29233] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 01:44:46.964 PST [29233] DETAIL:  parameters: $1 = '3'
2023-12-10 01:47:37.683 PST [36662] LOG:  checkpoint starting: time
2023-12-10 01:47:38.208 PST [36662] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.511 s, sync=0.005 s, total=0.525 s; sync files=6, longest=0.003 s, average=0.001 s; distance=2 kB, estimate=1602 kB
2023-12-10 02:19:44.358 PST [30066] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 02:19:47.241 PST [30072] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 02:19:47.269 PST [30073] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 02:19:47.456 PST [30075] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 02:19:47.545 PST [30076] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 02:20:10.129 PST [30086] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 02:27:02.751 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'address' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'address' AND nsp.nspname='public'
	)::oid[])
2023-12-10 02:27:02.783 PST [22661] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'address' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'address' AND nsp.nspname='public'
	)::oid[])
2023-12-10 02:27:02.795 PST [28287] LOG:  statement: SELECT * FROM public.address
	ORDER BY id ASC 
2023-12-10 02:27:02.848 PST [28287] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16617::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 02:27:02.859 PST [28287] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 02:27:02.859 PST [28287] DETAIL:  parameters: $1 = '{23,23,1043,1043}'
2023-12-10 02:28:57.662 PST [36662] LOG:  checkpoint starting: time
2023-12-10 02:28:57.789 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.115 s, sync=0.001 s, total=0.127 s; sync files=1, longest=0.001 s, average=0.001 s; distance=0 kB, estimate=1442 kB
2023-12-10 05:00:32.927 PST [30691] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 05:00:32.974 PST [30691] LOG:  statement: SELECT version()
2023-12-10 05:00:32.975 PST [30691] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 05:00:32.995 PST [30691] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 05:00:33.100 PST [30691] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 05:00:33.547 PST [30693] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 05:00:33.559 PST [30693] LOG:  statement: SELECT version()
2023-12-10 05:00:33.560 PST [30693] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 05:00:33.573 PST [30693] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 05:00:33.579 PST [30693] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 05:00:33.662 PST [30694] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 05:00:33.672 PST [30694] LOG:  statement: SELECT version()
2023-12-10 05:00:33.674 PST [30694] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 05:00:33.678 PST [30694] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 05:00:33.682 PST [30694] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 10:51:03.226 PST [30724] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 10:51:03.242 PST [30724] LOG:  statement: SELECT version()
2023-12-10 10:51:03.245 PST [30724] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 10:51:03.250 PST [30724] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 10:51:03.253 PST [30724] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 10:51:03.284 PST [30727] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 10:51:03.289 PST [30727] LOG:  statement: SELECT version()
2023-12-10 10:51:03.289 PST [30727] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 10:51:03.291 PST [30727] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 10:51:03.292 PST [30727] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 10:51:03.314 PST [30728] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 10:51:03.318 PST [30728] LOG:  statement: SELECT version()
2023-12-10 10:51:03.319 PST [30728] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 10:51:03.321 PST [30728] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 10:51:03.322 PST [30728] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 11:46:58.591 PST [31606] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:46:58.599 PST [31606] LOG:  execute <unnamed>: INSERT INTO users (username, email, password, phone) VALUES ($1, $2, $3, $4)
2023-12-10 11:46:58.599 PST [31606] DETAIL:  parameters: $1 = 'syed', $2 = 'syed2@gmail.com', $3 = '123456', $4 = '9257919627'
2023-12-10 11:46:58.605 PST [31606] LOG:  execute <unnamed>: COMMIT
2023-12-10 11:46:58.621 PST [31607] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:46:58.621 PST [31607] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 11:47:11.230 PST [31617] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:47:11.242 PST [31617] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 11:47:11.242 PST [31617] DETAIL:  parameters: $1 = '14'
2023-12-10 11:47:29.778 PST [31635] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:47:29.783 PST [31635] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 11:47:29.783 PST [31635] DETAIL:  parameters: $1 = 'syed'
2023-12-10 11:47:29.790 PST [31636] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:47:29.790 PST [31636] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 11:47:29.800 PST [31637] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:47:29.803 PST [31637] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:47:29.803 PST [31637] DETAIL:  parameters: $1 = '8', $2 = 'Napa Almond Chicken Salad Sandwich', $3 = '1', $4 = '7.19', $5 = '4'
2023-12-10 11:47:29.804 PST [31637] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:47:29.804 PST [31637] DETAIL:  parameters: $1 = '8', $2 = 'Tuna Salad Sandwich', $3 = '1', $4 = '7.19', $5 = '4'
2023-12-10 11:47:29.804 PST [31637] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:47:29.804 PST [31637] DETAIL:  parameters: $1 = '8', $2 = 'Grilled Mac & Cheese Sandwich', $3 = '1', $4 = '8.79', $5 = '4'
2023-12-10 11:47:29.805 PST [31637] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:47:29.805 PST [31637] DETAIL:  parameters: $1 = '8', $2 = 'Smokehouse BBQ Chicken Sandwich', $3 = '1', $4 = '7.19', $5 = '4'
2023-12-10 11:47:29.805 PST [31637] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:47:29.805 PST [31637] DETAIL:  parameters: $1 = '8', $2 = 'Bacon Turkey Bravo Sandwich', $3 = '1', $4 = '8.79', $5 = '4'
2023-12-10 11:47:29.806 PST [31637] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:47:29.806 PST [31637] DETAIL:  parameters: $1 = '8', $2 = 'Chipotle Chicken Avocado Melt', $3 = '1', $4 = '8.79', $5 = '4'
2023-12-10 11:47:29.807 PST [31637] LOG:  execute <unnamed>: COMMIT
2023-12-10 11:47:29.823 PST [31638] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:47:29.824 PST [31638] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 11:47:29.824 PST [31638] DETAIL:  parameters: $1 = '8'
2023-12-10 11:47:39.449 PST [31647] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:47:39.452 PST [31647] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 11:47:39.452 PST [31647] DETAIL:  parameters: $1 = 'syed'
2023-12-10 11:47:39.459 PST [31648] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:47:39.461 PST [31648] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 11:47:39.461 PST [31648] DETAIL:  parameters: $1 = '4', $2 = '6748839', $3 = '89503'
2023-12-10 11:47:39.468 PST [31648] LOG:  execute <unnamed>: COMMIT
2023-12-10 11:48:05.752 PST [31666] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:05.752 PST [31666] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 11:48:12.096 PST [31675] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:12.097 PST [31675] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 11:48:12.097 PST [31675] DETAIL:  parameters: $1 = '4'
2023-12-10 11:48:40.440 PST [31688] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:40.443 PST [31688] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 11:48:40.443 PST [31688] DETAIL:  parameters: $1 = 'syed'
2023-12-10 11:48:40.450 PST [31689] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:40.450 PST [31689] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 11:48:40.458 PST [31690] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:40.459 PST [31690] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.459 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Create Your Own Crustless - Keto Friendly (Baking Required)', $3 = '1', $4 = '9', $5 = '4'
2023-12-10 11:48:40.460 PST [31690] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.460 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Gourmet Vegetarian - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.460 PST [31690] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.460 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Gourmet Vegetarian - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.461 PST [31690] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.461 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.461 PST [31690] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.461 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.461 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.461 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.461 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.461 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.462 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.462 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.462 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.462 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.462 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.462 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.463 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.463 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.463 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.463 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.463 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.463 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.464 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.464 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.464 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.464 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.466 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.466 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.469 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.469 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.473 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.473 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.477 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.477 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.479 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.479 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.479 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.479 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.480 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.480 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.480 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.480 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.481 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.481 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Chicken Bacon Artichoke - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.481 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.481 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Cowboy - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.482 PST [31690] LOG:  execute _pg3_0: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 11:48:40.482 PST [31690] DETAIL:  parameters: $1 = '9', $2 = 'Gourmet Vegetarian - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '4'
2023-12-10 11:48:40.483 PST [31690] LOG:  execute <unnamed>: COMMIT
2023-12-10 11:48:40.504 PST [31691] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:40.506 PST [31691] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 11:48:40.506 PST [31691] DETAIL:  parameters: $1 = '9'
2023-12-10 11:48:59.210 PST [31706] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:59.212 PST [31706] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 11:48:59.212 PST [31706] DETAIL:  parameters: $1 = 'syed'
2023-12-10 11:48:59.219 PST [31707] LOG:  execute <unnamed>: BEGIN
2023-12-10 11:48:59.220 PST [31707] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 11:48:59.220 PST [31707] DETAIL:  parameters: $1 = '4', $2 = '6377', $3 = '89503'
2023-12-10 11:48:59.223 PST [31707] LOG:  execute <unnamed>: COMMIT
2023-12-10 11:49:55.459 PST [36662] LOG:  checkpoint starting: time
2023-12-10 11:49:56.213 PST [36662] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.731 s, sync=0.004 s, total=0.754 s; sync files=8, longest=0.003 s, average=0.001 s; distance=7 kB, estimate=1299 kB
2023-12-10 12:22:30.982 PST [32585] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:22:30.986 PST [32585] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 12:22:30.986 PST [32585] DETAIL:  parameters: $1 = NULL
2023-12-10 12:24:43.456 PST [32679] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:24:43.457 PST [32679] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 12:25:44.752 PST [32724] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:25:44.754 PST [32724] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 12:25:44.754 PST [32724] DETAIL:  parameters: $1 = '3'
2023-12-10 12:25:51.686 PST [32729] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:25:51.699 PST [32729] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 12:25:51.699 PST [32729] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 12:25:51.707 PST [32730] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:25:51.707 PST [32730] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 12:25:51.717 PST [32731] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:25:51.718 PST [32731] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 12:25:51.718 PST [32731] DETAIL:  parameters: $1 = '10', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '1', $4 = '10.78', $5 = '2'
2023-12-10 12:25:51.720 PST [32731] LOG:  execute <unnamed>: COMMIT
2023-12-10 12:25:51.735 PST [32732] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:25:51.736 PST [32732] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 12:25:51.736 PST [32732] DETAIL:  parameters: $1 = '10'
2023-12-10 12:26:05.598 PST [32743] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:05.601 PST [32743] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 12:26:05.601 PST [32743] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 12:26:05.607 PST [32744] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:05.608 PST [32744] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 12:26:05.608 PST [32744] DETAIL:  parameters: $1 = '2', $2 = 'mqwnd', $3 = '12345'
2023-12-10 12:26:05.612 PST [32744] LOG:  execute <unnamed>: COMMIT
2023-12-10 12:26:07.588 PST [32747] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:07.589 PST [32747] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 12:26:20.322 PST [32755] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:20.324 PST [32755] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 12:26:20.324 PST [32755] DETAIL:  parameters: $1 = '4'
2023-12-10 12:26:24.752 PST [32759] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:24.754 PST [32759] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 12:26:24.754 PST [32759] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 12:26:24.760 PST [32760] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:24.761 PST [32760] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 12:26:24.767 PST [32761] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:24.769 PST [32761] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 12:26:24.769 PST [32761] DETAIL:  parameters: $1 = '11', $2 = 'Create Your Own Crustless - Keto Friendly (Baking Required)', $3 = '1', $4 = '9', $5 = '2'
2023-12-10 12:26:24.769 PST [32761] LOG:  execute <unnamed>: COMMIT
2023-12-10 12:26:24.792 PST [32763] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:24.794 PST [32763] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 12:26:24.794 PST [32763] DETAIL:  parameters: $1 = '11'
2023-12-10 12:26:33.828 PST [32773] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:33.840 PST [32773] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 12:26:33.840 PST [32773] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 12:26:33.869 PST [32774] LOG:  execute <unnamed>: BEGIN
2023-12-10 12:26:33.874 PST [32774] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 12:26:33.874 PST [32774] DETAIL:  parameters: $1 = '2', $2 = 'qqqqw', $3 = '123445'
2023-12-10 12:26:33.876 PST [32774] LOG:  execute <unnamed>: COMMIT
2023-12-10 12:29:56.031 PST [36662] LOG:  checkpoint starting: time
2023-12-10 12:29:56.576 PST [36662] LOG:  checkpoint complete: wrote 6 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.524 s, sync=0.010 s, total=0.546 s; sync files=6, longest=0.006 s, average=0.002 s; distance=6 kB, estimate=1169 kB
2023-12-10 12:32:40.044 PST [32960] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:32:40.044 PST [32960] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 12:32:40.046 PST [32960] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:32:40.046 PST [32960] LOG:  statement: SET DATESTYLE = ISO
2023-12-10 12:32:40.046 PST [32960] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2023-12-10 12:32:40.047 PST [32960] LOG:  statement: SET extra_float_digits TO 3
2023-12-10 12:32:40.047 PST [32960] LOG:  statement: SET synchronize_seqscans TO off
2023-12-10 12:32:40.047 PST [32960] LOG:  statement: SET statement_timeout = 0
2023-12-10 12:32:40.047 PST [32960] LOG:  statement: SET lock_timeout = 0
2023-12-10 12:32:40.047 PST [32960] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2023-12-10 12:32:40.047 PST [32960] LOG:  statement: SET row_security = off
2023-12-10 12:32:40.047 PST [32960] LOG:  statement: BEGIN
2023-12-10 12:32:40.048 PST [32960] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2023-12-10 12:32:40.048 PST [32960] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2023-12-10 12:32:40.053 PST [32960] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2023-12-10 12:32:40.071 PST [32960] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2023-12-10 12:32:40.085 PST [32960] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2023-12-10 12:32:40.088 PST [32960] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2023-12-10 12:32:40.135 PST [32960] LOG:  statement: LOCK TABLE public.address IN ACCESS SHARE MODE
2023-12-10 12:32:40.136 PST [32960] LOG:  statement: LOCK TABLE public.users IN ACCESS SHARE MODE
2023-12-10 12:32:40.136 PST [32960] LOG:  statement: LOCK TABLE public.ratings IN ACCESS SHARE MODE
2023-12-10 12:32:40.136 PST [32960] LOG:  statement: LOCK TABLE public.menus IN ACCESS SHARE MODE
2023-12-10 12:32:40.136 PST [32960] LOG:  statement: LOCK TABLE public.restaurants IN ACCESS SHARE MODE
2023-12-10 12:32:40.137 PST [32960] LOG:  statement: LOCK TABLE public.orders IN ACCESS SHARE MODE
2023-12-10 12:32:40.137 PST [32960] LOG:  statement: LOCK TABLE public.menu_items IN ACCESS SHARE MODE
2023-12-10 12:32:40.138 PST [32960] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:32:40.273 PST [32960] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2023-12-10 12:32:40.299 PST [32960] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2023-12-10 12:32:40.305 PST [32960] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:32:40.306 PST [32960] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2023-12-10 12:32:40.319 PST [32960] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2023-12-10 12:32:40.320 PST [32960] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2023-12-10 12:32:40.327 PST [32960] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2023-12-10 12:32:40.334 PST [32960] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2023-12-10 12:32:40.340 PST [32960] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2023-12-10 12:32:40.346 PST [32960] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2023-12-10 12:32:40.353 PST [32960] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2023-12-10 12:32:40.361 PST [32960] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2023-12-10 12:32:40.367 PST [32960] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2023-12-10 12:32:40.373 PST [32960] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2023-12-10 12:32:40.379 PST [32960] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2023-12-10 12:32:40.394 PST [32960] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2023-12-10 12:32:40.403 PST [32960] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2023-12-10 12:32:40.411 PST [32960] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2023-12-10 12:32:40.411 PST [32960] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2023-12-10 12:32:40.416 PST [32960] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2023-12-10 12:32:40.420 PST [32960] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2023-12-10 12:32:40.432 PST [32960] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.atttypmod,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2023-12-10 12:32:40.442 PST [32960] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16617,16653,16667,16674,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2023-12-10 12:32:40.449 PST [32960] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2023-12-10 12:32:40.459 PST [32960] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxstattarget FROM pg_catalog.pg_statistic_ext
2023-12-10 12:32:40.463 PST [32960] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2023-12-10 12:32:40.464 PST [32960] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2023-12-10 12:32:40.470 PST [32960] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2023-12-10 12:32:40.488 PST [32960] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2023-12-10 12:32:40.493 PST [32960] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2023-12-10 12:32:40.496 PST [32960] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2023-12-10 12:32:40.501 PST [32960] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2023-12-10 12:32:40.504 PST [32960] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2023-12-10 12:32:40.508 PST [32960] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2023-12-10 12:32:40.531 PST [32960] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2023-12-10 12:32:40.536 PST [32960] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2023-12-10 12:32:40.537 PST [32960] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2023-12-10 12:32:40.579 PST [32960] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2023-12-10 12:32:40.584 PST [32960] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2023-12-10 12:32:40.585 PST [32960] LOG:  statement: SELECT tableoid, oid, datname, datdba, pg_encoding_to_char(encoding) AS encoding, datcollate, datctype, datfrozenxid, datacl, acldefault('d', datdba) AS acldefault, datistemplate, datconnlimit, datminmxid, datlocprovider, daticulocale, datcollversion, (SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, shobj_description(oid, 'pg_database') AS description FROM pg_database WHERE datname = current_database()
2023-12-10 12:32:40.590 PST [32960] LOG:  statement: SELECT provider, label FROM pg_catalog.pg_shseclabel WHERE classoid = 'pg_catalog.pg_database'::pg_catalog.regclass AND objoid = '16464'
2023-12-10 12:32:40.593 PST [32960] LOG:  statement: SELECT unnest(setconfig) FROM pg_db_role_setting WHERE setrole = 0 AND setdatabase = '16464'::oid
2023-12-10 12:32:40.593 PST [32960] LOG:  statement: SELECT rolname, unnest(setconfig) FROM pg_db_role_setting s, pg_roles r WHERE setrole = r.oid AND setdatabase = '16464'::oid
2023-12-10 12:32:40.594 PST [32960] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2023-12-10 12:32:40.595 PST [32960] LOG:  statement: EXECUTE getColumnACLs('6100')
2023-12-10 12:32:40.595 PST [32960] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2023-12-10 12:32:40.595 PST [32960] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16616'::oid
2023-12-10 12:32:40.598 PST [32960] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16673'::oid
2023-12-10 12:32:40.598 PST [32960] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16693'::oid
2023-12-10 12:32:40.599 PST [32960] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16666'::oid
2023-12-10 12:32:40.599 PST [32960] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16652'::oid
2023-12-10 12:33:42.725 PST [33003] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:33:42.725 PST [33003] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 12:33:42.725 PST [33003] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET DATESTYLE = ISO
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET extra_float_digits TO 3
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET synchronize_seqscans TO off
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET statement_timeout = 0
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET lock_timeout = 0
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET row_security = off
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: BEGIN
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2023-12-10 12:33:42.726 PST [33003] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2023-12-10 12:33:42.728 PST [33003] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2023-12-10 12:33:42.730 PST [33003] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2023-12-10 12:33:42.731 PST [33003] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2023-12-10 12:33:42.731 PST [33003] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2023-12-10 12:33:42.736 PST [33003] LOG:  statement: LOCK TABLE public.address IN ACCESS SHARE MODE
2023-12-10 12:33:42.736 PST [33003] LOG:  statement: LOCK TABLE public.users IN ACCESS SHARE MODE
2023-12-10 12:33:42.736 PST [33003] LOG:  statement: LOCK TABLE public.ratings IN ACCESS SHARE MODE
2023-12-10 12:33:42.737 PST [33003] LOG:  statement: LOCK TABLE public.menus IN ACCESS SHARE MODE
2023-12-10 12:33:42.737 PST [33003] LOG:  statement: LOCK TABLE public.restaurants IN ACCESS SHARE MODE
2023-12-10 12:33:42.737 PST [33003] LOG:  statement: LOCK TABLE public.orders IN ACCESS SHARE MODE
2023-12-10 12:33:42.737 PST [33003] LOG:  statement: LOCK TABLE public.menu_items IN ACCESS SHARE MODE
2023-12-10 12:33:42.737 PST [33003] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:33:42.744 PST [33003] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2023-12-10 12:33:42.747 PST [33003] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2023-12-10 12:33:42.748 PST [33003] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:33:42.749 PST [33003] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2023-12-10 12:33:42.750 PST [33003] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2023-12-10 12:33:42.751 PST [33003] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2023-12-10 12:33:42.751 PST [33003] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2023-12-10 12:33:42.752 PST [33003] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2023-12-10 12:33:42.752 PST [33003] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2023-12-10 12:33:42.753 PST [33003] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2023-12-10 12:33:42.753 PST [33003] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2023-12-10 12:33:42.754 PST [33003] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2023-12-10 12:33:42.754 PST [33003] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2023-12-10 12:33:42.755 PST [33003] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2023-12-10 12:33:42.755 PST [33003] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2023-12-10 12:33:42.757 PST [33003] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2023-12-10 12:33:42.757 PST [33003] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2023-12-10 12:33:42.758 PST [33003] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2023-12-10 12:33:42.758 PST [33003] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2023-12-10 12:33:42.759 PST [33003] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2023-12-10 12:33:42.759 PST [33003] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2023-12-10 12:33:42.760 PST [33003] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.atttypmod,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2023-12-10 12:33:42.761 PST [33003] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2023-12-10 12:33:42.765 PST [33003] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2023-12-10 12:33:42.768 PST [33003] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxstattarget FROM pg_catalog.pg_statistic_ext
2023-12-10 12:33:42.768 PST [33003] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2023-12-10 12:33:42.769 PST [33003] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2023-12-10 12:33:42.770 PST [33003] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2023-12-10 12:33:42.771 PST [33003] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2023-12-10 12:33:42.771 PST [33003] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2023-12-10 12:33:42.772 PST [33003] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2023-12-10 12:33:42.773 PST [33003] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2023-12-10 12:33:42.773 PST [33003] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2023-12-10 12:33:42.774 PST [33003] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2023-12-10 12:33:42.778 PST [33003] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2023-12-10 12:33:42.783 PST [33003] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2023-12-10 12:33:42.789 PST [33003] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2023-12-10 12:33:42.790 PST [33003] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2023-12-10 12:33:42.791 PST [33003] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2023-12-10 12:33:42.806 PST [33003] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2023-12-10 12:33:42.811 PST [33003] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2023-12-10 12:33:42.811 PST [33003] LOG:  statement: SELECT tableoid, oid, datname, datdba, pg_encoding_to_char(encoding) AS encoding, datcollate, datctype, datfrozenxid, datacl, acldefault('d', datdba) AS acldefault, datistemplate, datconnlimit, datminmxid, datlocprovider, daticulocale, datcollversion, (SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, shobj_description(oid, 'pg_database') AS description FROM pg_database WHERE datname = current_database()
2023-12-10 12:33:42.812 PST [33003] LOG:  statement: SELECT provider, label FROM pg_catalog.pg_shseclabel WHERE classoid = 'pg_catalog.pg_database'::pg_catalog.regclass AND objoid = '16464'
2023-12-10 12:33:42.813 PST [33003] LOG:  statement: SELECT unnest(setconfig) FROM pg_db_role_setting WHERE setrole = 0 AND setdatabase = '16464'::oid
2023-12-10 12:33:42.813 PST [33003] LOG:  statement: SELECT rolname, unnest(setconfig) FROM pg_db_role_setting s, pg_roles r WHERE setrole = r.oid AND setdatabase = '16464'::oid
2023-12-10 12:33:42.814 PST [33003] LOG:  statement: SELECT last_value, is_called FROM public.address_id_seq
2023-12-10 12:33:42.823 PST [33003] LOG:  statement: SELECT last_value, is_called FROM public.menus_id_seq
2023-12-10 12:33:42.826 PST [33003] LOG:  statement: SELECT last_value, is_called FROM public.orders_id_seq
2023-12-10 12:33:42.828 PST [33003] LOG:  statement: SELECT last_value, is_called FROM public.ratings_id_seq
2023-12-10 12:33:42.831 PST [33003] LOG:  statement: SELECT last_value, is_called FROM public.users_user_id_seq
2023-12-10 12:33:42.833 PST [33003] LOG:  statement: COPY public.users (user_id, username, email, password, phone) TO stdout;
2023-12-10 12:33:42.835 PST [33003] LOG:  statement: COPY public.address (id, user_id, street, pincode) TO stdout;
2023-12-10 12:33:42.836 PST [33003] LOG:  statement: COPY public.menu_items (id, qty, price, user_id, item_name) TO stdout;
2023-12-10 12:33:42.837 PST [33003] LOG:  statement: COPY public.restaurants (id, name, address, category) TO stdout;
2023-12-10 12:33:43.004 PST [33003] LOG:  statement: COPY public.menus (id, restaurant_id, category, name, description, price) TO stdout;
2023-12-10 12:33:43.028 PST [33003] LOG:  statement: COPY public.orders (id, user_id, restaurant_id, order_total) TO stdout;
2023-12-10 12:33:43.030 PST [33003] LOG:  statement: COPY public.ratings (id, restaurant_id, ratings, score) TO stdout;
2023-12-10 12:34:56.578 PST [36662] LOG:  checkpoint starting: time
2023-12-10 12:34:56.899 PST [36662] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.303 s, sync=0.006 s, total=0.321 s; sync files=3, longest=0.006 s, average=0.002 s; distance=6 kB, estimate=1053 kB
2023-12-10 12:39:29.201 PST [33192] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:39:29.202 PST [33192] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 12:39:29.202 PST [33192] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:39:29.202 PST [33192] LOG:  statement: SET DATESTYLE = ISO
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET extra_float_digits TO 3
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET synchronize_seqscans TO off
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET statement_timeout = 0
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET lock_timeout = 0
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET row_security = off
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: BEGIN
2023-12-10 12:39:29.203 PST [33192] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2023-12-10 12:39:29.204 PST [33192] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2023-12-10 12:39:29.206 PST [33192] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2023-12-10 12:39:29.208 PST [33192] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2023-12-10 12:39:29.209 PST [33192] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2023-12-10 12:39:29.211 PST [33192] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2023-12-10 12:39:29.218 PST [33192] LOG:  statement: LOCK TABLE public.address IN ACCESS SHARE MODE
2023-12-10 12:39:29.218 PST [33192] LOG:  statement: LOCK TABLE public.users IN ACCESS SHARE MODE
2023-12-10 12:39:29.218 PST [33192] LOG:  statement: LOCK TABLE public.ratings IN ACCESS SHARE MODE
2023-12-10 12:39:29.218 PST [33192] LOG:  statement: LOCK TABLE public.menus IN ACCESS SHARE MODE
2023-12-10 12:39:29.218 PST [33192] LOG:  statement: LOCK TABLE public.restaurants IN ACCESS SHARE MODE
2023-12-10 12:39:29.218 PST [33192] LOG:  statement: LOCK TABLE public.orders IN ACCESS SHARE MODE
2023-12-10 12:39:29.218 PST [33192] LOG:  statement: LOCK TABLE public.menu_items IN ACCESS SHARE MODE
2023-12-10 12:39:29.219 PST [33192] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:39:29.227 PST [33192] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2023-12-10 12:39:29.231 PST [33192] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2023-12-10 12:39:29.231 PST [33192] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:39:29.232 PST [33192] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2023-12-10 12:39:29.234 PST [33192] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2023-12-10 12:39:29.234 PST [33192] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2023-12-10 12:39:29.235 PST [33192] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2023-12-10 12:39:29.235 PST [33192] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2023-12-10 12:39:29.236 PST [33192] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2023-12-10 12:39:29.236 PST [33192] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2023-12-10 12:39:29.237 PST [33192] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2023-12-10 12:39:29.237 PST [33192] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2023-12-10 12:39:29.238 PST [33192] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2023-12-10 12:39:29.238 PST [33192] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2023-12-10 12:39:29.239 PST [33192] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2023-12-10 12:39:29.240 PST [33192] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2023-12-10 12:39:29.241 PST [33192] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2023-12-10 12:39:29.242 PST [33192] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2023-12-10 12:39:29.243 PST [33192] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2023-12-10 12:39:29.243 PST [33192] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2023-12-10 12:39:29.244 PST [33192] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2023-12-10 12:39:29.245 PST [33192] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.atttypmod,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2023-12-10 12:39:29.247 PST [33192] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2023-12-10 12:39:29.247 PST [33192] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2023-12-10 12:39:29.251 PST [33192] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxstattarget FROM pg_catalog.pg_statistic_ext
2023-12-10 12:39:29.251 PST [33192] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2023-12-10 12:39:29.252 PST [33192] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2023-12-10 12:39:29.254 PST [33192] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2023-12-10 12:39:29.255 PST [33192] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2023-12-10 12:39:29.256 PST [33192] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2023-12-10 12:39:29.257 PST [33192] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2023-12-10 12:39:29.258 PST [33192] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2023-12-10 12:39:29.258 PST [33192] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2023-12-10 12:39:29.260 PST [33192] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2023-12-10 12:39:29.261 PST [33192] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2023-12-10 12:39:29.262 PST [33192] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2023-12-10 12:39:29.266 PST [33192] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2023-12-10 12:39:29.267 PST [33192] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2023-12-10 12:39:29.267 PST [33192] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2023-12-10 12:39:29.280 PST [33192] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2023-12-10 12:39:29.284 PST [33192] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2023-12-10 12:39:29.284 PST [33192] LOG:  statement: SELECT last_value, is_called FROM public.address_id_seq
2023-12-10 12:39:29.285 PST [33192] LOG:  statement: SELECT last_value, is_called FROM public.menus_id_seq
2023-12-10 12:39:29.285 PST [33192] LOG:  statement: SELECT last_value, is_called FROM public.orders_id_seq
2023-12-10 12:39:29.286 PST [33192] LOG:  statement: SELECT last_value, is_called FROM public.ratings_id_seq
2023-12-10 12:39:29.287 PST [33192] LOG:  statement: SELECT last_value, is_called FROM public.users_user_id_seq
2023-12-10 12:39:29.288 PST [33192] LOG:  statement: COPY public.users (user_id, username, email, password, phone) TO stdout;
2023-12-10 12:39:29.288 PST [33192] LOG:  statement: COPY public.address (id, user_id, street, pincode) TO stdout;
2023-12-10 12:39:29.290 PST [33192] LOG:  statement: COPY public.menu_items (id, qty, price, user_id, item_name) TO stdout;
2023-12-10 12:39:29.291 PST [33192] LOG:  statement: COPY public.restaurants (id, name, address, category) TO stdout;
2023-12-10 12:39:29.356 PST [33192] LOG:  statement: COPY public.menus (id, restaurant_id, category, name, description, price) TO stdout;
2023-12-10 12:39:29.363 PST [33192] LOG:  statement: COPY public.orders (id, user_id, restaurant_id, order_total) TO stdout;
2023-12-10 12:39:29.363 PST [33192] LOG:  statement: COPY public.ratings (id, restaurant_id, ratings, score) TO stdout;
2023-12-10 12:41:02.227 PST [33237] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:41:02.228 PST [33237] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 12:41:02.228 PST [33237] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:41:02.228 PST [33237] LOG:  statement: SET DATESTYLE = ISO
2023-12-10 12:41:02.228 PST [33237] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2023-12-10 12:41:02.228 PST [33237] LOG:  statement: SET extra_float_digits TO 3
2023-12-10 12:41:02.228 PST [33237] LOG:  statement: SET synchronize_seqscans TO off
2023-12-10 12:41:02.228 PST [33237] LOG:  statement: SET statement_timeout = 0
2023-12-10 12:41:02.229 PST [33237] LOG:  statement: SET lock_timeout = 0
2023-12-10 12:41:02.229 PST [33237] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2023-12-10 12:41:02.229 PST [33237] LOG:  statement: SET row_security = off
2023-12-10 12:41:02.229 PST [33237] LOG:  statement: BEGIN
2023-12-10 12:41:02.229 PST [33237] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2023-12-10 12:41:02.229 PST [33237] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2023-12-10 12:41:02.231 PST [33237] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2023-12-10 12:41:02.233 PST [33237] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2023-12-10 12:41:02.234 PST [33237] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2023-12-10 12:41:02.234 PST [33237] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2023-12-10 12:41:02.239 PST [33237] LOG:  statement: LOCK TABLE public.address IN ACCESS SHARE MODE
2023-12-10 12:41:02.239 PST [33237] LOG:  statement: LOCK TABLE public.users IN ACCESS SHARE MODE
2023-12-10 12:41:02.239 PST [33237] LOG:  statement: LOCK TABLE public.ratings IN ACCESS SHARE MODE
2023-12-10 12:41:02.240 PST [33237] LOG:  statement: LOCK TABLE public.menus IN ACCESS SHARE MODE
2023-12-10 12:41:02.240 PST [33237] LOG:  statement: LOCK TABLE public.restaurants IN ACCESS SHARE MODE
2023-12-10 12:41:02.240 PST [33237] LOG:  statement: LOCK TABLE public.orders IN ACCESS SHARE MODE
2023-12-10 12:41:02.240 PST [33237] LOG:  statement: LOCK TABLE public.menu_items IN ACCESS SHARE MODE
2023-12-10 12:41:02.241 PST [33237] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:41:02.249 PST [33237] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2023-12-10 12:41:02.253 PST [33237] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2023-12-10 12:41:02.253 PST [33237] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:41:02.254 PST [33237] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2023-12-10 12:41:02.255 PST [33237] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2023-12-10 12:41:02.256 PST [33237] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2023-12-10 12:41:02.256 PST [33237] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2023-12-10 12:41:02.257 PST [33237] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2023-12-10 12:41:02.258 PST [33237] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2023-12-10 12:41:02.258 PST [33237] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2023-12-10 12:41:02.258 PST [33237] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2023-12-10 12:41:02.259 PST [33237] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2023-12-10 12:41:02.260 PST [33237] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2023-12-10 12:41:02.260 PST [33237] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2023-12-10 12:41:02.261 PST [33237] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2023-12-10 12:41:02.262 PST [33237] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2023-12-10 12:41:02.263 PST [33237] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2023-12-10 12:41:02.264 PST [33237] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2023-12-10 12:41:02.264 PST [33237] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2023-12-10 12:41:02.265 PST [33237] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2023-12-10 12:41:02.265 PST [33237] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2023-12-10 12:41:02.266 PST [33237] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.atttypmod,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2023-12-10 12:41:02.267 PST [33237] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2023-12-10 12:41:02.268 PST [33237] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2023-12-10 12:41:02.270 PST [33237] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxstattarget FROM pg_catalog.pg_statistic_ext
2023-12-10 12:41:02.271 PST [33237] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2023-12-10 12:41:02.271 PST [33237] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2023-12-10 12:41:02.272 PST [33237] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2023-12-10 12:41:02.273 PST [33237] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2023-12-10 12:41:02.273 PST [33237] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2023-12-10 12:41:02.274 PST [33237] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2023-12-10 12:41:02.275 PST [33237] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2023-12-10 12:41:02.275 PST [33237] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2023-12-10 12:41:02.276 PST [33237] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2023-12-10 12:41:02.277 PST [33237] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2023-12-10 12:41:02.277 PST [33237] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2023-12-10 12:41:02.281 PST [33237] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2023-12-10 12:41:02.282 PST [33237] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2023-12-10 12:41:02.282 PST [33237] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2023-12-10 12:41:02.290 PST [33237] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2023-12-10 12:41:02.294 PST [33237] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2023-12-10 12:41:02.294 PST [33237] LOG:  statement: SELECT tableoid, oid, datname, datdba, pg_encoding_to_char(encoding) AS encoding, datcollate, datctype, datfrozenxid, datacl, acldefault('d', datdba) AS acldefault, datistemplate, datconnlimit, datminmxid, datlocprovider, daticulocale, datcollversion, (SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, shobj_description(oid, 'pg_database') AS description FROM pg_database WHERE datname = current_database()
2023-12-10 12:41:02.295 PST [33237] LOG:  statement: SELECT provider, label FROM pg_catalog.pg_shseclabel WHERE classoid = 'pg_catalog.pg_database'::pg_catalog.regclass AND objoid = '16464'
2023-12-10 12:41:02.296 PST [33237] LOG:  statement: SELECT unnest(setconfig) FROM pg_db_role_setting WHERE setrole = 0 AND setdatabase = '16464'::oid
2023-12-10 12:41:02.296 PST [33237] LOG:  statement: SELECT rolname, unnest(setconfig) FROM pg_db_role_setting s, pg_roles r WHERE setrole = r.oid AND setdatabase = '16464'::oid
2023-12-10 12:41:02.297 PST [33237] LOG:  statement: SELECT last_value, is_called FROM public.address_id_seq
2023-12-10 12:41:02.297 PST [33237] LOG:  statement: SELECT last_value, is_called FROM public.menus_id_seq
2023-12-10 12:41:02.297 PST [33237] LOG:  statement: SELECT last_value, is_called FROM public.orders_id_seq
2023-12-10 12:41:02.298 PST [33237] LOG:  statement: SELECT last_value, is_called FROM public.ratings_id_seq
2023-12-10 12:41:02.298 PST [33237] LOG:  statement: SELECT last_value, is_called FROM public.users_user_id_seq
2023-12-10 12:41:02.298 PST [33237] LOG:  statement: COPY public.users (user_id, username, email, password, phone) TO stdout;
2023-12-10 12:41:02.299 PST [33237] LOG:  statement: COPY public.address (id, user_id, street, pincode) TO stdout;
2023-12-10 12:41:02.299 PST [33237] LOG:  statement: COPY public.menu_items (id, qty, price, user_id, item_name) TO stdout;
2023-12-10 12:41:02.299 PST [33237] LOG:  statement: COPY public.restaurants (id, name, address, category) TO stdout;
2023-12-10 12:41:02.475 PST [33237] LOG:  statement: COPY public.menus (id, restaurant_id, category, name, description, price) TO stdout;
2023-12-10 12:41:02.499 PST [33237] LOG:  statement: COPY public.orders (id, user_id, restaurant_id, order_total) TO stdout;
2023-12-10 12:41:02.499 PST [33237] LOG:  statement: COPY public.ratings (id, restaurant_id, ratings, score) TO stdout;
2023-12-10 12:41:58.624 PST [33268] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:41:58.625 PST [33268] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 12:41:58.625 PST [33268] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:41:58.625 PST [33268] LOG:  statement: SET DATESTYLE = ISO
2023-12-10 12:41:58.625 PST [33268] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SET extra_float_digits TO 3
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SET synchronize_seqscans TO off
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SET statement_timeout = 0
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SET lock_timeout = 0
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SET row_security = off
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: BEGIN
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2023-12-10 12:41:58.626 PST [33268] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2023-12-10 12:41:58.628 PST [33268] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2023-12-10 12:41:58.629 PST [33268] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2023-12-10 12:41:58.630 PST [33268] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2023-12-10 12:41:58.631 PST [33268] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2023-12-10 12:41:58.635 PST [33268] LOG:  statement: LOCK TABLE public.address IN ACCESS SHARE MODE
2023-12-10 12:41:58.636 PST [33268] LOG:  statement: LOCK TABLE public.users IN ACCESS SHARE MODE
2023-12-10 12:41:58.636 PST [33268] LOG:  statement: LOCK TABLE public.ratings IN ACCESS SHARE MODE
2023-12-10 12:41:58.636 PST [33268] LOG:  statement: LOCK TABLE public.menus IN ACCESS SHARE MODE
2023-12-10 12:41:58.636 PST [33268] LOG:  statement: LOCK TABLE public.restaurants IN ACCESS SHARE MODE
2023-12-10 12:41:58.636 PST [33268] LOG:  statement: LOCK TABLE public.orders IN ACCESS SHARE MODE
2023-12-10 12:41:58.636 PST [33268] LOG:  statement: LOCK TABLE public.menu_items IN ACCESS SHARE MODE
2023-12-10 12:41:58.636 PST [33268] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:41:58.643 PST [33268] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2023-12-10 12:41:58.647 PST [33268] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2023-12-10 12:41:58.647 PST [33268] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:41:58.648 PST [33268] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2023-12-10 12:41:58.650 PST [33268] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2023-12-10 12:41:58.650 PST [33268] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2023-12-10 12:41:58.651 PST [33268] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2023-12-10 12:41:58.652 PST [33268] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2023-12-10 12:41:58.652 PST [33268] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2023-12-10 12:41:58.653 PST [33268] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2023-12-10 12:41:58.653 PST [33268] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2023-12-10 12:41:58.654 PST [33268] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2023-12-10 12:41:58.654 PST [33268] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2023-12-10 12:41:58.655 PST [33268] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2023-12-10 12:41:58.655 PST [33268] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2023-12-10 12:41:58.657 PST [33268] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2023-12-10 12:41:58.658 PST [33268] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2023-12-10 12:41:58.659 PST [33268] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2023-12-10 12:41:58.659 PST [33268] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2023-12-10 12:41:58.659 PST [33268] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2023-12-10 12:41:58.660 PST [33268] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2023-12-10 12:41:58.661 PST [33268] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.atttypmod,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2023-12-10 12:41:58.662 PST [33268] LOG:  statement: SELECT partrelid FROM pg_partitioned_table WHERE
	(SELECT c.oid FROM pg_opclass c JOIN pg_am a ON c.opcmethod = a.oid
	WHERE opcname = 'enum_ops' AND opcnamespace = 'pg_catalog'::regnamespace AND amname = 'hash') = ANY(partclass)
2023-12-10 12:41:58.663 PST [33268] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2023-12-10 12:41:58.666 PST [33268] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxstattarget FROM pg_catalog.pg_statistic_ext
2023-12-10 12:41:58.666 PST [33268] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2023-12-10 12:41:58.667 PST [33268] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2023-12-10 12:41:58.667 PST [33268] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2023-12-10 12:41:58.668 PST [33268] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2023-12-10 12:41:58.669 PST [33268] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2023-12-10 12:41:58.669 PST [33268] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2023-12-10 12:41:58.670 PST [33268] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2023-12-10 12:41:58.670 PST [33268] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2023-12-10 12:41:58.671 PST [33268] LOG:  statement: WITH RECURSIVE w AS ( SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind FROM pg_depend d1 JOIN pg_class c1 ON c1.oid = d1.objid AND c1.relkind = 'm' JOIN pg_rewrite r1 ON r1.ev_class = d1.objid JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass AND d2.objid = r1.oid AND d2.refobjid <> d1.objid JOIN pg_class c2 ON c2.oid = d2.refobjid AND c2.relkind IN ('m','v') WHERE d1.classid = 'pg_class'::regclass UNION SELECT w.objid, d3.refobjid, c3.relkind FROM w JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass AND d3.objid = r3.oid AND d3.refobjid <> w.refobjid JOIN pg_class c3 ON c3.oid = d3.refobjid AND c3.relkind IN ('m','v') ) SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid FROM w WHERE refrelkind = 'm'
2023-12-10 12:41:58.672 PST [33268] LOG:  statement: SELECT oid, lomowner, lomacl, acldefault('L', lomowner) AS acldefault FROM pg_largeobject_metadata
2023-12-10 12:41:58.673 PST [33268] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2023-12-10 12:41:58.676 PST [33268] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2023-12-10 12:41:58.677 PST [33268] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2023-12-10 12:41:58.678 PST [33268] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2023-12-10 12:41:58.685 PST [33268] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2023-12-10 12:41:58.688 PST [33268] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2023-12-10 12:41:58.689 PST [33268] LOG:  statement: SELECT last_value, is_called FROM public.address_id_seq
2023-12-10 12:41:58.689 PST [33268] LOG:  statement: SELECT last_value, is_called FROM public.menus_id_seq
2023-12-10 12:41:58.689 PST [33268] LOG:  statement: SELECT last_value, is_called FROM public.orders_id_seq
2023-12-10 12:41:58.689 PST [33268] LOG:  statement: SELECT last_value, is_called FROM public.ratings_id_seq
2023-12-10 12:41:58.690 PST [33268] LOG:  statement: SELECT last_value, is_called FROM public.users_user_id_seq
2023-12-10 12:41:58.691 PST [33268] LOG:  statement: COPY public.users (user_id, username, email, password, phone) TO stdout;
2023-12-10 12:41:58.691 PST [33268] LOG:  statement: COPY public.address (id, user_id, street, pincode) TO stdout;
2023-12-10 12:41:58.691 PST [33268] LOG:  statement: COPY public.menu_items (id, qty, price, user_id, item_name) TO stdout;
2023-12-10 12:41:58.691 PST [33268] LOG:  statement: COPY public.restaurants (id, name, address, category) TO stdout;
2023-12-10 12:41:58.724 PST [33268] LOG:  statement: COPY public.menus (id, restaurant_id, category, name, description, price) TO stdout;
2023-12-10 12:41:58.730 PST [33268] LOG:  statement: COPY public.orders (id, user_id, restaurant_id, order_total) TO stdout;
2023-12-10 12:41:58.730 PST [33268] LOG:  statement: COPY public.ratings (id, restaurant_id, ratings, score) TO stdout;
2023-12-10 12:43:28.300 PST [33311] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:43:28.301 PST [33311] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 12:43:28.301 PST [33311] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 12:43:28.301 PST [33311] LOG:  statement: SET DATESTYLE = ISO
2023-12-10 12:43:28.301 PST [33311] LOG:  statement: SET INTERVALSTYLE = POSTGRES
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: SET extra_float_digits TO 3
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: SET synchronize_seqscans TO off
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: SET statement_timeout = 0
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: SET lock_timeout = 0
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: SET idle_in_transaction_session_timeout = 0
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: SET row_security = off
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: BEGIN
2023-12-10 12:43:28.302 PST [33311] LOG:  statement: SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ ONLY
2023-12-10 12:43:28.303 PST [33311] LOG:  statement: SELECT oid, rolname FROM pg_catalog.pg_roles ORDER BY 1
2023-12-10 12:43:28.304 PST [33311] LOG:  statement: SELECT x.tableoid, x.oid, x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition FROM pg_extension x JOIN pg_namespace n ON n.oid = x.extnamespace
2023-12-10 12:43:28.305 PST [33311] LOG:  statement: SELECT classid, objid, refobjid FROM pg_depend WHERE refclassid = 'pg_extension'::regclass AND deptype = 'e' ORDER BY 3
2023-12-10 12:43:28.306 PST [33311] LOG:  statement: SELECT n.tableoid, n.oid, n.nspname, n.nspowner, n.nspacl, acldefault('n', n.nspowner) AS acldefault FROM pg_namespace n
2023-12-10 12:43:28.307 PST [33311] LOG:  statement: SELECT c.tableoid, c.oid, c.relname, c.relnamespace, c.relkind, c.reltype, c.relowner, c.relchecks, c.relhasindex, c.relhasrules, c.relpages, c.relhastriggers, c.relpersistence, c.reloftype, c.relacl, acldefault(CASE WHEN c.relkind = 'S' THEN 's'::"char" ELSE 'r'::"char" END, c.relowner) AS acldefault, CASE WHEN c.relkind = 'f' THEN (SELECT ftserver FROM pg_catalog.pg_foreign_table WHERE ftrelid = c.oid) ELSE 0 END AS foreignserver, c.relfrozenxid, tc.relfrozenxid AS tfrozenxid, tc.oid AS toid, tc.relpages AS toastpages, tc.reloptions AS toast_reloptions, d.refobjid AS owning_tab, d.refobjsubid AS owning_col, tsp.spcname AS reltablespace, false AS relhasoids, c.relispopulated, c.relreplident, c.relrowsecurity, c.relforcerowsecurity, c.relminmxid, tc.relminmxid AS tminmxid, array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, am.amname, (d.deptype = 'i') IS TRUE AS is_identity_sequence, c.relispartition AS ispartition 
	FROM pg_class c
	LEFT JOIN pg_depend d ON (c.relkind = 'S' AND d.classid = 'pg_class'::regclass AND d.objid = c.oid AND d.objsubid = 0 AND d.refclassid = 'pg_class'::regclass AND d.deptype IN ('a', 'i'))
	LEFT JOIN pg_tablespace tsp ON (tsp.oid = c.reltablespace)
	LEFT JOIN pg_am am ON (c.relam = am.oid)
	LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid AND tc.relkind = 't' AND c.relkind <> 'p')
	WHERE c.relkind IN ('r', 'S', 'v', 'c', 'm', 'f', 'p')
	ORDER BY c.oid
2023-12-10 12:43:28.311 PST [33311] LOG:  statement: LOCK TABLE public.address IN ACCESS SHARE MODE
2023-12-10 12:43:28.311 PST [33311] LOG:  statement: LOCK TABLE public.users IN ACCESS SHARE MODE
2023-12-10 12:43:28.311 PST [33311] LOG:  statement: LOCK TABLE public.ratings IN ACCESS SHARE MODE
2023-12-10 12:43:28.312 PST [33311] LOG:  statement: LOCK TABLE public.menus IN ACCESS SHARE MODE
2023-12-10 12:43:28.312 PST [33311] LOG:  statement: LOCK TABLE public.restaurants IN ACCESS SHARE MODE
2023-12-10 12:43:28.312 PST [33311] LOG:  statement: LOCK TABLE public.orders IN ACCESS SHARE MODE
2023-12-10 12:43:28.312 PST [33311] LOG:  statement: LOCK TABLE public.menu_items IN ACCESS SHARE MODE
2023-12-10 12:43:28.312 PST [33311] LOG:  statement: SELECT p.tableoid, p.oid, p.proname, p.prolang, p.pronargs, p.proargtypes, p.prorettype, p.proacl, acldefault('f', p.proowner) AS acldefault, p.pronamespace, p.proowner FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind <> 'a'
	  AND NOT EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_proc'::regclass AND objid = p.oid AND deptype = 'i')
	  AND (
	  pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')
	  OR EXISTS (SELECT 1 FROM pg_cast
	  WHERE pg_cast.oid > 16383 
	  AND p.oid = pg_cast.castfunc)
	  OR EXISTS (SELECT 1 FROM pg_transform
	  WHERE pg_transform.oid > 16383 AND 
	  (p.oid = pg_transform.trffromsql
	  OR p.oid = pg_transform.trftosql))
	  OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:43:28.319 PST [33311] LOG:  statement: SELECT tableoid, oid, typname, typnamespace, typacl, acldefault('T', typowner) AS acldefault, typowner, typelem, typrelid, CASE WHEN typrelid = 0 THEN ' '::"char" ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, typtype, typisdefined, typname[0] = '_' AND typelem != 0 AND (SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray FROM pg_type
2023-12-10 12:43:28.322 PST [33311] LOG:  statement: SELECT tableoid, oid, lanname, lanpltrusted, lanplcallfoid, laninline, lanvalidator, lanacl, acldefault('l', lanowner) AS acldefault, lanowner FROM pg_language WHERE lanispl ORDER BY oid
2023-12-10 12:43:28.323 PST [33311] LOG:  statement: SELECT p.tableoid, p.oid, p.proname AS aggname, p.pronamespace AS aggnamespace, p.pronargs, p.proargtypes, p.proowner, p.proacl AS aggacl, acldefault('f', p.proowner) AS acldefault FROM pg_proc p LEFT JOIN pg_init_privs pip ON (p.oid = pip.objoid AND pip.classoid = 'pg_proc'::regclass AND pip.objsubid = 0) WHERE p.prokind = 'a' AND (p.pronamespace != (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') OR p.proacl IS DISTINCT FROM pip.initprivs)
2023-12-10 12:43:28.323 PST [33311] LOG:  statement: SELECT tableoid, oid, oprname, oprnamespace, oprowner, oprkind, oprcode::oid AS oprcode FROM pg_operator
2023-12-10 12:43:28.325 PST [33311] LOG:  statement: SELECT tableoid, oid, amname, amtype, amhandler::pg_catalog.regproc AS amhandler FROM pg_am
2023-12-10 12:43:28.325 PST [33311] LOG:  statement: SELECT tableoid, oid, opcname, opcnamespace, opcowner FROM pg_opclass
2023-12-10 12:43:28.326 PST [33311] LOG:  statement: SELECT tableoid, oid, opfname, opfnamespace, opfowner FROM pg_opfamily
2023-12-10 12:43:28.327 PST [33311] LOG:  statement: SELECT tableoid, oid, prsname, prsnamespace, prsstart::oid, prstoken::oid, prsend::oid, prsheadline::oid, prslextype::oid FROM pg_ts_parser
2023-12-10 12:43:28.327 PST [33311] LOG:  statement: SELECT tableoid, oid, tmplname, tmplnamespace, tmplinit::oid, tmpllexize::oid FROM pg_ts_template
2023-12-10 12:43:28.327 PST [33311] LOG:  statement: SELECT tableoid, oid, dictname, dictnamespace, dictowner, dicttemplate, dictinitoption FROM pg_ts_dict
2023-12-10 12:43:28.328 PST [33311] LOG:  statement: SELECT tableoid, oid, cfgname, cfgnamespace, cfgowner, cfgparser FROM pg_ts_config
2023-12-10 12:43:28.328 PST [33311] LOG:  statement: SELECT tableoid, oid, fdwname, fdwowner, fdwhandler::pg_catalog.regproc, fdwvalidator::pg_catalog.regproc, fdwacl, acldefault('F', fdwowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(fdwoptions) ORDER BY option_name), E',
	    ') AS fdwoptions FROM pg_foreign_data_wrapper
2023-12-10 12:43:28.329 PST [33311] LOG:  statement: SELECT tableoid, oid, srvname, srvowner, srvfdw, srvtype, srvversion, srvacl, acldefault('S', srvowner) AS acldefault, array_to_string(ARRAY(SELECT quote_ident(option_name) || ' ' || quote_literal(option_value) FROM pg_options_to_table(srvoptions) ORDER BY option_name), E',
	    ') AS srvoptions FROM pg_foreign_server
2023-12-10 12:43:28.329 PST [33311] LOG:  statement: SELECT oid, tableoid, defaclrole, defaclnamespace, defaclobjtype, defaclacl, CASE WHEN defaclnamespace = 0 THEN acldefault(CASE WHEN defaclobjtype = 'S' THEN 's'::"char" ELSE defaclobjtype END, defaclrole) ELSE '{}' END AS acldefault FROM pg_default_acl
2023-12-10 12:43:28.330 PST [33311] LOG:  statement: SELECT tableoid, oid, collname, collnamespace, collowner FROM pg_collation
2023-12-10 12:43:28.331 PST [33311] LOG:  statement: SELECT tableoid, oid, conname, connamespace, conowner FROM pg_conversion
2023-12-10 12:43:28.332 PST [33311] LOG:  statement: SELECT tableoid, oid, castsource, casttarget, castfunc, castcontext, castmethod FROM pg_cast c WHERE NOT EXISTS ( SELECT 1 FROM pg_range r WHERE c.castsource = r.rngtypid AND c.casttarget = r.rngmultitypid ) ORDER BY 3,4
2023-12-10 12:43:28.333 PST [33311] LOG:  statement: SELECT tableoid, oid, trftype, trflang, trffromsql::oid, trftosql::oid FROM pg_transform ORDER BY 3,4
2023-12-10 12:43:28.333 PST [33311] LOG:  statement: SELECT inhrelid, inhparent FROM pg_inherits
2023-12-10 12:43:28.334 PST [33311] LOG:  statement: SELECT e.tableoid, e.oid, evtname, evtenabled, evtevent, evtowner, array_to_string(array(select quote_literal(x)  from unnest(evttags) as t(x)), ', ') as evttags, e.evtfoid::regproc as evtfname FROM pg_event_trigger e ORDER BY e.oid
2023-12-10 12:43:28.334 PST [33311] LOG:  statement: SELECT conrelid, confrelid FROM pg_constraint JOIN pg_depend ON (objid = confrelid) WHERE contype = 'f' AND refclassid = 'pg_extension'::regclass AND classid = 'pg_class'::regclass;
2023-12-10 12:43:28.335 PST [33311] LOG:  statement: SELECT
	a.attrelid,
	a.attnum,
	a.attname,
	a.atttypmod,
	a.attstattarget,
	a.attstorage,
	t.typstorage,
	a.attnotnull,
	a.atthasdef,
	a.attisdropped,
	a.attlen,
	a.attalign,
	a.attislocal,
	pg_catalog.format_type(t.oid, a.atttypmod) AS atttypname,
	array_to_string(a.attoptions, ', ') AS attoptions,
	CASE WHEN a.attcollation <> t.typcollation THEN a.attcollation ELSE 0 END AS attcollation,
	pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(option_name) || ' ' || pg_catalog.quote_literal(option_value) FROM pg_catalog.pg_options_to_table(attfdwoptions) ORDER BY option_name), E',
	    ') AS attfdwoptions,
	a.attcompression AS attcompression,
	a.attidentity,
	CASE WHEN a.atthasmissing AND NOT a.attisdropped THEN a.attmissingval ELSE null END AS attmissingval,
	a.attgenerated
	FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attribute a ON (src.tbloid = a.attrelid) LEFT JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid)
	WHERE a.attnum > 0::pg_catalog.int2
	ORDER BY a.attrelid, a.attnum
2023-12-10 12:43:28.336 PST [33311] LOG:  statement: SELECT a.tableoid, a.oid, adrelid, adnum, pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc
	FROM unnest('{16617,16653,16667,16674,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_attrdef a ON (src.tbloid = a.adrelid)
	ORDER BY a.adrelid, a.adnum
2023-12-10 12:43:28.337 PST [33311] LOG:  statement: SELECT t.tableoid, t.oid, i.indrelid, t.relname AS indexname, pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, i.indkey, i.indisclustered, c.contype, c.conname, c.condeferrable, c.condeferred, c.tableoid AS contableoid, c.oid AS conoid, pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, (SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, t.reloptions AS indreloptions, i.indisreplident, inh.inhparent AS parentidx, i.indnkeyatts AS indnkeyatts, i.indnatts AS indnatts, (SELECT pg_catalog.array_agg(attnum ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatcols, (SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum)   FROM pg_catalog.pg_attribute   WHERE attrelid = i.indexrelid AND     attstattarget >= 0) AS indstatvals, i.indnullsnotdistinct FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_index i ON (src.tbloid = i.indrelid) JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) LEFT JOIN pg_catalog.pg_constraint c ON (i.indrelid = c.conrelid AND i.indexrelid = c.conindid AND c.contype IN ('p','u','x')) LEFT JOIN pg_catalog.pg_inherits inh ON (inh.inhrelid = indexrelid) WHERE (i.indisvalid OR t2.relkind = 'p') AND i.indisready ORDER BY i.indrelid, indexname
2023-12-10 12:43:28.340 PST [33311] LOG:  statement: SELECT tableoid, oid, stxname, stxnamespace, stxowner, stxstattarget FROM pg_catalog.pg_statistic_ext
2023-12-10 12:43:28.340 PST [33311] LOG:  statement: SELECT c.tableoid, c.oid, conrelid, conname, confrelid, conindid, pg_catalog.pg_get_constraintdef(c.oid) AS condef
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_constraint c ON (src.tbloid = c.conrelid)
	WHERE contype = 'f' AND conparentid = 0 ORDER BY conrelid, conname
2023-12-10 12:43:28.340 PST [33311] LOG:  statement: SELECT t.tgrelid, t.tgname, t.tgfoid::pg_catalog.regproc AS tgfname, pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, t.tgenabled, t.tableoid, t.oid, t.tgparentid <> 0 AS tgispartition
	FROM unnest('{16617,16653,16667,16674,16686,16694}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_trigger t ON (src.tbloid = t.tgrelid) LEFT JOIN pg_catalog.pg_trigger u ON (u.oid = t.tgparentid) WHERE ((NOT t.tgisinternal AND t.tgparentid = 0) OR t.tgenabled != u.tgenabled) ORDER BY t.tgrelid, t.tgname
2023-12-10 12:43:28.341 PST [33311] LOG:  statement: SELECT tableoid, oid, rulename, ev_class AS ruletable, ev_type, is_instead, ev_enabled FROM pg_rewrite ORDER BY oid
2023-12-10 12:43:28.342 PST [33311] LOG:  statement: SELECT pol.oid, pol.tableoid, pol.polrelid, pol.polname, pol.polcmd, pol.polpermissive, CASE WHEN pol.polroles = '{0}' THEN NULL ELSE    pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck FROM unnest('{16617,16653,16667,16674,16686,16694,16736}'::pg_catalog.oid[]) AS src(tbloid)
	JOIN pg_catalog.pg_policy pol ON (src.tbloid = pol.polrelid)
2023-12-10 12:43:28.343 PST [33311] LOG:  statement: SELECT p.tableoid, p.oid, p.pubname, p.pubowner, p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate, p.pubviaroot FROM pg_publication p
2023-12-10 12:43:28.343 PST [33311] LOG:  statement: SELECT tableoid, oid, prpubid, prrelid, pg_catalog.pg_get_expr(prqual, prrelid) AS prrelqual, (CASE
	  WHEN pr.prattrs IS NOT NULL THEN
	    (SELECT array_agg(attname)
	       FROM
	         pg_catalog.generate_series(0, pg_catalog.array_upper(pr.prattrs::pg_catalog.int2[], 1)) s,
	         pg_catalog.pg_attribute
	      WHERE attrelid = pr.prrelid AND attnum = prattrs[s])
	  ELSE NULL END) prattrs FROM pg_catalog.pg_publication_rel pr
2023-12-10 12:43:28.344 PST [33311] LOG:  statement: SELECT tableoid, oid, pnpubid, pnnspid FROM pg_catalog.pg_publication_namespace
2023-12-10 12:43:28.344 PST [33311] LOG:  statement: SELECT s.tableoid, s.oid, s.subname,
	 s.subowner,
	 s.subconninfo, s.subslotname, s.subsynccommit,
	 s.subpublications,
	 s.subbinary,
	 s.substream,
	 s.subtwophasestate,
	 s.subdisableonerr
	FROM pg_subscription s
	WHERE s.subdbid = (SELECT oid FROM pg_database
	                   WHERE datname = current_database())
2023-12-10 12:43:28.345 PST [33311] LOG:  statement: SELECT classid, objid, refclassid, refobjid, deptype FROM pg_depend WHERE deptype != 'p' AND deptype != 'e'
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amopfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amop o WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amop'::regclass AND objid = o.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amopfamily = refobjid)
	UNION ALL
	SELECT 'pg_opfamily'::regclass AS classid, amprocfamily AS objid, refclassid, refobjid, deptype FROM pg_depend d, pg_amproc p WHERE deptype NOT IN ('p', 'e', 'i') AND classid = 'pg_amproc'::regclass AND objid = p.oid AND NOT (refclassid = 'pg_opfamily'::regclass AND amprocfamily = refobjid)
	ORDER BY 1,2
2023-12-10 12:43:28.348 PST [33311] LOG:  statement: SELECT DISTINCT attrelid FROM pg_attribute WHERE attacl IS NOT NULL
2023-12-10 12:43:28.349 PST [33311] LOG:  statement: SELECT objoid, classoid, objsubid, privtype, initprivs FROM pg_init_privs
2023-12-10 12:43:28.350 PST [33311] LOG:  statement: SELECT description, classoid, objoid, objsubid FROM pg_catalog.pg_description ORDER BY classoid, objoid, objsubid
2023-12-10 12:43:28.358 PST [33311] LOG:  statement: SELECT label, provider, classoid, objoid, objsubid FROM pg_catalog.pg_seclabel ORDER BY classoid, objoid, objsubid
2023-12-10 12:43:28.362 PST [33311] LOG:  statement: SELECT pg_catalog.current_schemas(false)
2023-12-10 12:43:28.362 PST [33311] LOG:  statement: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2023-12-10 12:43:28.363 PST [33311] LOG:  statement: EXECUTE getColumnACLs('6100')
2023-12-10 12:43:28.363 PST [33311] DETAIL:  prepare: PREPARE getColumnACLs(pg_catalog.oid) AS
	SELECT at.attname, at.attacl, '{}' AS acldefault, pip.privtype, pip.initprivs FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_init_privs pip ON (at.attrelid = pip.objoid AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass AND at.attnum = pip.objsubid) WHERE at.attrelid = $1 AND NOT at.attisdropped AND (at.attacl IS NOT NULL OR pip.initprivs IS NOT NULL) ORDER BY at.attnum
2023-12-10 12:43:28.363 PST [33311] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16616'::oid
2023-12-10 12:43:28.364 PST [33311] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16673'::oid
2023-12-10 12:43:28.364 PST [33311] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16693'::oid
2023-12-10 12:43:28.364 PST [33311] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16666'::oid
2023-12-10 12:43:28.364 PST [33311] LOG:  statement: SELECT format_type(seqtypid, NULL), seqstart, seqincrement, seqmax, seqmin, seqcache, seqcycle FROM pg_catalog.pg_sequence WHERE seqrelid = '16652'::oid
2023-12-10 12:44:25.286 PST [33336] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 12:47:26.086 PST [33431] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 13:01:37.545 PST [30724] LOG:  statement: SELECT pg_catalog.current_setting('lc_ctype') as cname
	UNION
	SELECT pg_catalog.current_setting('lc_collate') as cname
2023-12-10 13:01:37.557 PST [30724] LOG:  statement: SELECT
	    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
	    db.datistemplate AS is_template,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner,
	    descr.description
	FROM
	    pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE         db.oid > 0::OID OR db.datname IN ('postgres', 'edb')
	
	ORDER BY datname;
2023-12-10 13:01:37.567 PST [30724] LOG:  statement: SELECT pg_catalog.current_setting('lc_ctype') as cname
	UNION
	SELECT pg_catalog.current_setting('lc_collate') as cname
2023-12-10 13:02:03.917 PST [30724] LOG:  statement: CREATE DATABASE "Final"
	    WITH
	    OWNER = postgres
	    ENCODING = 'UTF8'
	    CONNECTION LIMIT = -1
	    IS_TEMPLATE = False;
	
2023-12-10 13:02:04.918 PST [30724] LOG:  statement: SELECT
	    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
	    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
	    pg_catalog.pg_get_userbyid(datdba) AS datowner,
	    (select pg_catalog.current_setting('lc_collate')) as datcollate,
	    (select pg_catalog.current_setting('lc_ctype')) as datctype,
	    datconnlimit,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
	    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
	    descr.description AS comments, db.datistemplate AS is_template,
	        '' AS tblacl,
	        '' AS seqacl,
	        '' AS funcacl,
	    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
	FROM pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE
	            db.datname = 'Final'::text
	    
	
	ORDER BY datname;
2023-12-10 13:02:05.061 PST [30724] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:02:05.150 PST [33808] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:02:05.162 PST [33808] LOG:  statement: SELECT version()
2023-12-10 13:02:05.163 PST [33808] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:02:05.171 PST [33808] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:02:05.174 PST [33808] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:02:32.962 PST [30724] LOG:  statement: SELECT * FROM
	(SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
	FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
	WHERE encoding != '' ORDER BY encoding;
	
	
2023-12-10 13:04:24.727 PST [33871] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 13:04:24.727 PST [33871] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 13:04:24.728 PST [33871] LOG:  statement: --
	-- PostgreSQL database dump
	--
	
	
2023-12-10 13:04:24.728 PST [33871] LOG:  statement: -- Dumped from database version 15.5
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: -- Dumped by pg_dump version 15.3
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: 
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: -- Started on 2023-12-10 12:32:39 PST
	
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: SET statement_timeout = 0;
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: SET lock_timeout = 0;
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: SET idle_in_transaction_session_timeout = 0;
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: SET client_encoding = 'UTF8';
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: SET standard_conforming_strings = on;
	
2023-12-10 13:04:24.729 PST [33871] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
	
2023-12-10 13:04:24.730 PST [33871] LOG:  statement: SET check_function_bodies = false;
	
2023-12-10 13:04:24.730 PST [33871] LOG:  statement: SET xmloption = content;
	
2023-12-10 13:04:24.730 PST [33871] LOG:  statement: SET client_min_messages = warning;
	
2023-12-10 13:04:24.730 PST [33871] LOG:  statement: SET row_security = off;
	
2023-12-10 13:04:24.730 PST [33871] LOG:  statement: 
	
2023-12-10 13:04:24.730 PST [33871] LOG:  statement: SET default_tablespace = ''
2023-12-10 13:04:24.731 PST [33871] LOG:  statement: SET default_table_access_method = heap;
2023-12-10 13:04:24.732 PST [33871] LOG:  statement: CREATE TABLE public.address (
	    id integer NOT NULL,
	    user_id integer,
	    street character varying(255),
	    pincode character varying(6)
	);
	
	
	
2023-12-10 13:04:24.743 PST [33871] LOG:  statement: ALTER TABLE public.address OWNER TO postgres;
	
	
2023-12-10 13:04:24.744 PST [33871] LOG:  statement: CREATE SEQUENCE public.address_id_seq
	    AS integer
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-12-10 13:04:24.748 PST [33871] LOG:  statement: ALTER TABLE public.address_id_seq OWNER TO postgres;
	
	
2023-12-10 13:04:24.748 PST [33871] LOG:  statement: ALTER SEQUENCE public.address_id_seq OWNED BY public.address.id;
	
	
	
2023-12-10 13:04:24.749 PST [33871] LOG:  statement: CREATE TABLE public.menu_items (
	    id integer NOT NULL,
	    qty integer,
	    price numeric(255,2),
	    user_id integer,
	    item_name character varying(255)
	);
	
	
	
2023-12-10 13:04:24.751 PST [33871] LOG:  statement: ALTER TABLE public.menu_items OWNER TO postgres;
	
	
2023-12-10 13:04:24.751 PST [33871] LOG:  statement: CREATE TABLE public.menus (
	    id integer NOT NULL,
	    restaurant_id integer,
	    category text,
	    name character varying(255),
	    description text,
	    price numeric(255,2)
	);
	
	
	
2023-12-10 13:04:24.756 PST [33871] LOG:  statement: ALTER TABLE public.menus OWNER TO postgres;
	
	
2023-12-10 13:04:24.756 PST [33871] LOG:  statement: CREATE SEQUENCE public.menus_id_seq
	    AS integer
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-12-10 13:04:24.757 PST [33871] LOG:  statement: ALTER TABLE public.menus_id_seq OWNER TO postgres;
	
	
2023-12-10 13:04:24.757 PST [33871] LOG:  statement: ALTER SEQUENCE public.menus_id_seq OWNED BY public.menus.id;
	
	
	
2023-12-10 13:04:24.758 PST [33871] LOG:  statement: CREATE TABLE public.orders (
	    id integer NOT NULL,
	    user_id integer,
	    restaurant_id integer,
	    order_total numeric(255,2)
	);
	
	
	
2023-12-10 13:04:24.760 PST [33871] LOG:  statement: ALTER TABLE public.orders OWNER TO postgres;
	
	
2023-12-10 13:04:24.761 PST [33871] LOG:  statement: CREATE SEQUENCE public.orders_id_seq
	    AS integer
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-12-10 13:04:24.762 PST [33871] LOG:  statement: ALTER TABLE public.orders_id_seq OWNER TO postgres;
	
	
2023-12-10 13:04:24.762 PST [33871] LOG:  statement: ALTER SEQUENCE public.orders_id_seq OWNED BY public.orders.id;
	
	
	
2023-12-10 13:04:24.762 PST [33871] LOG:  statement: CREATE TABLE public.ratings (
	    id integer NOT NULL,
	    restaurant_id integer,
	    ratings numeric(255,2),
	    score numeric(255,2)
	);
	
	
	
2023-12-10 13:04:24.764 PST [33871] LOG:  statement: ALTER TABLE public.ratings OWNER TO postgres;
	
	
2023-12-10 13:04:24.764 PST [33871] LOG:  statement: CREATE SEQUENCE public.ratings_id_seq
	    AS integer
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-12-10 13:04:24.765 PST [33871] LOG:  statement: ALTER TABLE public.ratings_id_seq OWNER TO postgres;
	
	
2023-12-10 13:04:24.765 PST [33871] LOG:  statement: ALTER SEQUENCE public.ratings_id_seq OWNED BY public.ratings.id;
	
	
	
2023-12-10 13:04:24.765 PST [33871] LOG:  statement: CREATE TABLE public.restaurants (
	    id integer NOT NULL,
	    name character varying(255),
	    address character varying(255),
	    category text
	);
	
	
	
2023-12-10 13:04:24.767 PST [33871] LOG:  statement: ALTER TABLE public.restaurants OWNER TO postgres;
	
	
2023-12-10 13:04:24.768 PST [33871] LOG:  statement: CREATE TABLE public.users (
	    user_id integer NOT NULL,
	    username character varying(255),
	    email character varying(255),
	    password character varying(255),
	    phone character varying(255)
	);
	
	
	
2023-12-10 13:04:24.770 PST [33871] LOG:  statement: ALTER TABLE public.users OWNER TO postgres;
	
	
2023-12-10 13:04:24.771 PST [33871] LOG:  statement: CREATE SEQUENCE public.users_user_id_seq
	    AS integer
	    START WITH 1
	    INCREMENT BY 1
	    NO MINVALUE
	    NO MAXVALUE
	    CACHE 1;
	
	
	
2023-12-10 13:04:24.771 PST [33871] LOG:  statement: ALTER TABLE public.users_user_id_seq OWNER TO postgres;
	
	
2023-12-10 13:04:24.771 PST [33871] LOG:  statement: ALTER SEQUENCE public.users_user_id_seq OWNED BY public.users.user_id;
	
	
	
2023-12-10 13:04:24.772 PST [33871] LOG:  statement: ALTER TABLE ONLY public.address ALTER COLUMN id SET DEFAULT nextval('public.address_id_seq'::regclass);
	
	
	
2023-12-10 13:04:24.776 PST [33871] LOG:  statement: ALTER TABLE ONLY public.menus ALTER COLUMN id SET DEFAULT nextval('public.menus_id_seq'::regclass);
	
	
	
2023-12-10 13:04:24.777 PST [33871] LOG:  statement: ALTER TABLE ONLY public.orders ALTER COLUMN id SET DEFAULT nextval('public.orders_id_seq'::regclass);
	
	
	
2023-12-10 13:04:24.777 PST [33871] LOG:  statement: ALTER TABLE ONLY public.ratings ALTER COLUMN id SET DEFAULT nextval('public.ratings_id_seq'::regclass);
	
	
	
2023-12-10 13:04:24.778 PST [33871] LOG:  statement: ALTER TABLE ONLY public.users ALTER COLUMN user_id SET DEFAULT nextval('public.users_user_id_seq'::regclass);
	
	
	
2023-12-10 13:04:24.778 PST [33871] LOG:  statement: ALTER TABLE ONLY public.address
	    ADD CONSTRAINT address_pkey PRIMARY KEY (id);
	
	
	
2023-12-10 13:04:24.781 PST [33871] LOG:  statement: ALTER TABLE ONLY public.menus
	    ADD CONSTRAINT menus_pkey PRIMARY KEY (id);
	
	
	
2023-12-10 13:04:24.783 PST [33871] LOG:  statement: ALTER TABLE ONLY public.orders
	    ADD CONSTRAINT orders_pkey PRIMARY KEY (id);
	
	
	
2023-12-10 13:04:24.785 PST [33871] LOG:  statement: ALTER TABLE ONLY public.ratings
	    ADD CONSTRAINT ratings_pkey PRIMARY KEY (id);
	
	
	
2023-12-10 13:04:24.787 PST [33871] LOG:  statement: ALTER TABLE ONLY public.restaurants
	    ADD CONSTRAINT restaurants_pkey PRIMARY KEY (id);
	
	
	
2023-12-10 13:04:24.789 PST [33871] LOG:  statement: ALTER TABLE ONLY public.users
	    ADD CONSTRAINT users_pkey PRIMARY KEY (user_id);
	
	
	
2023-12-10 13:04:24.791 PST [33871] LOG:  statement: ALTER TABLE ONLY public.address
	    ADD CONSTRAINT address_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id) NOT VALID;
	
	
	
2023-12-10 13:04:24.795 PST [33871] LOG:  statement: ALTER TABLE ONLY public.menus
	    ADD CONSTRAINT menus_restaurant_id_fkey FOREIGN KEY (restaurant_id) REFERENCES public.restaurants(id) NOT VALID;
	
	
	
2023-12-10 13:04:24.796 PST [33871] LOG:  statement: ALTER TABLE ONLY public.orders
	    ADD CONSTRAINT orders_restaurant_id_fkey FOREIGN KEY (restaurant_id) REFERENCES public.restaurants(id) NOT VALID;
	
	
	
2023-12-10 13:04:24.797 PST [33871] LOG:  statement: ALTER TABLE ONLY public.orders
	    ADD CONSTRAINT orders_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(user_id) NOT VALID;
	
	
	
2023-12-10 13:04:24.797 PST [33871] LOG:  statement: ALTER TABLE ONLY public.ratings
	    ADD CONSTRAINT ratings_restaurant_id_fkey FOREIGN KEY (restaurant_id) REFERENCES public.restaurants(id) NOT VALID;
	
	
	
2023-12-10 13:04:24.798 PST [33871] LOG:  statement: -- Completed on 2023-12-10 13:04:24 PST
	
	
2023-12-10 13:04:24.798 PST [33871] LOG:  statement: --
	-- PostgreSQL database dump complete
	--
	
	
2023-12-10 13:04:56.570 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:06:11.379 PST [33928] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
2023-12-10 13:06:11.380 PST [33928] LOG:  statement: SELECT pg_catalog.pg_is_in_recovery()
2023-12-10 13:06:11.380 PST [33928] LOG:  statement: --
	-- PostgreSQL database dump
	--
	
	
2023-12-10 13:06:11.380 PST [33928] LOG:  statement: -- Dumped from database version 15.5
	
2023-12-10 13:06:11.380 PST [33928] LOG:  statement: -- Dumped by pg_dump version 15.3
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: 
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: -- Started on 2023-12-10 12:33:42 PST
	
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: SET statement_timeout = 0;
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: SET lock_timeout = 0;
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: SET idle_in_transaction_session_timeout = 0;
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: SET client_encoding = 'UTF8';
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: SET standard_conforming_strings = on;
	
2023-12-10 13:06:11.381 PST [33928] LOG:  statement: SELECT pg_catalog.set_config('search_path', '', false);
	
2023-12-10 13:06:11.382 PST [33928] LOG:  statement: SET check_function_bodies = false;
	
2023-12-10 13:06:11.382 PST [33928] LOG:  statement: SET xmloption = content;
	
2023-12-10 13:06:11.382 PST [33928] LOG:  statement: SET client_min_messages = warning;
	
2023-12-10 13:06:11.382 PST [33928] LOG:  statement: SET row_security = off;
	
2023-12-10 13:06:11.382 PST [33928] LOG:  statement: 
	
2023-12-10 13:06:11.382 PST [33928] LOG:  statement: COPY public.users (user_id, username, email, password, phone) FROM stdin;
	
2023-12-10 13:06:11.386 PST [33928] LOG:  statement: COPY public.address (id, user_id, street, pincode) FROM stdin;
	
2023-12-10 13:06:11.389 PST [33928] LOG:  statement: COPY public.menu_items (id, qty, price, user_id, item_name) FROM stdin;
	
2023-12-10 13:06:11.391 PST [33928] LOG:  statement: COPY public.restaurants (id, name, address, category) FROM stdin;
	
2023-12-10 13:06:11.792 PST [33928] LOG:  statement: COPY public.menus (id, restaurant_id, category, name, description, price) FROM stdin;
	
2023-12-10 13:06:11.868 PST [33928] LOG:  statement: COPY public.orders (id, user_id, restaurant_id, order_total) FROM stdin;
	
2023-12-10 13:06:11.869 PST [33928] LOG:  statement: COPY public.ratings (id, restaurant_id, ratings, score) FROM stdin;
	
2023-12-10 13:06:12.082 PST [33928] LOG:  statement: SELECT pg_catalog.setval('public.address_id_seq', 7, true);
	
	
	
2023-12-10 13:06:12.083 PST [33928] LOG:  statement: SELECT pg_catalog.setval('public.menus_id_seq', 4600, true);
	
	
	
2023-12-10 13:06:12.083 PST [33928] LOG:  statement: SELECT pg_catalog.setval('public.orders_id_seq', 1, false);
	
	
	
2023-12-10 13:06:12.084 PST [33928] LOG:  statement: SELECT pg_catalog.setval('public.ratings_id_seq', 19118, true);
	
	
	
2023-12-10 13:06:12.084 PST [33928] LOG:  statement: SELECT pg_catalog.setval('public.users_user_id_seq', 5, true);
	
	
	
2023-12-10 13:06:12.085 PST [33928] LOG:  statement: -- Completed on 2023-12-10 13:06:12 PST
	
	
2023-12-10 13:06:12.085 PST [33928] LOG:  statement: --
	-- PostgreSQL database dump complete
	--
	
	
2023-12-10 13:06:27.710 PST [33808] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-10 13:06:27.971 PST [33808] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-10 13:06:30.667 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-10 13:06:33.348 PST [36662] LOG:  checkpoint complete: wrote 957 buffers (5.8%); 0 WAL file(s) added, 0 removed, 0 recycled; write=96.728 s, sync=0.037 s, total=96.778 s; sync files=327, longest=0.001 s, average=0.001 s; distance=4420 kB, estimate=4420 kB
2023-12-10 13:07:16.949 PST [33967] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:07:16.951 PST [33967] LOG:  statement: SELECT version()
2023-12-10 13:07:16.953 PST [33967] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:07:16.956 PST [33967] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:07:16.958 PST [33967] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:07:16.971 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16766;
	
2023-12-10 13:07:17.150 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:07:17.161 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:07:17.164 PST [33967] LOG:  statement: SELECT * FROM public.users
	ORDER BY user_id ASC 
2023-12-10 13:07:17.424 PST [33967] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16766::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:07:17.439 PST [33967] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:07:17.439 PST [33967] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-10 13:07:28.059 PST [33971] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:07:28.062 PST [33971] LOG:  statement: SELECT version()
2023-12-10 13:07:28.063 PST [33971] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:07:28.065 PST [33971] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:07:28.067 PST [33971] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:07:28.071 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16753;
	
2023-12-10 13:07:28.183 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:07:28.186 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:07:28.191 PST [33971] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 13:07:28.429 PST [33971] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:07:28.437 PST [33971] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:07:28.437 PST [33971] DETAIL:  parameters: $1 = '{23,23,23,1700}'
2023-12-10 13:09:56.338 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:11:54.583 PST [36662] LOG:  checkpoint complete: wrote 1170 buffers (7.1%); 0 WAL file(s) added, 0 removed, 1 recycled; write=118.222 s, sync=0.008 s, total=118.246 s; sync files=32, longest=0.006 s, average=0.001 s; distance=11591 kB, estimate=11591 kB
2023-12-10 13:12:49.065 PST [33808] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 13:12:49.070 PST [33808] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-10 13:12:49.072 PST [33808] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 13:12:49.085 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 13:12:49.116 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:12:49.118 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:12:49.121 PST [33808] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:12:49.132 PST [33808] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:12:49.136 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:12:49.138 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:12:49.139 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:12:49.140 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:12:49.141 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:12:49.144 PST [33808] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:12:49.145 PST [33808] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:12:49.146 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:12:49.148 PST [33808] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 13:12:49.150 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16761::oid
	    AND a2.attnum=1
	
2023-12-10 13:12:49.150 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16761::oid
2023-12-10 13:12:49.151 PST [33808] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:12:49.154 PST [33808] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:12:49.154 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 13:12:49.155 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 13:12:49.155 PST [33808] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:12:49.158 PST [33808] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:12:49.159 PST [33808] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 13:12:49.159 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:12:50.265 PST [33808] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:12:50.288 PST [33808] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:12:50.301 PST [33808] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:12:50.314 PST [33808] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:13:23.368 PST [33808] LOG:  statement: SELECT cl.oid as value, pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(relname) AS label
	FROM pg_catalog.pg_namespace nsp, pg_class cl
	WHERE relnamespace=nsp.oid AND relkind in ('r', 'p')
	   AND nsp.nspname NOT LIKE E'pg\_temp\_%'
	      AND (nsp.nspname NOT LIKE 'pg\_%' AND nsp.nspname NOT in ('information_schema'))
	   ORDER BY nspname, relname
2023-12-10 13:13:31.473 PST [33808] LOG:  statement: SELECT
	    a.attname AS name, pg_catalog.format_type(a.atttypid, NULL) AS cltype,
	    pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval, a.attidentity as clidentity,
	    pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) as inheritedfrom,
	    c.oid as inheritedid
	FROM
	    pg_catalog.pg_class c
	JOIN
	    pg_catalog.pg_namespace n ON c.relnamespace=n.oid
	JOIN
	    pg_catalog.pg_attribute a ON a.attrelid = c.oid AND NOT a.attisdropped AND a.attnum > 0
	LEFT OUTER JOIN
	    pg_catalog.pg_attrdef def ON adrelid=a.attrelid AND adnum=a.attnum
	WHERE
	    c.oid = 16744::OID
	
2023-12-10 13:13:44.404 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 13:13:44.410 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:13:44.412 PST [33808] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16739)ORDER BY
	    pid, locktype
2023-12-10 13:13:44.419 PST [33808] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16753::oid;
	
2023-12-10 13:13:44.420 PST [33808] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-10 13:13:44.421 PST [33808] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16753::oid;
2023-12-10 13:13:44.422 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:13:44.424 PST [33808] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:13:44.429 PST [33808] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:13:44.431 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:13:44.432 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:13:44.433 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:13:44.434 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:13:44.435 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:13:44.437 PST [33808] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:13:44.437 PST [33808] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:13:44.438 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:13:44.440 PST [33808] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 13:13:44.442 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16761::oid
	    AND a2.attnum=1
	
2023-12-10 13:13:44.442 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16761::oid
2023-12-10 13:13:44.443 PST [33808] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:13:44.446 PST [33808] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:13:44.446 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 13:13:44.446 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 13:13:44.447 PST [33808] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:13:44.450 PST [33808] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:13:44.450 PST [33808] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 13:13:44.451 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:13:44.457 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16744::oid
2023-12-10 13:13:44.460 PST [33808] LOG:  statement: ALTER TABLE IF EXISTS public.orders
	    ADD COLUMN order_id integer;
	ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (order_id)
	    REFERENCES public.menu_items (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-10 13:13:44.462 PST [33808] ERROR:  there is no unique constraint matching given keys for referenced table "menu_items"
2023-12-10 13:13:44.462 PST [33808] STATEMENT:  ALTER TABLE IF EXISTS public.orders
	    ADD COLUMN order_id integer;
	ALTER TABLE IF EXISTS public.orders
	    ADD FOREIGN KEY (order_id)
	    REFERENCES public.menu_items (id) MATCH SIMPLE
	    ON UPDATE NO ACTION
	    ON DELETE NO ACTION
	    NOT VALID;
2023-12-10 13:14:06.997 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 13:14:07.004 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:14:07.006 PST [33808] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16739)ORDER BY
	    pid, locktype
2023-12-10 13:14:07.007 PST [33808] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16753::oid;
	
2023-12-10 13:14:07.007 PST [33808] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-10 13:14:07.008 PST [33808] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16753::oid;
2023-12-10 13:14:07.010 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:14:07.011 PST [33808] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:14:07.016 PST [33808] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:14:07.018 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:14:07.019 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:14:07.020 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:14:07.022 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:14:07.023 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:14:07.025 PST [33808] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:14:07.025 PST [33808] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:14:07.026 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:14:07.029 PST [33808] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 13:14:07.030 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16761::oid
	    AND a2.attnum=1
	
2023-12-10 13:14:07.031 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16761::oid
2023-12-10 13:14:07.031 PST [33808] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:14:07.034 PST [33808] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:14:07.035 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 13:14:07.035 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 13:14:07.038 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:14:07.039 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:14:07.040 PST [33808] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 13:14:07.040 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:14:07.044 PST [33808] LOG:  statement: ALTER TABLE IF EXISTS public.orders
	    ADD COLUMN order_id integer;
2023-12-10 13:14:07.053 PST [33808] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16753::oid;
	
2023-12-10 13:14:42.212 PST [34169] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:14:42.212 PST [34169] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 13:14:47.891 PST [34177] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:14:47.901 PST [34177] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:14:47.901 PST [34177] DETAIL:  parameters: $1 = '4'
2023-12-10 13:14:55.259 PST [34183] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:14:55.266 PST [34183] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:14:55.266 PST [34183] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:14:55.274 PST [34184] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:14:55.274 PST [34184] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:14:55.283 PST [34185] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:14:55.284 PST [34185] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:14:55.284 PST [34185] DETAIL:  parameters: $1 = '12', $2 = 'Create Your Own Crustless - Keto Friendly (Baking Required)', $3 = '1', $4 = '9', $5 = '2'
2023-12-10 13:14:55.285 PST [34185] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:14:55.285 PST [34185] DETAIL:  parameters: $1 = '12', $2 = 'Scratch-Made 5-Cheese Bread (Baking Required)', $3 = '1', $4 = '5', $5 = '2'
2023-12-10 13:14:55.285 PST [34185] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:14:56.590 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:14:57.317 PST [36662] LOG:  checkpoint complete: wrote 8 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.709 s, sync=0.011 s, total=0.727 s; sync files=8, longest=0.006 s, average=0.002 s; distance=37 kB, estimate=10435 kB
2023-12-10 13:21:32.132 PST [34367] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:21:32.137 PST [34367] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:21:32.137 PST [34367] DETAIL:  parameters: $1 = '4'
2023-12-10 13:21:41.907 PST [34376] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:21:41.909 PST [34376] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:21:41.909 PST [34376] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:21:41.914 PST [34377] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:21:41.914 PST [34377] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:21:41.923 PST [34378] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:21:41.924 PST [34378] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:21:41.924 PST [34378] DETAIL:  parameters: $1 = '13', $2 = 'Cowboy - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '2'
2023-12-10 13:21:41.925 PST [34378] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:21:41.925 PST [34378] DETAIL:  parameters: $1 = '13', $2 = 'Gourmet Vegetarian - Keto Friendly (Baking Required)', $3 = '2', $4 = '10.99', $5 = '2'
2023-12-10 13:21:41.925 PST [34378] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:22:41.127 PST [33808] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 13:22:41.143 PST [33808] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 13:22:41.145 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16744::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16744::oid ORDER BY rel.relname;
2023-12-10 13:22:41.159 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16744::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16744::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:22:41.161 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16744::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16744::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:22:41.163 PST [33808] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16744::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:22:41.168 PST [33808] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700,1043)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700,1043)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:22:41.170 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:22:41.171 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:22:41.172 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:22:41.173 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:22:41.174 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16744::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:22:41.175 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16744::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:22:41.177 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16744::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:22:41.179 PST [33808] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16744::oid
	ORDER BY conname
2023-12-10 13:22:41.181 PST [33808] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16744::oid
	
2023-12-10 13:22:41.181 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16744::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:22:42.522 PST [33808] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:22:42.540 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:22:42.556 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:22:42.576 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:22:42.592 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:24:12.126 PST [33808] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 13:24:12.131 PST [33808] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 13:24:12.132 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 13:24:12.143 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:12.144 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:12.145 PST [33808] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:24:12.152 PST [33808] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:24:12.153 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:12.154 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:12.155 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:12.156 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:12.157 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:12.158 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:24:12.161 PST [33808] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:24:12.162 PST [33808] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:24:12.163 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:24:12.165 PST [33808] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 13:24:12.167 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16761::oid
	    AND a2.attnum=1
	
2023-12-10 13:24:12.167 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16761::oid
2023-12-10 13:24:12.170 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:24:12.171 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:24:12.171 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 13:24:12.172 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 13:24:12.173 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:24:12.173 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:24:12.173 PST [33808] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 13:24:12.174 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:24:13.245 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:24:13.333 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:24:13.355 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:24:13.370 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:24:13.387 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:24:40.465 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 13:24:40.472 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:40.472 PST [33808] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16739)ORDER BY
	    pid, locktype
2023-12-10 13:24:40.473 PST [33808] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16753::oid;
	
2023-12-10 13:24:40.474 PST [33808] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-10 13:24:40.474 PST [33808] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16753::oid;
2023-12-10 13:24:40.475 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:40.476 PST [33808] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:24:40.484 PST [33808] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:24:40.485 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:40.486 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:40.487 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:40.488 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:40.489 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:24:40.490 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:24:40.492 PST [33808] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:24:40.493 PST [33808] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:24:40.494 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:24:40.496 PST [33808] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 13:24:40.498 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16761::oid
	    AND a2.attnum=1
	
2023-12-10 13:24:40.498 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16761::oid
2023-12-10 13:24:40.499 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:24:40.500 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:24:40.500 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 13:24:40.500 PST [33808] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 13:24:40.501 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:24:40.502 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:24:40.502 PST [33808] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 13:24:40.503 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:24:40.548 PST [33808] LOG:  statement: ALTER TABLE IF EXISTS public.orders DROP COLUMN IF EXISTS restaurant_id;
	ALTER TABLE IF EXISTS public.orders DROP CONSTRAINT IF EXISTS orders_restaurant_id_fkey;
2023-12-10 13:24:40.551 PST [33808] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16753::oid;
	
2023-12-10 13:24:56.336 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:24:57.200 PST [36662] LOG:  checkpoint complete: wrote 9 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.846 s, sync=0.010 s, total=0.864 s; sync files=8, longest=0.004 s, average=0.002 s; distance=38 kB, estimate=9395 kB
2023-12-10 13:25:13.236 PST [34486] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:13.238 PST [34486] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:25:13.238 PST [34486] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:25:13.246 PST [34487] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:13.246 PST [34487] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:25:13.255 PST [34488] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:13.256 PST [34488] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:25:13.256 PST [34488] DETAIL:  parameters: $1 = '14', $2 = 'Create Your Own Crustless - Keto Friendly (Baking Required)', $3 = '1', $4 = '9', $5 = '2'
2023-12-10 13:25:13.257 PST [34488] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:25:13.257 PST [34488] DETAIL:  parameters: $1 = '14', $2 = 'Scratch-Made 5-Cheese Bread (Baking Required)', $3 = '1', $4 = '5', $5 = '2'
2023-12-10 13:25:13.257 PST [34488] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:25:15.992 PST [34491] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:15.997 PST [34491] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:25:15.997 PST [34491] DETAIL:  parameters: $1 = '4'
2023-12-10 13:25:23.922 PST [34496] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:23.924 PST [34496] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:25:23.924 PST [34496] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:25:23.931 PST [34497] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:23.931 PST [34497] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:25:23.938 PST [34498] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:23.940 PST [34498] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:25:23.940 PST [34498] DETAIL:  parameters: $1 = '15', $2 = 'Cowboy - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '2'
2023-12-10 13:25:23.940 PST [34498] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:25:23.940 PST [34498] DETAIL:  parameters: $1 = '15', $2 = 'Create Your Own Crustless - Keto Friendly (Baking Required)', $3 = '3', $4 = '9', $5 = '2'
2023-12-10 13:25:23.941 PST [34498] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:25:56.144 PST [34515] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:56.147 PST [34515] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:25:56.147 PST [34515] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:25:56.152 PST [34516] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:56.152 PST [34516] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:25:56.160 PST [34517] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:56.161 PST [34517] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:25:56.161 PST [34517] DETAIL:  parameters: $1 = '16', $2 = 'Cowboy - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '2'
2023-12-10 13:25:56.161 PST [34517] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:25:56.161 PST [34517] DETAIL:  parameters: $1 = '16', $2 = 'Create Your Own Crustless - Keto Friendly (Baking Required)', $3 = '3', $4 = '9', $5 = '2'
2023-12-10 13:25:56.162 PST [34517] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:25:58.059 PST [34520] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:25:58.061 PST [34520] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:25:58.061 PST [34520] DETAIL:  parameters: $1 = '4'
2023-12-10 13:26:01.775 PST [34522] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:01.777 PST [34522] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:26:01.777 PST [34522] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:26:01.784 PST [34523] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:01.784 PST [34523] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:26:01.791 PST [34524] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:01.793 PST [34524] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:26:01.793 PST [34524] DETAIL:  parameters: $1 = '17', $2 = 'Cowboy - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '2'
2023-12-10 13:26:01.793 PST [34524] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:26:37.328 PST [34569] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:37.329 PST [34569] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 13:26:41.936 PST [34574] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:41.938 PST [34574] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:26:41.938 PST [34574] DETAIL:  parameters: $1 = '3'
2023-12-10 13:26:47.792 PST [34580] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:47.794 PST [34580] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:26:47.794 PST [34580] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:26:47.800 PST [34581] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:47.801 PST [34581] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:26:47.808 PST [34582] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:26:47.810 PST [34582] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:26:47.810 PST [34582] DETAIL:  parameters: $1 = '18', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '1', $4 = '10.78', $5 = '2'
2023-12-10 13:26:47.810 PST [34582] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:26:47.810 PST [34582] DETAIL:  parameters: $1 = '18', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:26:47.810 PST [34582] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:27:16.754 PST [34596] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:27:16.757 PST [34596] LOG:  statement: SELECT version()
2023-12-10 13:27:16.758 PST [34596] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:27:16.760 PST [34596] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:27:16.763 PST [34596] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:27:16.768 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16740;
	
2023-12-10 13:27:16.885 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'address' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'address' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:16.888 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'address' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'address' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:16.891 PST [34596] LOG:  statement: SELECT * FROM public.address
	ORDER BY id ASC 
2023-12-10 13:27:17.131 PST [34596] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16740::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:27:17.155 PST [34596] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:27:17.155 PST [34596] DETAIL:  parameters: $1 = '{23,23,1043,1043}'
2023-12-10 13:27:23.426 PST [34599] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:27:23.429 PST [34599] LOG:  statement: SELECT version()
2023-12-10 13:27:23.430 PST [34599] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:27:23.432 PST [34599] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:27:23.433 PST [34599] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:27:23.438 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16744;
	
2023-12-10 13:27:23.550 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:23.553 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:23.556 PST [34599] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-10 13:27:23.804 PST [34599] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16744::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:27:23.813 PST [34599] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:27:23.813 PST [34599] DETAIL:  parameters: $1 = '{23,23,1700,23,1043}'
2023-12-10 13:27:32.989 PST [34603] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:27:32.991 PST [34603] LOG:  statement: SELECT version()
2023-12-10 13:27:32.992 PST [34603] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:27:32.994 PST [34603] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:27:32.995 PST [34603] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:27:33.000 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16747;
	
2023-12-10 13:27:33.119 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:33.126 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menus' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menus' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:33.132 PST [34603] LOG:  statement: SELECT * FROM public.menus
	ORDER BY id ASC 
2023-12-10 13:27:33.307 PST [34603] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16747::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:27:33.316 PST [34603] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:27:33.316 PST [34603] DETAIL:  parameters: $1 = '{23,23,25,1043,25,1700}'
2023-12-10 13:27:40.703 PST [34607] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:27:40.706 PST [34607] LOG:  statement: SELECT version()
2023-12-10 13:27:40.707 PST [34607] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:27:40.709 PST [34607] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:27:40.710 PST [34607] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:27:40.714 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16757;
	
2023-12-10 13:27:40.822 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:40.825 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:40.831 PST [34607] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 13:27:41.083 PST [34607] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16757::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:27:41.092 PST [34607] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:27:41.092 PST [34607] DETAIL:  parameters: $1 = '{23,23,1700,1700}'
2023-12-10 13:27:50.411 PST [34611] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:27:50.414 PST [34611] LOG:  statement: SELECT version()
2023-12-10 13:27:50.415 PST [34611] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:27:50.417 PST [34611] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:27:50.419 PST [34611] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:27:50.423 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16761;
	
2023-12-10 13:27:50.542 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'restaurants' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'restaurants' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:50.545 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'restaurants' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'restaurants' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:50.547 PST [34611] LOG:  statement: SELECT * FROM public.restaurants
	ORDER BY id ASC 
2023-12-10 13:27:50.884 PST [34611] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16761::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:27:50.893 PST [34611] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:27:50.893 PST [34611] DETAIL:  parameters: $1 = '{23,1043,1043,25}'
2023-12-10 13:27:56.309 PST [34615] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:27:56.311 PST [34615] LOG:  statement: SELECT version()
2023-12-10 13:27:56.312 PST [34615] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:27:56.314 PST [34615] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:27:56.316 PST [34615] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:27:56.320 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16766;
	
2023-12-10 13:27:56.430 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:56.433 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'users' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'users' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:27:56.437 PST [34615] LOG:  statement: SELECT * FROM public.users
	ORDER BY user_id ASC 
2023-12-10 13:27:56.626 PST [34615] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16766::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:27:56.636 PST [34615] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:27:56.636 PST [34615] DETAIL:  parameters: $1 = '{23,1043,1043,1043,1043}'
2023-12-10 13:28:58.370 PST [34643] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:28:58.372 PST [34643] LOG:  statement: SELECT version()
2023-12-10 13:28:58.373 PST [34643] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:28:58.375 PST [34643] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:28:58.377 PST [34643] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:28:58.381 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16744;
	
2023-12-10 13:28:58.593 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:28:58.596 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:28:58.603 PST [34643] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-10 13:28:58.744 PST [34643] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16744::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:28:58.778 PST [34643] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:28:58.778 PST [34643] DETAIL:  parameters: $1 = '{23,23,1700,23,1043}'
2023-12-10 13:29:56.209 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:29:57.660 PST [36662] LOG:  checkpoint complete: wrote 15 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.434 s, sync=0.008 s, total=1.451 s; sync files=13, longest=0.006 s, average=0.001 s; distance=66 kB, estimate=8463 kB
2023-12-10 13:31:08.200 PST [34728] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:08.202 PST [34728] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:31:08.202 PST [34728] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:31:08.207 PST [34729] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:08.208 PST [34729] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:31:08.217 PST [34730] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:08.218 PST [34730] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:31:08.218 PST [34730] DETAIL:  parameters: $1 = '19', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '1', $4 = '10.78', $5 = '2'
2023-12-10 13:31:08.219 PST [34730] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:31:08.219 PST [34730] DETAIL:  parameters: $1 = '19', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:31:08.219 PST [34730] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:31:10.189 PST [34733] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:10.191 PST [34733] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:31:10.191 PST [34733] DETAIL:  parameters: $1 = '3'
2023-12-10 13:31:19.613 PST [34740] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:19.615 PST [34740] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:31:19.615 PST [34740] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:31:19.622 PST [34741] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:19.622 PST [34741] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:31:19.629 PST [34742] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:19.631 PST [34742] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:31:19.631 PST [34742] DETAIL:  parameters: $1 = '20', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:31:19.631 PST [34742] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:31:19.631 PST [34742] DETAIL:  parameters: $1 = '20', $2 = 'Cheesesteak Hoagie - $14.38Cheesesteak Hoagie', $3 = '3', $4 = '14.38', $5 = '2'
2023-12-10 13:31:19.632 PST [34742] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:31:55.018 PST [34770] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:31:55.020 PST [34770] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:31:55.020 PST [34770] DETAIL:  parameters: $1 = '3'
2023-12-10 13:32:16.468 PST [34780] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:32:16.470 PST [34780] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:32:16.470 PST [34780] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:32:16.477 PST [34781] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:32:16.477 PST [34781] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:32:16.486 PST [34782] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:32:16.488 PST [34782] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:32:16.488 PST [34782] DETAIL:  parameters: $1 = '21', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '1', $4 = '10.78', $5 = '2'
2023-12-10 13:32:16.488 PST [34782] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:32:16.488 PST [34782] DETAIL:  parameters: $1 = '21', $2 = 'BBQ Chicken Cheesesteak - $13.18BBQ Chicken Cheesesteak', $3 = '1', $4 = '13.18', $5 = '2'
2023-12-10 13:32:16.489 PST [34782] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:33:45.556 PST [34846] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:33:45.558 PST [34846] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:33:45.558 PST [34846] DETAIL:  parameters: $1 = '3'
2023-12-10 13:33:55.530 PST [34853] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:33:55.534 PST [34853] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:33:55.534 PST [34853] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:33:55.540 PST [34854] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:33:55.541 PST [34854] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:33:55.548 PST [34855] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:33:55.550 PST [34855] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:33:55.550 PST [34855] DETAIL:  parameters: $1 = '22', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:33:55.550 PST [34855] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:33:55.550 PST [34855] DETAIL:  parameters: $1 = '22', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '3', $4 = '10.78', $5 = '2'
2023-12-10 13:33:55.551 PST [34855] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:33:55.570 PST [34856] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:33:55.571 PST [34856] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 13:33:55.571 PST [34856] DETAIL:  parameters: $1 = '22'
2023-12-10 13:34:33.325 PST [34883] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:34:33.327 PST [34883] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 13:34:33.327 PST [34883] DETAIL:  parameters: $1 = '22'
2023-12-10 13:34:35.501 PST [34884] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:34:35.503 PST [34884] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 13:34:35.503 PST [34884] DETAIL:  parameters: $1 = '22'
2023-12-10 13:34:37.611 PST [34888] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:34:37.613 PST [34888] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:34:37.613 PST [34888] DETAIL:  parameters: $1 = '3'
2023-12-10 13:34:47.047 PST [34894] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:34:47.051 PST [34894] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:34:47.051 PST [34894] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:34:47.060 PST [34895] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:34:47.061 PST [34895] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:34:47.072 PST [34896] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:34:47.074 PST [34896] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:34:47.074 PST [34896] DETAIL:  parameters: $1 = '23', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '1', $4 = '10.78', $5 = '2'
2023-12-10 13:34:47.075 PST [34896] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:34:47.075 PST [34896] DETAIL:  parameters: $1 = '23', $2 = 'Loaded Cheesesteak', $3 = '4', $4 = '14.38', $5 = '2'
2023-12-10 13:34:47.075 PST [34896] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:34:47.098 PST [34897] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:34:47.101 PST [34897] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 13:34:47.101 PST [34897] DETAIL:  parameters: $1 = '23'
2023-12-10 13:34:56.670 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:34:56.902 PST [36662] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.209 s, sync=0.010 s, total=0.233 s; sync files=3, longest=0.006 s, average=0.003 s; distance=13 kB, estimate=7618 kB
2023-12-10 13:37:53.758 PST [34981] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:37:53.760 PST [34981] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 13:37:53.760 PST [34981] DETAIL:  parameters: $1 = '23'
2023-12-10 13:37:54.943 PST [34983] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:37:54.945 PST [34983] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 13:37:54.945 PST [34983] DETAIL:  parameters: $1 = '23'
2023-12-10 13:37:56.630 PST [34986] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:37:56.633 PST [34986] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:37:56.633 PST [34986] DETAIL:  parameters: $1 = '3'
2023-12-10 13:38:05.968 PST [34994] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:05.971 PST [34994] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:38:05.971 PST [34994] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:38:05.977 PST [34995] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:05.977 PST [34995] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:38:05.984 PST [34996] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:05.986 PST [34996] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:38:05.986 PST [34996] DETAIL:  parameters: $1 = '24', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:38:05.987 PST [34996] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:38:05.987 PST [34996] DETAIL:  parameters: $1 = '24', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '13', $4 = '10.78', $5 = '2'
2023-12-10 13:38:05.987 PST [34996] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:38:06.003 PST [34997] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:06.005 PST [34997] LOG:  execute <unnamed>: SELECT item_name, qty, price FROM menu_items WHERE id = $1
2023-12-10 13:38:06.005 PST [34997] DETAIL:  parameters: $1 = '24'
2023-12-10 13:38:30.050 PST [35015] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:30.052 PST [35015] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:38:30.052 PST [35015] DETAIL:  parameters: $1 = '3'
2023-12-10 13:38:37.254 PST [35020] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:37.256 PST [35020] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:38:37.256 PST [35020] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:38:37.263 PST [35021] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:37.263 PST [35021] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:38:37.273 PST [35022] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:37.274 PST [35022] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:38:37.274 PST [35022] DETAIL:  parameters: $1 = '25', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:38:37.275 PST [35022] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:38:37.275 PST [35022] DETAIL:  parameters: $1 = '25', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '11', $4 = '10.78', $5 = '2'
2023-12-10 13:38:37.275 PST [35022] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:38:37.293 PST [35023] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:38:37.295 PST [35023] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 13:38:37.295 PST [35023] DETAIL:  parameters: $1 = '25'
2023-12-10 13:39:56.911 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:39:57.135 PST [36662] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.204 s, sync=0.010 s, total=0.225 s; sync files=3, longest=0.009 s, average=0.004 s; distance=13 kB, estimate=6857 kB
2023-12-10 13:40:33.667 PST [35087] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:40:33.670 PST [35087] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:40:33.670 PST [35087] DETAIL:  parameters: $1 = '3'
2023-12-10 13:40:41.651 PST [35092] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:40:41.654 PST [35092] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:40:41.654 PST [35092] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:40:41.661 PST [35093] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:40:41.661 PST [35093] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:40:41.669 PST [35094] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:40:41.671 PST [35094] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:40:41.671 PST [35094] DETAIL:  parameters: $1 = '26', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:40:41.672 PST [35094] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:40:41.672 PST [35094] DETAIL:  parameters: $1 = '26', $2 = 'Cheesesteak Hoagie - $14.38Cheesesteak Hoagie', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:40:41.672 PST [35094] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:40:41.672 PST [35094] DETAIL:  parameters: $1 = '26', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '1', $4 = '10.78', $5 = '2'
2023-12-10 13:40:41.672 PST [35094] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:40:41.689 PST [35095] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:40:41.691 PST [35095] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 13:40:41.691 PST [35095] DETAIL:  parameters: $1 = '26'
2023-12-10 13:40:41.692 PST [35095] ERROR:  column "order_id" of relation "orders" does not exist at character 30
2023-12-10 13:40:41.692 PST [35095] STATEMENT:  INSERT INTO orders (user_id, order_id, order_total) VALUES ($1, $2, $3)
2023-12-10 13:42:13.987 PST [35135] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:42:13.989 PST [35135] LOG:  statement: SELECT version()
2023-12-10 13:42:13.991 PST [35135] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:42:13.993 PST [35135] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:42:13.995 PST [35135] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:42:14.000 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16753;
	
2023-12-10 13:42:14.106 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:42:14.109 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:42:14.111 PST [35135] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 13:42:14.229 PST [35135] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:42:14.249 PST [35135] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:42:14.249 PST [35135] DETAIL:  parameters: $1 = '{23,23,1700,23}'
2023-12-10 13:43:28.284 PST [35177] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:28.287 PST [35177] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:43:28.287 PST [35177] DETAIL:  parameters: $1 = '3'
2023-12-10 13:43:35.466 PST [35184] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:35.470 PST [35184] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:43:35.470 PST [35184] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:43:35.478 PST [35185] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:35.478 PST [35185] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:43:35.486 PST [35186] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:35.488 PST [35186] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:43:35.488 PST [35186] DETAIL:  parameters: $1 = '27', $2 = 'Classic Cheesesteak', $3 = '1', $4 = '11.98', $5 = '2'
2023-12-10 13:43:35.488 PST [35186] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:43:35.488 PST [35186] DETAIL:  parameters: $1 = '27', $2 = 'Cheesesteak Hoagie - $14.38Cheesesteak Hoagie', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:43:35.488 PST [35186] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:43:35.505 PST [35187] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:35.506 PST [35187] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 13:43:35.506 PST [35187] DETAIL:  parameters: $1 = '27'
2023-12-10 13:43:35.507 PST [35187] ERROR:  syntax error at or near ")" at character 53
2023-12-10 13:43:35.507 PST [35187] STATEMENT:  INSERT INTO orders (user_id,  order_total, order_id,) VALUES ($1, $2, $3)
2023-12-10 13:43:51.179 PST [35204] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:51.182 PST [35204] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:43:51.182 PST [35204] DETAIL:  parameters: $1 = '3'
2023-12-10 13:43:55.886 PST [35209] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:55.890 PST [35209] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:43:55.890 PST [35209] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:43:55.897 PST [35210] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:55.897 PST [35210] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:43:55.905 PST [35211] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:55.906 PST [35211] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:43:55.906 PST [35211] DETAIL:  parameters: $1 = '28', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:43:55.907 PST [35211] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:43:55.907 PST [35211] DETAIL:  parameters: $1 = '28', $2 = 'Cheesesteak Hoagie - $14.38Cheesesteak Hoagie', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:43:55.907 PST [35211] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:43:55.923 PST [35212] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:43:55.925 PST [35212] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 13:43:55.925 PST [35212] DETAIL:  parameters: $1 = '28'
2023-12-10 13:43:55.926 PST [35212] ERROR:  column "order_id" of relation "orders" does not exist at character 44
2023-12-10 13:43:55.926 PST [35212] STATEMENT:  INSERT INTO orders (user_id,  order_total, order_id) VALUES ($1, $2, $3)
2023-12-10 13:44:50.744 PST [35234] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:44:50.746 PST [35234] LOG:  statement: SELECT version()
2023-12-10 13:44:50.747 PST [35234] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:44:50.749 PST [35234] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:44:50.751 PST [35234] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:44:56.038 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:44:56.463 PST [36662] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.414 s, sync=0.003 s, total=0.425 s; sync files=5, longest=0.002 s, average=0.001 s; distance=18 kB, estimate=6173 kB
2023-12-10 13:45:48.054 PST [35234] LOG:  statement: INSERT INTO orders (user_id, order_total, order_id) VALUES (1, 100, 1);
2023-12-10 13:47:05.869 PST [35364] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:05.869 PST [35364] LOG:  statement: SELECT pg_cancel_backend(33967);
2023-12-10 13:47:06.305 PST [30724] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:06.317 PST [30724] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:07.326 PST [35365] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:07.326 PST [35365] LOG:  statement: SELECT pg_cancel_backend(33971);
2023-12-10 13:47:08.306 PST [30724] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:08.315 PST [30724] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:08.328 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:08.807 PST [35367] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:08.807 PST [35367] LOG:  statement: SELECT pg_cancel_backend(34596);
2023-12-10 13:47:10.232 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:10.249 PST [35369] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:10.250 PST [35369] LOG:  statement: SELECT pg_cancel_backend(34599);
2023-12-10 13:47:10.465 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:10.468 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:11.668 PST [35370] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:11.668 PST [35370] LOG:  statement: SELECT pg_cancel_backend(34603);
2023-12-10 13:47:12.081 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:13.309 PST [35371] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:13.310 PST [35371] LOG:  statement: SELECT pg_cancel_backend(34607);
2023-12-10 13:47:14.348 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:14.355 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:14.978 PST [35373] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:14.978 PST [35373] LOG:  statement: SELECT pg_cancel_backend(34611);
2023-12-10 13:47:16.301 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:16.380 PST [35375] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:16.380 PST [35375] LOG:  statement: SELECT pg_cancel_backend(34615);
2023-12-10 13:47:18.121 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:18.138 PST [35376] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:18.139 PST [35376] LOG:  statement: SELECT pg_cancel_backend(34643);
2023-12-10 13:47:18.324 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:19.442 PST [35378] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:47:19.443 PST [35378] LOG:  statement: SELECT pg_cancel_backend(35135);
2023-12-10 13:47:19.519 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 13:47:27.101 PST [35381] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:47:27.104 PST [35381] LOG:  statement: SELECT version()
2023-12-10 13:47:27.105 PST [35381] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:47:27.107 PST [35381] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:47:27.109 PST [35381] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:47:27.113 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16753;
	
2023-12-10 13:47:27.269 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:47:27.296 PST [33808] LOG:  execute _pg3_4: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:47:27.300 PST [35381] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 13:47:27.428 PST [35381] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:47:27.437 PST [35381] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:47:27.437 PST [35381] DETAIL:  parameters: $1 = '{23,23,1700,23}'
2023-12-10 13:49:15.086 PST [35433] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:49:15.089 PST [35433] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:49:15.089 PST [35433] DETAIL:  parameters: $1 = '3'
2023-12-10 13:49:21.867 PST [35438] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:49:21.871 PST [35438] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:49:21.871 PST [35438] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:49:21.877 PST [35439] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:49:21.878 PST [35439] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:49:21.887 PST [35440] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:49:21.889 PST [35440] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:49:21.889 PST [35440] DETAIL:  parameters: $1 = '29', $2 = 'Classic Cheesesteak', $3 = '1', $4 = '11.98', $5 = '2'
2023-12-10 13:49:21.889 PST [35440] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:49:21.889 PST [35440] DETAIL:  parameters: $1 = '29', $2 = 'Philadelphia Cheesesteak - $10.78Philadelphia Cheesesteak', $3 = '1', $4 = '10.78', $5 = '2'
2023-12-10 13:49:21.891 PST [35440] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:49:21.907 PST [35441] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:49:21.911 PST [35441] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 13:49:21.911 PST [35441] DETAIL:  parameters: $1 = '29'
2023-12-10 13:49:21.912 PST [35441] ERROR:  column "order_id" of relation "orders" does not exist at character 43
2023-12-10 13:49:21.912 PST [35441] STATEMENT:  INSERT INTO orders (user_id, order_total, order_id) VALUES ($1, $2, $3)
2023-12-10 13:49:56.460 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:49:57.306 PST [36662] LOG:  checkpoint complete: wrote 9 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.829 s, sync=0.008 s, total=0.847 s; sync files=7, longest=0.006 s, average=0.002 s; distance=17 kB, estimate=5558 kB
2023-12-10 13:51:41.321 PST [35517] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 13:51:41.323 PST [35517] LOG:  statement: SELECT version()
2023-12-10 13:51:41.324 PST [35517] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 13:51:41.327 PST [35517] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 13:51:41.329 PST [35517] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 13:51:41.337 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16757;
	
2023-12-10 13:51:42.227 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:51:42.230 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 13:51:42.240 PST [35517] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 13:51:42.463 PST [35517] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16757::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 13:51:42.476 PST [35517] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 13:51:42.476 PST [35517] DETAIL:  parameters: $1 = '{23,23,1700,1700}'
2023-12-10 13:54:50.590 PST [33808] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 13:54:50.593 PST [33808] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 13:54:50.600 PST [33808] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16757::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16757::oid ORDER BY rel.relname;
2023-12-10 13:54:50.607 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16757::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16757::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:54:50.609 PST [33808] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16757::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16757::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:54:50.611 PST [33808] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16757::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:54:50.618 PST [33808] LOG:  execute _pg3_5: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:54:50.619 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:54:50.620 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:54:50.621 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:54:50.623 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16757::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:54:50.624 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16757::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:54:50.628 PST [33808] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16783 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:54:50.629 PST [33808] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16783::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:54:50.631 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16757::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:54:50.633 PST [33808] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16757::oid
	ORDER BY conname
2023-12-10 13:54:50.635 PST [33808] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16757::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16761::oid
	    AND a2.attnum=1
	
2023-12-10 13:54:50.637 PST [33808] LOG:  execute _pg3_6: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16761::oid
2023-12-10 13:54:50.638 PST [33808] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16757::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16757::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16757::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16757::oid
	   AND conname IS NULL
2023-12-10 13:54:50.642 PST [33808] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16783 , 1 , true) AS column
	
2023-12-10 13:54:50.642 PST [33808] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16757::oid
	
2023-12-10 13:54:50.644 PST [33808] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16757::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:54:51.481 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:54:51.512 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:54:51.532 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:54:51.555 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:54:56.302 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:54:56.421 PST [36662] LOG:  checkpoint complete: wrote 1 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.101 s, sync=0.007 s, total=0.119 s; sync files=1, longest=0.007 s, average=0.007 s; distance=8 kB, estimate=5003 kB
2023-12-10 13:55:02.730 PST [33808] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 13:55:02.735 PST [33808] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 13:55:02.743 PST [33808] LOG:  execute _pg3_7: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 13:55:02.746 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:55:02.747 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:55:02.753 PST [33808] LOG:  execute _pg3_8: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:55:02.755 PST [33808] LOG:  execute _pg3_5: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:55:02.757 PST [33808] LOG:  execute _pg3_9: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:55:02.758 PST [33808] LOG:  execute _pg3_10: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:55:02.760 PST [33808] LOG:  execute _pg3_11: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:55:02.760 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:55:02.763 PST [33808] LOG:  execute _pg3_12: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:55:02.764 PST [33808] LOG:  execute _pg3_13: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:55:02.765 PST [33808] LOG:  execute _pg3_14: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:55:02.768 PST [33808] LOG:  execute _pg3_15: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:55:02.770 PST [33808] LOG:  execute _pg3_16: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 13:55:02.771 PST [33808] LOG:  execute _pg3_17: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 13:55:02.771 PST [33808] LOG:  execute _pg3_18: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 13:55:02.774 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:55:02.775 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:55:02.776 PST [33808] LOG:  execute _pg3_19: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 13:55:02.779 PST [33808] LOG:  execute _pg3_20: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:55:03.698 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:55:03.717 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:55:03.730 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:55:03.744 PST [33808] LOG:  execute _pg3_3: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 13:57:29.560 PST [33808] LOG:  execute _pg3_7: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 13:57:29.563 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:57:29.564 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:57:29.566 PST [33808] LOG:  execute _pg3_8: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 13:57:29.568 PST [33808] LOG:  execute _pg3_5: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 13:57:29.569 PST [33808] LOG:  execute _pg3_9: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:57:29.570 PST [33808] LOG:  execute _pg3_10: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:57:29.570 PST [33808] LOG:  execute _pg3_11: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:57:29.571 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 13:57:29.573 PST [33808] LOG:  execute _pg3_12: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 13:57:29.573 PST [33808] LOG:  execute _pg3_13: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 13:57:29.574 PST [33808] LOG:  execute _pg3_14: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 13:57:29.575 PST [33808] LOG:  execute _pg3_15: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 13:57:29.575 PST [33808] LOG:  execute _pg3_16: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 13:57:29.576 PST [33808] LOG:  execute _pg3_17: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 13:57:29.577 PST [33808] LOG:  execute _pg3_18: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 13:57:29.578 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 13:57:29.578 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 13:57:29.579 PST [33808] LOG:  execute _pg3_19: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 13:57:29.580 PST [33808] LOG:  execute _pg3_20: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 13:59:33.171 PST [35719] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:59:33.176 PST [35719] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 13:59:33.176 PST [35719] DETAIL:  parameters: $1 = '3'
2023-12-10 13:59:38.710 PST [35724] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:59:38.714 PST [35724] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 13:59:38.714 PST [35724] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 13:59:38.721 PST [35725] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:59:38.722 PST [35725] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 13:59:38.734 PST [35726] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:59:38.736 PST [35726] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:59:38.736 PST [35726] DETAIL:  parameters: $1 = '30', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:59:38.738 PST [35726] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 13:59:38.738 PST [35726] DETAIL:  parameters: $1 = '30', $2 = 'Cheesesteak Hoagie - $14.38Cheesesteak Hoagie', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 13:59:38.739 PST [35726] LOG:  execute <unnamed>: COMMIT
2023-12-10 13:59:38.754 PST [35727] LOG:  execute <unnamed>: BEGIN
2023-12-10 13:59:38.756 PST [35727] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 13:59:38.756 PST [35727] DETAIL:  parameters: $1 = '30'
2023-12-10 13:59:38.757 PST [35727] ERROR:  column "order_id" of relation "orders" does not exist at character 43
2023-12-10 13:59:38.757 PST [35727] STATEMENT:  INSERT INTO orders (user_id, order_total, order_id) VALUES ($1, $2, $3)
2023-12-10 13:59:56.418 PST [36662] LOG:  checkpoint starting: time
2023-12-10 13:59:56.533 PST [36662] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.102 s, sync=0.007 s, total=0.116 s; sync files=2, longest=0.006 s, average=0.004 s; distance=0 kB, estimate=4502 kB
2023-12-10 14:02:00.379 PST [35800] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:02:00.381 PST [35800] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 14:02:00.381 PST [35800] DETAIL:  parameters: $1 = '3'
2023-12-10 14:02:05.963 PST [35806] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:02:05.966 PST [35806] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:02:05.966 PST [35806] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:02:05.974 PST [35807] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:02:05.974 PST [35807] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 14:02:05.983 PST [35808] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:02:05.984 PST [35808] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:02:05.984 PST [35808] DETAIL:  parameters: $1 = '31', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 14:02:05.984 PST [35808] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:02:06.007 PST [35809] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:02:06.009 PST [35809] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 14:02:06.009 PST [35809] DETAIL:  parameters: $1 = '31'
2023-12-10 14:02:06.010 PST [35809] ERROR:  column "order_id" of relation "orders" does not exist at character 43
2023-12-10 14:02:06.010 PST [35809] STATEMENT:  INSERT INTO orders (user_id, order_total, order_id) VALUES ($1, $2, $3)
2023-12-10 14:03:04.915 PST [33808] LOG:  execute _pg3_7: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 14:03:04.917 PST [33808] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16739)ORDER BY
	    pid, locktype
2023-12-10 14:03:04.919 PST [33808] LOG:  statement: TRUNCATE TABLE public.orders;
2023-12-10 14:03:17.620 PST [33808] LOG:  execute _pg3_7: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 14:03:17.624 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:03:17.625 PST [33808] LOG:  execute _pg3_0: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16753::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:03:17.629 PST [33808] LOG:  execute _pg3_8: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16753::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 14:03:17.631 PST [33808] LOG:  execute _pg3_5: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 14:03:17.632 PST [33808] LOG:  execute _pg3_9: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:03:17.633 PST [33808] LOG:  execute _pg3_10: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:03:17.634 PST [33808] LOG:  execute _pg3_11: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:03:17.635 PST [33808] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16753::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:03:17.637 PST [33808] LOG:  execute _pg3_12: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 14:03:17.638 PST [33808] LOG:  execute _pg3_13: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 14:03:17.639 PST [33808] LOG:  execute _pg3_14: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16781::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 14:03:17.642 PST [33808] LOG:  execute _pg3_15: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 14:03:17.644 PST [33808] LOG:  execute _pg3_16: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16753::oid
	ORDER BY conname
2023-12-10 14:03:17.644 PST [33808] LOG:  execute _pg3_17: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16753::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16766::oid
	    AND a2.attnum=1
	
2023-12-10 14:03:17.645 PST [33808] LOG:  execute _pg3_18: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16766::oid
2023-12-10 14:03:17.647 PST [33808] LOG:  execute _pg3_1: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16753::oid
	   AND conname IS NULL
2023-12-10 14:03:17.648 PST [33808] LOG:  execute _pg3_2: SELECT  pg_catalog.pg_get_indexdef(16781 , 1 , true) AS column
	
2023-12-10 14:03:17.649 PST [33808] LOG:  execute _pg3_19: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16753::oid
	
2023-12-10 14:03:17.652 PST [33808] LOG:  execute _pg3_20: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16739::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16753::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 14:03:42.576 PST [33808] LOG:  execute _pg3_7: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16739::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16753::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16753::oid ORDER BY rel.relname;
2023-12-10 14:03:42.578 PST [33808] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16739)ORDER BY
	    pid, locktype
2023-12-10 14:03:42.582 PST [33808] LOG:  statement: DROP TABLE IF EXISTS public.orders CASCADE;
2023-12-10 14:03:42.605 PST [33808] LOG:  execute <unnamed>: DEALLOCATE ALL
2023-12-10 14:03:55.966 PST [33808] LOG:  statement: SELECT c.oid, pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS like_relation
	FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n
	WHERE c.relnamespace=n.oid
	    AND c.relkind IN ('r', 'v', 'f')
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY 1;
2023-12-10 14:03:55.968 PST [33808] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 14:03:55.973 PST [33808] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 14:04:03.427 PST [33808] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:04:56.530 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:04:58.276 PST [36662] LOG:  checkpoint complete: wrote 18 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.734 s, sync=0.007 s, total=1.747 s; sync files=17, longest=0.002 s, average=0.001 s; distance=88 kB, estimate=4061 kB
2023-12-10 14:05:05.269 PST [33808] LOG:  statement: CREATE TABLE public.orders
	(
	    id serial NOT NULL,
	    user_id integer,
	    order_total numeric(255, 2),
	    order_id integer,
	    PRIMARY KEY (id)
	);
	
	
	ALTER TABLE IF EXISTS public.orders
	    OWNER to postgres;
	
	
	
	
	
	
	
	
	
2023-12-10 14:05:05.293 PST [33808] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.relname = 'orders'::text AND nspname = 'public';
	
2023-12-10 14:05:05.294 PST [33808] LOG:  statement: SELECT rel.oid as tid
	FROM pg_catalog.pg_class rel
	WHERE rel.relkind IN ('r','s','t','p')
	AND rel.relnamespace = 2200::oid
	AND rel.relname = 'orders'
2023-12-10 14:05:13.044 PST [35902] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:05:13.044 PST [35902] LOG:  statement: SELECT pg_cancel_backend(35381);
2023-12-10 14:05:14.672 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 14:05:19.712 PST [35906] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:05:19.716 PST [35906] LOG:  statement: SELECT version()
2023-12-10 14:05:19.717 PST [35906] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:05:19.720 PST [35906] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:05:19.723 PST [35906] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:05:19.729 PST [33808] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16826;
	
2023-12-10 14:05:19.854 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:05:19.860 PST [33808] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:05:19.863 PST [35906] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 14:05:19.974 PST [35906] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16826::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:05:19.996 PST [35906] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:05:19.996 PST [35906] DETAIL:  parameters: $1 = '{23,23,1700,23}'
2023-12-10 14:05:23.565 PST [35908] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:05:23.565 PST [35908] LOG:  statement: SELECT pg_cancel_backend(35234);
2023-12-10 14:05:23.568 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 14:06:07.594 PST [35937] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:06:07.596 PST [35937] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 14:06:07.596 PST [35937] DETAIL:  parameters: $1 = '3'
2023-12-10 14:06:11.667 PST [35941] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:06:11.669 PST [35941] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:06:11.669 PST [35941] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:06:11.676 PST [35942] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:06:11.677 PST [35942] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 14:06:11.685 PST [35943] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:06:11.686 PST [35943] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:06:11.686 PST [35943] DETAIL:  parameters: $1 = '32', $2 = 'Chicken Bacon Ranch Cheesesteak - $14.38Chicken Bacon Ranch Cheesesteak', $3 = '1', $4 = '14.38', $5 = '2'
2023-12-10 14:06:11.687 PST [35943] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:06:11.703 PST [35944] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:06:11.705 PST [35944] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 14:06:11.705 PST [35944] DETAIL:  parameters: $1 = '32'
2023-12-10 14:06:11.706 PST [35944] ERROR:  column "order_id" of relation "orders" does not exist at character 41
2023-12-10 14:06:11.706 PST [35944] STATEMENT:  INSERT INTO orders (user_id,order_total,order_id) VALUES ($1, $2, $3)
2023-12-10 14:06:50.220 PST [35964] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:06:50.223 PST [35964] LOG:  statement: SELECT version()
2023-12-10 14:06:50.224 PST [35964] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:06:50.225 PST [35964] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:06:50.227 PST [35964] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:06:54.887 PST [35964] LOG:  statement: INSERT INTO orders (user_id, order_total, order_id) VALUES (2, 14.38, 32);
	
	
2023-12-10 14:09:56.308 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:10:00.071 PST [36662] LOG:  checkpoint complete: wrote 38 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.745 s, sync=0.010 s, total=3.763 s; sync files=33, longest=0.006 s, average=0.001 s; distance=147 kB, estimate=3670 kB
2023-12-10 14:11:23.014 PST [36109] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:23.014 PST [36109] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 14:11:28.204 PST [36116] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:28.207 PST [36116] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 14:11:28.207 PST [36116] DETAIL:  parameters: $1 = '4'
2023-12-10 14:11:30.985 PST [36118] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:30.990 PST [36118] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:11:30.990 PST [36118] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:11:30.995 PST [36119] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:30.995 PST [36119] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 14:11:31.004 PST [36120] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:31.005 PST [36120] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:11:31.005 PST [36120] DETAIL:  parameters: $1 = '33', $2 = 'Gourmet Vegetarian - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '2'
2023-12-10 14:11:31.006 PST [36120] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:11:31.021 PST [36121] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:31.022 PST [36121] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 14:11:31.022 PST [36121] DETAIL:  parameters: $1 = '33'
2023-12-10 14:11:31.023 PST [36121] ERROR:  column "order_id" of relation "orders" does not exist at character 41
2023-12-10 14:11:31.023 PST [36121] STATEMENT:  INSERT INTO orders (user_id,order_total,order_id) VALUES ($1, $2, $3)
2023-12-10 14:11:47.624 PST [36134] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:47.624 PST [36134] LOG:  statement: SELECT pg_cancel_backend(35517);
2023-12-10 14:11:47.638 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 14:11:47.656 PST [36135] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:11:47.656 PST [36135] LOG:  statement: SELECT pg_cancel_backend(35906);
2023-12-10 14:11:47.660 PST [30724] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 14:12:41.485 PST [36190] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:12:41.489 PST [36190] LOG:  statement: SELECT version()
2023-12-10 14:12:41.489 PST [36190] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:12:41.491 PST [36190] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:12:41.493 PST [36190] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:12:41.507 PST [36190] LOG:  statement: SELECT CASE WHEN usesuper
	       THEN pg_catalog.pg_is_in_recovery()
	       ELSE FALSE
	       END as inrecovery,
	       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
	       THEN pg_is_wal_replay_paused()
	       ELSE FALSE
	       END as isreplaypaused
	FROM pg_catalog.pg_user WHERE usename=current_user
2023-12-10 14:12:41.862 PST [36190] LOG:  statement: 
	SELECT
	    has_table_privilege(
	      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
	    ) has_priviledge
	WHERE EXISTS(
	    SELECT has_schema_privilege('pgagent', 'USAGE')
	    WHERE EXISTS(
	        SELECT cl.oid FROM pg_catalog.pg_class cl
	        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
	        WHERE relname='pga_job' AND nspname='pgagent'
	    )
	)
	
2023-12-10 14:12:41.950 PST [36190] LOG:  statement: SELECT
	    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
	    db.datistemplate AS is_template,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner,
	    descr.description
	FROM
	    pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE         db.oid > 16383::OID OR db.datname IN ('postgres', 'edb')
	
	ORDER BY datname;
2023-12-10 14:12:41.989 PST [36190] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:12:42.016 PST [36192] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:12:42.017 PST [36191] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:12:42.022 PST [36191] LOG:  statement: SELECT version()
2023-12-10 14:12:42.022 PST [36192] LOG:  statement: SELECT version()
2023-12-10 14:12:42.023 PST [36192] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:12:42.023 PST [36191] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:12:42.028 PST [36192] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:12:42.028 PST [36191] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:12:42.030 PST [36191] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:12:42.030 PST [36192] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:12:42.347 PST [36191] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-10 14:12:42.426 PST [36191] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-10 14:12:42.642 PST [36191] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-10 14:12:51.690 PST [36196] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:12:51.692 PST [36196] LOG:  statement: SELECT version()
2023-12-10 14:12:51.694 PST [36196] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:12:51.695 PST [36196] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:12:51.697 PST [36196] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:12:51.718 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16694;
	
2023-12-10 14:12:51.849 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:12:51.918 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:12:51.921 PST [36196] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 14:12:52.004 PST [36196] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:12:52.041 PST [36196] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:12:52.041 PST [36196] DETAIL:  parameters: $1 = '{23,23,23,1700}'
2023-12-10 14:13:03.629 PST [36202] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 14:13:06.060 PST [36206] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 14:13:06.092 PST [36207] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 14:13:06.290 PST [36209] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 14:13:06.325 PST [36210] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
2023-12-10 14:14:23.978 PST [36257] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:14:23.983 PST [36257] LOG:  statement: SELECT version()
2023-12-10 14:14:23.985 PST [36257] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:14:23.986 PST [36257] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:14:23.991 PST [36257] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:14:23.996 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16736;
	
2023-12-10 14:14:24.070 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:14:24.073 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'menu_items' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'menu_items' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:14:24.075 PST [36257] LOG:  statement: SELECT * FROM public.menu_items
	
2023-12-10 14:14:24.186 PST [36257] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16736::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:14:24.205 PST [36257] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:14:24.205 PST [36257] DETAIL:  parameters: $1 = '{23,23,1700,23,1043}'
2023-12-10 14:14:30.752 PST [36263] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:14:30.752 PST [36263] LOG:  statement: SELECT pg_cancel_backend(36257);
2023-12-10 14:14:30.763 PST [36190] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:14:48.646 PST [36271] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:14:48.646 PST [36271] LOG:  statement: SELECT pg_cancel_backend(36196);
2023-12-10 14:14:55.412 PST [36190] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:14:55.438 PST [36275] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:14:55.441 PST [36275] LOG:  statement: SELECT version()
2023-12-10 14:14:55.450 PST [36275] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:14:55.452 PST [36275] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:14:55.454 PST [36275] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:14:55.459 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16694;
	
2023-12-10 14:14:55.595 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:14:55.598 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:14:55.601 PST [36275] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 14:14:55.758 PST [36275] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:14:55.768 PST [36275] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:14:55.768 PST [36275] DETAIL:  parameters: $1 = '{23,23,23,1700}'
2023-12-10 14:14:56.070 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:14:56.182 PST [36662] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.102 s, sync=0.002 s, total=0.112 s; sync files=2, longest=0.002 s, average=0.001 s; distance=1 kB, estimate=3303 kB
2023-12-10 14:15:06.572 PST [36190] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16739
2023-12-10 14:15:06.597 PST [36279] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:15:06.598 PST [36280] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:15:06.600 PST [36279] LOG:  statement: SELECT version()
2023-12-10 14:15:06.600 PST [36280] LOG:  statement: SELECT version()
2023-12-10 14:15:06.600 PST [36279] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:15:06.600 PST [36280] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:15:06.601 PST [36279] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:15:06.601 PST [36280] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:15:06.602 PST [36279] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:15:06.602 PST [36280] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:15:08.783 PST [36280] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-10 14:15:09.021 PST [36280] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-10 14:15:11.286 PST [36280] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-10 14:15:16.817 PST [36284] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:15:16.819 PST [36284] LOG:  statement: SELECT version()
2023-12-10 14:15:16.821 PST [36284] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:15:16.822 PST [36284] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:15:16.824 PST [36284] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:15:16.828 PST [36280] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16826;
	
2023-12-10 14:15:17.020 PST [36280] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:15:17.035 PST [36280] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:15:17.043 PST [36284] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 14:15:17.148 PST [36284] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16826::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:15:17.164 PST [36284] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:15:17.164 PST [36284] DETAIL:  parameters: $1 = '{23,23,1700,23}'
2023-12-10 14:16:07.573 PST [36191] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-10 14:16:07.761 PST [36191] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 14:16:07.771 PST [36191] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16694::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16694::oid ORDER BY rel.relname;
2023-12-10 14:16:07.772 PST [36190] LOG:  statement: SELECT
		r.oid, r.rolname, r.rolcanlogin, r.rolsuper,
		pg_catalog.shobj_description(r.oid, 'pg_authid') AS description
	FROM
		pg_catalog.pg_roles r
	ORDER BY r.rolcanlogin, r.rolname
2023-12-10 14:16:07.782 PST [36190] LOG:  statement: SELECT
	    ts.oid AS oid, spcname AS name, spcowner as owner,
	    pg_catalog.shobj_description(oid, 'pg_tablespace') AS description
	FROM
	    pg_catalog.pg_tablespace ts
	ORDER BY name;
2023-12-10 14:16:07.863 PST [36191] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 14:16:07.881 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:07.884 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:07.893 PST [36191] LOG:  statement: SELECT name, setting::numeric AS setting FROM pg_catalog.pg_settings WHERE name IN('autovacuum_vacuum_threshold','autovacuum_analyze_threshold','autovacuum_vacuum_scale_factor','autovacuum_analyze_scale_factor','autovacuum_vacuum_cost_delay','autovacuum_vacuum_cost_limit','autovacuum_freeze_max_age','vacuum_freeze_min_age','vacuum_freeze_table_age') ORDER BY name
2023-12-10 14:16:07.896 PST [36191] LOG:  statement: SELECT name, setting::numeric AS setting FROM pg_catalog.pg_settings WHERE name IN('autovacuum_vacuum_threshold','autovacuum_vacuum_scale_factor','autovacuum_vacuum_cost_delay','autovacuum_vacuum_cost_limit','autovacuum_freeze_max_age','vacuum_freeze_min_age','vacuum_freeze_table_age') ORDER BY name
2023-12-10 14:16:07.910 PST [36191] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 14:16:07.949 PST [36191] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 14:16:07.972 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:07.976 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:07.978 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:07.979 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:07.986 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 14:16:08.011 PST [36191] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 14:16:08.022 PST [36191] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16698::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 14:16:08.027 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 14:16:08.045 PST [36191] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16694::oid
	ORDER BY conname
2023-12-10 14:16:08.062 PST [36191] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16694::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16686::oid
	    AND a2.attnum=1
	
2023-12-10 14:16:08.076 PST [36191] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16686::oid
2023-12-10 14:16:08.088 PST [36191] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	   AND conname IS NULL
2023-12-10 14:16:08.106 PST [36191] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column
	
2023-12-10 14:16:08.107 PST [36191] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16694::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16653::oid
	    AND a2.attnum=1
	
2023-12-10 14:16:08.108 PST [36191] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16653::oid
2023-12-10 14:16:08.110 PST [36191] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	   AND conname IS NULL
2023-12-10 14:16:08.114 PST [36191] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column
	
2023-12-10 14:16:08.129 PST [36191] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16694::oid
	
2023-12-10 14:16:08.142 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 14:16:08.385 PST [36191] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:16:08.401 PST [36191] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:16:08.415 PST [36191] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:16:08.428 PST [36191] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:16:42.893 PST [36191] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16694::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16694::oid ORDER BY rel.relname;
2023-12-10 14:16:42.902 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:42.917 PST [36191] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-10 14:16:42.936 PST [36191] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16694::oid;
	
2023-12-10 14:16:42.946 PST [36191] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-10 14:16:42.959 PST [36191] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16694::oid;
2023-12-10 14:16:42.961 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16694::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:42.965 PST [36191] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 14:16:42.971 PST [36191] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 14:16:42.973 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:42.974 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:42.975 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 3::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:42.977 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16694::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:16:42.980 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 14:16:42.986 PST [36191] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 14:16:42.989 PST [36191] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16698::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 14:16:42.990 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 14:16:42.994 PST [36191] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16694::oid
	ORDER BY conname
2023-12-10 14:16:42.997 PST [36191] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16694::oid
	    AND a1.attnum=3
	    AND a2.attrelid=16686::oid
	    AND a2.attnum=1
	
2023-12-10 14:16:42.998 PST [36191] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16686::oid
2023-12-10 14:16:42.999 PST [36191] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	   AND conname IS NULL
2023-12-10 14:16:43.005 PST [36191] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column
	
2023-12-10 14:16:43.006 PST [36191] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16694::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16653::oid
	    AND a2.attnum=1
	
2023-12-10 14:16:43.007 PST [36191] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16653::oid
2023-12-10 14:16:43.008 PST [36191] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16694::oid
	   AND conname IS NULL
2023-12-10 14:16:43.011 PST [36191] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16698 , 1 , true) AS column
	
2023-12-10 14:16:43.013 PST [36191] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16694::oid
	
2023-12-10 14:16:43.015 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16694::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 14:16:43.206 PST [36191] LOG:  statement: ALTER TABLE IF EXISTS public.orders DROP COLUMN IF EXISTS restaurant_id;
	
	ALTER TABLE IF EXISTS public.orders
	    ADD COLUMN order_id integer;
	ALTER TABLE IF EXISTS public.orders DROP CONSTRAINT IF EXISTS orders_restaurant_id_fkey;
2023-12-10 14:16:43.216 PST [36191] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16694::oid;
	
2023-12-10 14:16:52.425 PST [36323] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:16:52.425 PST [36323] LOG:  statement: SELECT pg_cancel_backend(36284);
2023-12-10 14:16:54.356 PST [36325] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:16:54.356 PST [36325] LOG:  statement: SELECT pg_cancel_backend(36275);
2023-12-10 14:17:05.322 PST [36337] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:17:05.326 PST [36337] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 14:17:05.326 PST [36337] DETAIL:  parameters: $1 = '4'
2023-12-10 14:17:17.795 PST [36348] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:17:17.798 PST [36348] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:17:17.798 PST [36348] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:17:17.805 PST [36349] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:17:17.805 PST [36349] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 14:17:17.814 PST [36350] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:17:17.815 PST [36350] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:17:17.815 PST [36350] DETAIL:  parameters: $1 = '34', $2 = 'Cowboy - Keto Friendly (Baking Required)', $3 = '1', $4 = '10.99', $5 = '2'
2023-12-10 14:17:17.816 PST [36350] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:17:17.816 PST [36350] DETAIL:  parameters: $1 = '34', $2 = 'Create Your Own Crustless - Keto Friendly (Baking Required)', $3 = '3', $4 = '9', $5 = '2'
2023-12-10 14:17:17.816 PST [36350] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:17:17.833 PST [36351] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:17:17.835 PST [36351] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 14:17:17.835 PST [36351] DETAIL:  parameters: $1 = '34'
2023-12-10 14:17:17.836 PST [36351] LOG:  execute <unnamed>: INSERT INTO orders (user_id,order_total,order_id) VALUES ($1, $2, $3)
2023-12-10 14:17:17.836 PST [36351] DETAIL:  parameters: $1 = '2', $2 = '37.99', $3 = '34'
2023-12-10 14:17:17.839 PST [36351] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:17:29.539 PST [36190] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:17:29.562 PST [36359] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:17:29.564 PST [36359] LOG:  statement: SELECT version()
2023-12-10 14:17:29.565 PST [36359] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:17:29.567 PST [36359] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:17:29.569 PST [36359] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:17:29.573 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16694;
	
2023-12-10 14:17:29.697 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:17:29.701 PST [36191] LOG:  execute _pg3_0: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'orders' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'orders' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:17:29.703 PST [36359] LOG:  statement: SELECT * FROM public.orders
	ORDER BY id ASC 
2023-12-10 14:17:29.894 PST [36359] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16694::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:17:29.903 PST [36359] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:17:29.903 PST [36359] DETAIL:  parameters: $1 = '{23,23,1700,23}'
2023-12-10 14:19:56.181 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:19:59.464 PST [36662] LOG:  checkpoint complete: wrote 33 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.268 s, sync=0.006 s, total=3.283 s; sync files=24, longest=0.002 s, average=0.001 s; distance=149 kB, estimate=2987 kB
2023-12-10 14:22:21.661 PST [36491] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:22:21.663 PST [36491] LOG:  statement: SELECT version()
2023-12-10 14:22:21.664 PST [36491] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:22:21.666 PST [36491] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:22:21.668 PST [36491] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:22:21.672 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16667;
	
2023-12-10 14:22:21.792 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:22:21.796 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:22:21.844 PST [36491] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 14:22:22.060 PST [36491] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:22:22.071 PST [36491] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:22:22.071 PST [36491] DETAIL:  parameters: $1 = '{23,23,1700,1700}'
2023-12-10 14:24:56.464 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:24:56.787 PST [36662] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.308 s, sync=0.006 s, total=0.324 s; sync files=1, longest=0.006 s, average=0.006 s; distance=21 kB, estimate=2691 kB
2023-12-10 14:35:57.145 PST [36883] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:35:57.145 PST [36883] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 14:36:04.757 PST [36891] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:36:04.758 PST [36891] LOG:  statement: SELECT restaurant_id, ratings FROM ratings GROUP BY restaurant_id
2023-12-10 14:36:04.758 PST [36891] ERROR:  column "ratings.ratings" must appear in the GROUP BY clause or be used in an aggregate function at character 23
2023-12-10 14:36:04.758 PST [36891] STATEMENT:  SELECT restaurant_id, ratings FROM ratings GROUP BY restaurant_id
2023-12-10 14:36:45.476 PST [36917] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:36:45.476 PST [36917] LOG:  statement: SELECT restaurant_id, ratings FROM ratings
2023-12-10 14:36:49.199 PST [36923] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:36:49.200 PST [36923] LOG:  statement: SELECT restaurant_id, ratings FROM ratings
2023-12-10 14:38:17.571 PST [36965] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:38:17.571 PST [36965] LOG:  statement: SELECT restaurant_id, ratings FROM ratings
2023-12-10 14:38:18.548 PST [36969] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:38:18.548 PST [36969] LOG:  statement: SELECT restaurant_id, ratings FROM ratings
2023-12-10 14:38:21.079 PST [36971] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:38:21.080 PST [36971] LOG:  statement: SELECT restaurant_id, ratings FROM ratings
2023-12-10 14:38:43.768 PST [36991] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:38:43.768 PST [36991] LOG:  statement: SELECT restaurant_id, ratings FROM ratings
2023-12-10 14:42:23.574 PST [36191] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-10 14:42:23.586 PST [36191] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-10 14:42:23.602 PST [36191] LOG:  statement: TRUNCATE TABLE public.ratings RESTART IDENTITY;
2023-12-10 14:42:27.665 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:42:27.668 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:42:27.674 PST [36491] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 14:42:27.733 PST [36491] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:42:27.743 PST [36491] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:42:27.743 PST [36491] DETAIL:  parameters: $1 = '{23,23,1700,1700}'
2023-12-10 14:42:31.347 PST [36191] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16667::oid
2023-12-10 14:42:31.349 PST [36190] LOG:  statement: SELECT * FROM
	(SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
	FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
	WHERE encoding != '' ORDER BY encoding;
	
	
2023-12-10 14:42:31.351 PST [36191] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:42:59.950 PST [37108] LOG:  statement: COPY  public.ratings ( id, restaurant_id, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-10 14:42:59.951 PST [37108] ERROR:  invalid input syntax for type integer: "4.7"
2023-12-10 14:42:59.951 PST [37108] CONTEXT:  COPY ratings, line 2, column restaurant_id: "4.7"
2023-12-10 14:42:59.951 PST [37108] STATEMENT:  COPY  public.ratings ( id, restaurant_id, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-10 14:43:32.715 PST [37121] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:43:32.719 PST [37121] LOG:  statement: SELECT version()
2023-12-10 14:43:32.729 PST [37121] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:43:32.736 PST [37121] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:43:32.747 PST [37121] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:43:32.758 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16667;
	
2023-12-10 14:43:32.842 PST [36191] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:43:33.055 PST [36191] LOG:  execute _pg3_1: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:43:33.070 PST [37121] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 14:43:33.338 PST [37121] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:43:33.357 PST [37121] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:43:33.357 PST [37121] DETAIL:  parameters: $1 = '{23,23,1700,1700}'
2023-12-10 14:43:37.132 PST [37124] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:43:37.132 PST [37124] LOG:  statement: SELECT pg_cancel_backend(37121);
2023-12-10 14:43:37.150 PST [36190] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:43:39.456 PST [37126] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:43:39.457 PST [37126] LOG:  statement: SELECT pg_cancel_backend(36491);
2023-12-10 14:43:39.585 PST [36190] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:43:45.530 PST [37128] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:43:45.530 PST [37128] LOG:  statement: SELECT pg_cancel_backend(36359);
2023-12-10 14:43:50.540 PST [36190] LOG:  execute _pg3_0: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:43:50.563 PST [37132] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:43:50.565 PST [37132] LOG:  statement: SELECT version()
2023-12-10 14:43:50.567 PST [37132] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:43:50.569 PST [37132] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:43:50.570 PST [37132] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:43:50.574 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16667;
	
2023-12-10 14:43:50.705 PST [36191] LOG:  execute _pg3_1: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:43:50.707 PST [36191] LOG:  execute _pg3_1: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:43:50.710 PST [37132] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 14:43:50.948 PST [37132] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:43:50.962 PST [37132] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:43:50.962 PST [37132] DETAIL:  parameters: $1 = '{23,23,1700,1700}'
2023-12-10 14:44:00.981 PST [36191] LOG:  statement: SELECT c.oid, c.relname , nspname,
	CASE WHEN nspname NOT LIKE 'pg\_%' THEN
	 pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	ELSE pg_catalog.quote_ident(c.relname)
	END AS inherits
	FROM pg_catalog.pg_class c
	JOIN pg_catalog.pg_namespace n
	ON n.oid=c.relnamespace
	WHERE relkind='r' AND NOT relispartition
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY relnamespace, c.relname
2023-12-10 14:44:00.983 PST [36191] LOG:  statement: SELECT c.oid,
	  pg_catalog.quote_ident(n.nspname)||'.'||pg_catalog.quote_ident(c.relname) AS typname
	  FROM pg_catalog.pg_namespace n, pg_catalog.pg_class c
	WHERE c.relkind = 'c' AND c.relnamespace=n.oid
	AND n.nspname NOT LIKE 'pg\_%' AND n.nspname NOT IN ('information_schema') 
	ORDER BY typname;
2023-12-10 14:44:00.991 PST [36191] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-10 14:44:00.997 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:00.999 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:01.003 PST [36191] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 14:44:01.009 PST [36191] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 14:44:01.010 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:01.012 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:01.013 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:01.014 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:01.015 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 14:44:01.019 PST [36191] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 14:44:01.019 PST [36191] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16671::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 14:44:01.020 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 14:44:01.023 PST [36191] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16667::oid
	ORDER BY conname
2023-12-10 14:44:01.025 PST [36191] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16667::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16686::oid
	    AND a2.attnum=1
	
2023-12-10 14:44:01.026 PST [36191] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16686::oid
2023-12-10 14:44:01.026 PST [36191] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	   AND conname IS NULL
2023-12-10 14:44:01.030 PST [36191] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column
	
2023-12-10 14:44:01.030 PST [36191] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16667::oid
	
2023-12-10 14:44:01.034 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 14:44:01.332 PST [36191] LOG:  statement: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:44:01.346 PST [36191] LOG:  execute _pg3_2: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:44:01.358 PST [36191] LOG:  execute _pg3_2: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:44:01.370 PST [36191] LOG:  execute _pg3_2: SELECT
	    *
	FROM
	    (SELECT
	        pg_catalog.format_type(t.oid,NULL) AS typname,
	        CASE WHEN typelem > 0 THEN typelem ELSE t.oid END as elemoid,
	        typlen, typtype, t.oid, nspname,
	        (SELECT COUNT(1) FROM pg_catalog.pg_type t2 WHERE t2.typname = t.typname) > 1 AS isdup,
	        CASE WHEN t.typcollation != 0 THEN TRUE ELSE FALSE END AS is_collatable
	    FROM
	        pg_catalog.pg_type t
	    JOIN
	        pg_catalog.pg_namespace nsp ON typnamespace=nsp.oid
	    WHERE
	        (NOT (typname = 'unknown' AND nspname = 'pg_catalog'))
	    AND
	        typisdefined AND typtype IN ('b', 'c', 'd', 'e', 'r', 'm')
	AND NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE relnamespace=typnamespace
	AND relname = typname AND relkind != 'c') AND
	(typname NOT LIKE '_%' OR NOT EXISTS (SELECT 1 FROM pg_catalog.pg_class WHERE
	relnamespace=typnamespace AND relname = substring(typname FROM 2)::name
	AND relkind != 'c'))
	AND nsp.nspname != 'information_schema'
	
	    UNION SELECT 'smallserial', 0, 2, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'bigserial', 0, 8, 'b', 0, 'pg_catalog', false, false
	    UNION SELECT 'serial', 0, 4, 'b', 0, 'pg_catalog', false, false
	    ) AS dummy
	ORDER BY nspname <> 'pg_catalog', nspname <> 'public', nspname, 1
2023-12-10 14:44:29.992 PST [36191] LOG:  statement: SELECT rel.oid, rel.relname AS name, rel.reltablespace AS spcoid,rel.relacl AS relacl_str,
	  (CASE WHEN length(spc.spcname::text) > 0 OR rel.relkind = 'p' THEN spc.spcname ELSE
	    (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	    JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	    WHERE dtb.oid = 16464::oid)
	  END) as spcname,
	  (CASE rel.relreplident
	          WHEN 'd' THEN 'default'
	          WHEN 'n' THEN 'nothing'
	          WHEN 'f' THEN 'full'
	          WHEN 'i' THEN 'index'
	  END) as replica_identity,
	  (select nspname FROM pg_catalog.pg_namespace WHERE oid = 2200::oid ) as schema,
	  pg_catalog.pg_get_userbyid(rel.relowner) AS relowner, rel.relkind,
	  (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	  rel.relhassubclass, rel.reltuples::bigint, des.description, con.conname, con.conkey,
		EXISTS(select 1 FROM pg_catalog.pg_trigger
				JOIN pg_catalog.pg_proc pt ON pt.oid=tgfoid AND pt.proname='logtrigger'
				JOIN pg_catalog.pg_proc pc ON pc.pronamespace=pt.pronamespace AND pc.proname='slonyversion'
				WHERE tgrelid=rel.oid) AS isrepl,
		(SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
		(SELECT ARRAY(SELECT CASE WHEN (nspname NOT LIKE 'pg\_%') THEN
	            pg_catalog.quote_ident(nspname)||'.'||pg_catalog.quote_ident(c.relname)
	            ELSE pg_catalog.quote_ident(c.relname) END AS inherited_tables
	    FROM pg_catalog.pg_inherits i
	    JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	    JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
	    WHERE i.inhrelid = rel.oid ORDER BY inhseqno)) AS coll_inherits,
	  (SELECT count(*)
			FROM pg_catalog.pg_inherits i
	      JOIN pg_catalog.pg_class c ON c.oid = i.inhparent
	      JOIN pg_catalog.pg_namespace n ON n.oid=c.relnamespace
			WHERE i.inhrelid = rel.oid) AS inherited_tables_cnt,
		(CASE WHEN rel.relpersistence = 'u' THEN true ELSE false END) AS relpersistence,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'fillfactor=([0-9]*)') AS fillfactor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'parallel_workers=([0-9]*)') AS parallel_workers,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'toast_tuple_target=([0-9]*)') AS toast_tuple_target,
		(substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS autovacuum_enabled,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(rel.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS autovacuum_freeze_table_age,
		(substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_enabled=([a-z|0-9]*)'))::BOOL AS toast_autovacuum_enabled,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_threshold=([0-9]*)') AS toast_autovacuum_vacuum_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_vacuum_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_threshold=([0-9]*)') AS toast_autovacuum_analyze_threshold,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_analyze_scale_factor=([0-9]*[.]?[0-9]*)') AS toast_autovacuum_analyze_scale_factor,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_delay=([0-9]*)') AS toast_autovacuum_vacuum_cost_delay,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_vacuum_cost_limit=([0-9]*)') AS toast_autovacuum_vacuum_cost_limit,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_min_age=([0-9]*)') AS toast_autovacuum_freeze_min_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_max_age=([0-9]*)') AS toast_autovacuum_freeze_max_age,
		substring(pg_catalog.array_to_string(tst.reloptions, ',') FROM 'autovacuum_freeze_table_age=([0-9]*)') AS toast_autovacuum_freeze_table_age,
		rel.reloptions AS reloptions, tst.reloptions AS toast_reloptions, rel.reloftype,
		CASE WHEN typ.typname IS NOT NULL THEN (select pg_catalog.quote_ident(nspname) FROM pg_catalog.pg_namespace WHERE oid = 2200::oid )||'.'||pg_catalog.quote_ident(typ.typname) ELSE typ.typname END AS typname,
		typ.typrelid AS typoid, rel.relrowsecurity as rlspolicy, rel.relforcerowsecurity as forcerlspolicy,
		(CASE WHEN rel.reltoastrelid = 0 THEN false ELSE true END) AS hastoasttable,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=rel.oid AND sl1.objsubid=0) AS seclabels,
		(CASE WHEN rel.oid <= 16383::oid THEN true ElSE false END) AS is_sys_table
		-- Added for partition table
	    , (CASE WHEN rel.relkind = 'p' THEN pg_catalog.pg_get_partkeydef(16667::oid) ELSE '' END) AS partition_scheme FROM pg_catalog.pg_class rel
	  LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	  LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	  LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	AND NOT rel.relispartition
	  AND rel.oid = 16667::oid ORDER BY rel.relname;
2023-12-10 14:44:29.999 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:30.002 PST [36191] LOG:  statement: SELECT
	    pid,
	    locktype,
	    datname,
	    relation::regclass,
	    page,
	    tuple,
	    virtualxid
	    transactionid,
	    classid::regclass,
	    objid,
	    objsubid,
	    virtualtransaction,
	    mode,
	    granted,
	    fastpath
	FROM
	    pg_catalog.pg_locks l
	    LEFT OUTER JOIN pg_catalog.pg_database d ON (l.database = d.oid)
	WHERE
	    datname = (SELECT datname FROM pg_catalog.pg_database WHERE oid = 16464)ORDER BY
	    pid, locktype
2023-12-10 14:44:30.003 PST [36191] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16667::oid;
	
2023-12-10 14:44:30.003 PST [36191] LOG:  statement: SELECT nsp.nspname FROM pg_catalog.pg_namespace nsp WHERE nsp.oid = 2200;
2023-12-10 14:44:30.010 PST [36191] LOG:  statement: SELECT
	    rel.relname AS name
	FROM
	    pg_catalog.pg_class rel
	WHERE
	    rel.relkind IN ('r','s','t','p')
	    AND rel.relnamespace = 2200::oid
	    AND rel.oid = 16667::oid;
2023-12-10 14:44:30.010 PST [36191] LOG:  statement: SELECT 'relacl' as deftype, COALESCE(gt.rolname, 'PUBLIC') grantee, g.rolname grantor,
	    pg_catalog.array_agg(privilege_type) as privileges, pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
			WHEN 'CONNECT' THEN 'c'
			WHEN 'CREATE' THEN 'C'
			WHEN 'DELETE' THEN 'd'
			WHEN 'EXECUTE' THEN 'X'
			WHEN 'INSERT' THEN 'a'
			WHEN 'REFERENCES' THEN 'x'
			WHEN 'SELECT' THEN 'r'
			WHEN 'TEMPORARY' THEN 'T'
			WHEN 'TRIGGER' THEN 't'
			WHEN 'TRUNCATE' THEN 'D'
			WHEN 'UPDATE' THEN 'w'
			WHEN 'USAGE' THEN 'U'
			ELSE 'UNKNOWN'
		END AS privilege_type
	  FROM
	    (SELECT rel.relacl
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        aclexplode(rel.relacl) as d
	        FROM pg_catalog.pg_class rel
	          LEFT OUTER JOIN pg_catalog.pg_tablespace spc on spc.oid=rel.reltablespace
	          LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid AND con.contype='p'
	          LEFT OUTER JOIN pg_catalog.pg_class tst ON tst.oid = rel.reltoastrelid
	          LEFT JOIN pg_catalog.pg_type typ ON rel.reloftype=typ.oid
	        WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	            AND rel.oid = 16667::oid
	        ) a ORDER BY privilege_type) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:30.015 PST [36191] LOG:  statement: SELECT DISTINCT ON (att.attnum) att.attname as name, att.atttypid, att.attlen, att.attnum, att.attndims,
			att.atttypmod, att.attacl, att.attnotnull, att.attoptions, att.attstattarget,
			att.attstorage, att.attidentity,
			pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
			pg_catalog.format_type(ty.oid,NULL) AS typname,
	        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
			pg_catalog.format_type(ty.oid,att.atttypmod) AS cltype,
	        CASE WHEN ty.typelem > 0 THEN ty.typelem ELSE ty.oid END as elemoid,
			(SELECT nspname FROM pg_catalog.pg_namespace WHERE oid = ty.typnamespace) as typnspname,
	        ty.typstorage AS defaultstorage,
			description, pi.indkey,
		(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
		CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
		  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
		ELSE '' END AS collspcname,
		EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As is_fk,
		(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS seclabels,
		(CASE WHEN (att.attnum < 1) THEN true ElSE false END) AS is_sys_column,
		(CASE WHEN (att.attidentity in ('a', 'd')) THEN 'i' WHEN (att.attgenerated in ('s')) THEN 'g' ELSE 'n' END) AS colconstype,
		(CASE WHEN (att.attgenerated in ('s')) THEN pg_catalog.pg_get_expr(def.adbin, def.adrelid) END) AS genexpr, tab.relname as relname,
		(CASE WHEN tab.relkind = 'v' THEN true ELSE false END) AS is_view_only,
		seq.*
	FROM pg_catalog.pg_attribute att
	  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	  LEFT OUTER JOIN (pg_catalog.pg_depend dep JOIN pg_catalog.pg_class cs ON dep.classid='pg_class'::regclass AND dep.objid=cs.oid AND cs.relkind='S') ON dep.refobjid=att.attrelid AND dep.refobjsubid=att.attnum
	  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
	  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
	  LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	  LEFT OUTER JOIN pg_catalog.pg_class tab on tab.oid = att.attrelid
	WHERE att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	    ORDER BY att.attnum;
2023-12-10 14:44:30.022 PST [36191] LOG:  statement: SELECT t.main_oid, pg_catalog.ARRAY_AGG(t.typname) as edit_types
	FROM
	(SELECT pc.castsource AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	    JOIN pg_catalog.pg_cast pc ON tt.oid=pc.casttarget
	    WHERE pc.castsource IN (23,1700)
	    AND pc.castcontext IN ('i', 'a')
	UNION
	SELECT tt.typbasetype AS main_oid, pg_catalog.format_type(tt.oid,NULL) AS typname
	FROM pg_catalog.pg_type tt
	WHERE tt.typbasetype  IN (23,1700)
	) t
	GROUP BY t.main_oid;
2023-12-10 14:44:30.023 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 1::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:30.032 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 2::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:30.034 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 4::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:30.035 PST [36191] LOG:  statement: SELECT 'attacl' as deftype,
	    COALESCE(gt.rolname, 'PUBLIC') grantee,
	    g.rolname grantor,
	    pg_catalog.array_agg(privilege_type order by privilege_type) as privileges,
	    pg_catalog.array_agg(is_grantable) as grantable
	FROM
	  (SELECT
	    d.grantee, d.grantor, d.is_grantable,
	    CASE d.privilege_type
	        WHEN 'CONNECT' THEN 'c'
	        WHEN 'CREATE' THEN 'C'
	        WHEN 'DELETE' THEN 'd'
	        WHEN 'EXECUTE' THEN 'X'
	        WHEN 'INSERT' THEN 'a'
	        WHEN 'REFERENCES' THEN 'x'
	        WHEN 'SELECT' THEN 'r'
	        WHEN 'TEMPORARY' THEN 'T'
	        WHEN 'TRIGGER' THEN 't'
	        WHEN 'TRUNCATE' THEN 'D'
	        WHEN 'UPDATE' THEN 'w'
	        WHEN 'USAGE' THEN 'U'
	        ELSE 'UNKNOWN'
	    END AS privilege_type
	  FROM
	    (SELECT attacl
	        FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int
	    ) acl,
	    (SELECT (d).grantee AS grantee, (d).grantor AS grantor, (d).is_grantable
	        AS is_grantable, (d).privilege_type AS privilege_type FROM (SELECT
	        pg_catalog.aclexplode(attacl) as d FROM pg_catalog.pg_attribute att
	        WHERE att.attrelid = 16667::oid
	        AND att.attnum = 5::int) a) d
	    ) d
	  LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
	  LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
	GROUP BY g.rolname, gt.rolname
	ORDER BY grantee
2023-12-10 14:44:30.036 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='p'
	ORDER BY cls.relname
2023-12-10 14:44:30.039 PST [36191] LOG:  statement: SELECT * FROM (
	SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column, 0 AS dummy
	) tmp
	ORDER BY dummy
2023-12-10 14:44:30.040 PST [36191] LOG:  statement: -- pg_get_indexdef did not support INCLUDE columns
	
	SELECT a.attname as colname
	FROM (
	    SELECT
	      i.indnkeyatts,
	      i.indrelid,
	      pg_catalog.unnest(indkey) AS table_colnum,
	      pg_catalog.unnest(ARRAY(SELECT pg_catalog.generate_series(1, i.indnatts) AS n)) attnum
	    FROM
	      pg_catalog.pg_index i
	    WHERE i.indexrelid = 16671::OID
	) i JOIN pg_catalog.pg_attribute a
	ON (a.attrelid = i.indrelid AND i.table_colnum = a.attnum)
	WHERE i.attnum > i.indnkeyatts
	ORDER BY i.attnum
2023-12-10 14:44:30.040 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    indnullsnotdistinct,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    conislocal,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='u'
	ORDER BY cls.relname
2023-12-10 14:44:30.043 PST [36191] LOG:  statement: SELECT ct.oid,
	      conname as name,
	      condeferrable,
	      condeferred,
	      confupdtype,
	      confdeltype,
	      CASE confmatchtype
	        WHEN 's' THEN FALSE
	        WHEN 'f' THEN TRUE
	      END AS confmatchtype,
	      conkey,
	      confkey,
	      confrelid,
	      nl.nspname as fknsp,
	      cl.relname as fktab,
	      nr.oid as refnspoid,
	      nr.nspname as refnsp,
	      cr.relname as reftab,
	      description as comment,
	      convalidated,
	      conislocal
	FROM pg_catalog.pg_constraint ct
	JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	JOIN pg_catalog.pg_namespace nl ON nl.oid=cl.relnamespace
	JOIN pg_catalog.pg_class cr ON cr.oid=confrelid
	JOIN pg_catalog.pg_namespace nr ON nr.oid=cr.relnamespace
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ct.oid AND des.classoid='pg_constraint'::regclass)
	WHERE contype='f' AND
	conrelid = 16667::oid
	ORDER BY conname
2023-12-10 14:44:30.045 PST [36191] LOG:  statement: SELECT a1.attname as conattname,
	    a2.attname as confattname
	FROM pg_catalog.pg_attribute a1,
	    pg_catalog.pg_attribute a2
	WHERE a1.attrelid=16667::oid
	    AND a1.attnum=2
	    AND a2.attrelid=16686::oid
	    AND a2.attnum=1
	
2023-12-10 14:44:30.045 PST [36191] LOG:  statement: SELECT nsp.nspname AS schema,
	    rel.relname AS table
	FROM
	    pg_catalog.pg_class rel
	JOIN pg_catalog.pg_namespace nsp
	ON rel.relnamespace = nsp.oid::oid
	WHERE rel.oid = 16686::oid
2023-12-10 14:44:30.046 PST [36191] LOG:  statement: SELECT   cls.oid, cls.relname as idxname, indnatts as col_count
	  FROM pg_catalog.pg_index idx
	  JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	  LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	  LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	    AND con.contype='p'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	    AND con.contype='x'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	    AND con.contype='u'
	
	UNION
	
	SELECT  cls.oid, cls.relname as idxname, indnatts
	    FROM pg_catalog.pg_index idx
	    JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	    LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	    LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	WHERE idx.indrelid = 16667::oid
	   AND conname IS NULL
2023-12-10 14:44:30.049 PST [36191] LOG:  statement: SELECT  pg_catalog.pg_get_indexdef(16671 , 1 , true) AS column
	
2023-12-10 14:44:30.050 PST [36191] LOG:  statement: SELECT c.oid, conname as name, relname, nspname, description as comment,
	       pg_catalog.pg_get_expr(conbin, conrelid, true) as consrc,
	       connoinherit, NOT convalidated as convalidated, conislocal
	    FROM pg_catalog.pg_constraint c
	    JOIN pg_catalog.pg_class cl ON cl.oid=conrelid
	    JOIN pg_catalog.pg_namespace nl ON nl.oid=relnamespace
	LEFT OUTER JOIN
	    pg_catalog.pg_description des ON (des.objoid=c.oid AND
	                           des.classoid='pg_constraint'::regclass)
	WHERE contype = 'c'
	    AND conrelid = 16667::oid
	
2023-12-10 14:44:30.052 PST [36191] LOG:  statement: SELECT cls.oid,
	    cls.relname as name,
	    indnkeyatts as col_count,
	    amname,
	    CASE WHEN length(spcname::text) > 0 THEN spcname ELSE
	        (SELECT sp.spcname FROM pg_catalog.pg_database dtb
	        JOIN pg_catalog.pg_tablespace sp ON dtb.dattablespace=sp.oid
	        WHERE dtb.oid = 16464::oid)
	    END as spcname,
	    CASE contype
	        WHEN 'p' THEN desp.description
	        WHEN 'u' THEN desp.description
	        WHEN 'x' THEN desp.description
	        ELSE des.description
	    END AS comment,
	    condeferrable,
	    condeferred,
	    substring(pg_catalog.array_to_string(cls.reloptions, ',') from 'fillfactor=([0-9]*)') AS fillfactor,
	    pg_catalog.pg_get_expr(idx.indpred, idx.indrelid, true) AS indconstraint
	FROM pg_catalog.pg_index idx
	JOIN pg_catalog.pg_class cls ON cls.oid=indexrelid
	LEFT OUTER JOIN pg_catalog.pg_tablespace ta on ta.oid=cls.reltablespace
	JOIN pg_catalog.pg_am am ON am.oid=cls.relam
	LEFT JOIN pg_catalog.pg_depend dep ON (dep.classid = cls.tableoid AND dep.objid = cls.oid AND dep.refobjsubid = '0' AND dep.refclassid=(SELECT oid FROM pg_catalog.pg_class WHERE relname='pg_constraint') AND dep.deptype='i')
	LEFT OUTER JOIN pg_catalog.pg_constraint con ON (con.tableoid = dep.refclassid AND con.oid = dep.refobjid)
	LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=cls.oid AND des.classoid='pg_class'::regclass)
	LEFT OUTER JOIN pg_catalog.pg_description desp ON (desp.objoid=con.oid AND desp.objsubid = 0 AND desp.classoid='pg_constraint'::regclass)
	WHERE indrelid = 16667::oid
	AND contype='x'
	ORDER BY cls.relname
2023-12-10 14:44:30.056 PST [36191] LOG:  statement: ALTER TABLE IF EXISTS public.ratings
	    ADD COLUMN name character varying(255);
2023-12-10 14:44:30.061 PST [36191] LOG:  statement: SELECT
	    c.relnamespace as scid, nsp.nspname as nspname
	FROM
	    pg_catalog.pg_class c
	LEFT JOIN pg_catalog.pg_namespace nsp ON nsp.oid = c.relnamespace
	WHERE
	    c.oid = 16667::oid;
	
2023-12-10 14:44:56.795 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:44:57.627 PST [37161] LOG:  statement: COPY  public.ratings ( id, restaurant_id, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-10 14:44:57.628 PST [37161] ERROR:  invalid input syntax for type integer: "4.7"
2023-12-10 14:44:57.628 PST [37161] CONTEXT:  COPY ratings, line 2, column restaurant_id: "4.7"
2023-12-10 14:44:57.628 PST [37161] STATEMENT:  COPY  public.ratings ( id, restaurant_id, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-10 14:44:58.044 PST [36662] LOG:  checkpoint complete: wrote 13 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.233 s, sync=0.004 s, total=1.249 s; sync files=12, longest=0.002 s, average=0.001 s; distance=67 kB, estimate=2428 kB
2023-12-10 14:45:34.944 PST [37184] LOG:  statement: COPY  public.ratings ( restaurant_id, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-10 14:45:34.945 PST [37184] ERROR:  extra data after last expected column
2023-12-10 14:45:34.945 PST [37184] CONTEXT:  COPY ratings, line 2: "7,4.7,63.0,Jinsei Sushi"
2023-12-10 14:45:34.945 PST [37184] STATEMENT:  COPY  public.ratings ( restaurant_id, ratings, score ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-10 14:46:16.602 PST [37215] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:46:16.605 PST [37215] LOG:  statement: SELECT version()
2023-12-10 14:46:16.607 PST [37215] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:46:16.609 PST [37215] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:46:16.611 PST [37215] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:46:16.617 PST [36191] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16667;
	
2023-12-10 14:46:16.738 PST [36191] LOG:  execute _pg3_1: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:46:16.741 PST [36191] LOG:  execute _pg3_1: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:46:16.746 PST [37215] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 14:46:16.992 PST [37215] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:46:17.011 PST [37215] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:46:17.011 PST [37215] DETAIL:  parameters: $1 = '{23,23,1700,1700,1043}'
2023-12-10 14:46:26.736 PST [36191] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-10 14:46:26.760 PST [36191] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-10 14:46:26.938 PST [36191] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-10 14:47:21.648 PST [37276] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:47:21.650 PST [37276] LOG:  statement: SELECT version()
2023-12-10 14:47:21.650 PST [37276] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:47:21.651 PST [37276] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:47:21.652 PST [37276] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:47:21.667 PST [37276] LOG:  statement: SELECT CASE WHEN usesuper
	       THEN pg_catalog.pg_is_in_recovery()
	       ELSE FALSE
	       END as inrecovery,
	       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
	       THEN pg_is_wal_replay_paused()
	       ELSE FALSE
	       END as isreplaypaused
	FROM pg_catalog.pg_user WHERE usename=current_user
2023-12-10 14:47:21.947 PST [37276] LOG:  statement: 
	SELECT
	    has_table_privilege(
	      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
	    ) has_priviledge
	WHERE EXISTS(
	    SELECT has_schema_privilege('pgagent', 'USAGE')
	    WHERE EXISTS(
	        SELECT cl.oid FROM pg_catalog.pg_class cl
	        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
	        WHERE relname='pga_job' AND nspname='pgagent'
	    )
	)
	
2023-12-10 14:47:22.013 PST [37276] LOG:  statement: SELECT
	    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
	    db.datistemplate AS is_template,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner,
	    descr.description
	FROM
	    pg_catalog.pg_database db
	    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
	    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
	        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
	    )
	WHERE         db.oid > 16383::OID OR db.datname IN ('postgres', 'edb')
	
	ORDER BY datname;
2023-12-10 14:47:22.046 PST [37276] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
	    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.oid = 16464
2023-12-10 14:47:22.070 PST [37278] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:47:22.071 PST [37277] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:47:22.073 PST [37278] LOG:  statement: SELECT version()
2023-12-10 14:47:22.073 PST [37277] LOG:  statement: SELECT version()
2023-12-10 14:47:22.073 PST [37278] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:47:22.073 PST [37277] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:47:22.074 PST [37278] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:47:22.074 PST [37277] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:47:22.075 PST [37278] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:47:22.075 PST [37277] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:47:22.404 PST [37277] LOG:  statement: SELECT
	    nsp.oid,
	    nsp.nspname as name,
	    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
	    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage,
	    des.description
	FROM
	    pg_catalog.pg_namespace nsp
	    LEFT OUTER JOIN pg_catalog.pg_description des ON
	        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
	WHERE
	             nspname NOT LIKE E'pg\\_%' AND
	            NOT (
	(nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1))
	    )
	
	    
	ORDER BY nspname;
2023-12-10 14:47:22.450 PST [37277] LOG:  statement: SELECT
	    nsp.nspname as schema_name,
	    (nsp.nspname = 'pg_catalog' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'pgagent' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
	            relnamespace = nsp.oid LIMIT 1)) OR
	    (nsp.nspname = 'information_schema' AND EXISTS
	        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
	            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
	    CASE
	    WHEN nsp.nspname = ANY('{information_schema}')
	        THEN false
	    ELSE true END AS db_support
	FROM
	    pg_catalog.pg_namespace nsp
	WHERE
	    nsp.oid = 2200::OID;
2023-12-10 14:47:22.656 PST [37277] LOG:  statement: SELECT rel.oid, rel.relname AS name,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE) AS triggercount,
	    (SELECT count(*) FROM pg_catalog.pg_trigger WHERE tgrelid=rel.oid AND tgisinternal = FALSE AND tgenabled = 'O') AS has_enable_triggers,
	    (CASE WHEN rel.relkind = 'p' THEN true ELSE false END) AS is_partitioned,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhrelid=rel.oid LIMIT 1) as is_inherits,
	    (SELECT count(1) FROM pg_catalog.pg_inherits WHERE inhparent=rel.oid LIMIT 1) as is_inherited,
	    des.description
	FROM pg_catalog.pg_class rel
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=rel.oid AND des.objsubid=0 AND des.classoid='pg_class'::regclass)
	    WHERE rel.relkind IN ('r','s','t','p') AND rel.relnamespace = 2200::oid
	    AND NOT rel.relispartition
	        ORDER BY rel.relname;
2023-12-10 14:47:31.511 PST [37277] LOG:  statement: SELECT nsp.nspname AS schema ,rel.relname AS table
	FROM pg_catalog.pg_class rel
	    JOIN pg_catalog.pg_namespace nsp
	    ON rel.relnamespace = nsp.oid::oid
	    WHERE rel.oid = 16667::oid
2023-12-10 14:47:31.512 PST [37276] LOG:  statement: SELECT * FROM
	(SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
	FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
	WHERE encoding != '' ORDER BY encoding;
	
	
2023-12-10 14:47:31.543 PST [37277] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:47:41.146 PST [37289] LOG:  statement: COPY  public.ratings ( restaurant_id, ratings, score, name ) FROM STDIN  DELIMITER ',' CSV   HEADER  QUOTE '"' ESCAPE '''';
2023-12-10 14:49:52.990 PST [37407] LOG:  statement: SET DateStyle=ISO; SET client_min_messages=notice; SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'; SET client_encoding='utf-8';
2023-12-10 14:49:52.993 PST [37407] LOG:  statement: SELECT version()
2023-12-10 14:49:52.995 PST [37407] LOG:  statement: 
	SELECT
	    db.oid as did, db.datname, db.datallowconn,
	    pg_encoding_to_char(db.encoding) AS serverencoding,
	    has_database_privilege(db.oid, 'CREATE') as cancreate,
	    datistemplate
	FROM
	    pg_catalog.pg_database db
	WHERE db.datname = current_database()
2023-12-10 14:49:52.997 PST [37407] LOG:  statement: 
	        SELECT
	             gss_authenticated, encrypted
	        FROM
	            pg_catalog.pg_stat_gssapi
	        WHERE pid = pg_backend_pid()
2023-12-10 14:49:52.999 PST [37407] LOG:  statement: 
	        SELECT
	            roles.oid as id, roles.rolname as name,
	            roles.rolsuper as is_superuser,
	            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
	            can_create_role,
	            CASE WHEN roles.rolsuper THEN true
	            ELSE roles.rolcreatedb END as can_create_db,
	            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(WITH RECURSIVE cte AS (
	            SELECT pg_roles.oid,pg_roles.rolname FROM pg_roles
	                WHERE pg_roles.oid = roles.oid
	            UNION ALL
	            SELECT m.roleid,pgr.rolname FROM cte cte_1
	                JOIN pg_auth_members m ON m.member = cte_1.oid
	                JOIN pg_roles pgr ON pgr.oid = m.roleid)
	            SELECT rolname  FROM cte)) THEN True
	            ELSE False END as can_signal_backend
	        FROM
	            pg_catalog.pg_roles as roles
	        WHERE
	            rolname = current_user
2023-12-10 14:49:53.026 PST [37277] LOG:  statement: SELECT n.nspname, r.relname
	FROM pg_catalog.pg_class r
	    LEFT JOIN pg_catalog.pg_namespace n ON (r.relnamespace = n.oid)
	WHERE r.oid = 16667;
	
2023-12-10 14:49:53.137 PST [37277] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:49:53.162 PST [37277] LOG:  statement: SELECT at.attname, at.attnum, ty.typname
	FROM pg_catalog.pg_attribute at LEFT JOIN pg_catalog.pg_type ty ON (ty.oid = at.atttypid)
	JOIN pg_catalog.pg_class as cl ON cl.oid=AT.attrelid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=cl.relnamespace
	WHERE
	    cl.relname = 'ratings' AND nsp.nspname='public' AND
	attnum = ANY (
	(SELECT con.conkey FROM pg_catalog.pg_class rel LEFT OUTER JOIN pg_catalog.pg_constraint con ON con.conrelid=rel.oid
	JOIN pg_catalog.pg_namespace as nsp ON nsp.oid=REL.relnamespace
	AND con.contype='p' WHERE rel.relkind IN ('r','s','t', 'p') AND
	    rel.relname = 'ratings' AND nsp.nspname='public'
	)::oid[])
2023-12-10 14:49:53.165 PST [37407] LOG:  statement: SELECT * FROM public.ratings
	ORDER BY id ASC 
2023-12-10 14:49:53.257 PST [37407] LOG:  statement: SELECT DISTINCT att.attname as name, att.attnum as OID, pg_catalog.format_type(ty.oid,NULL) AS datatype,
	att.attnotnull as not_null, att.atthasdef as has_default_val, des.description, seq.seqtypid
	FROM pg_catalog.pg_attribute att
	    JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
	    JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
	    JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
	    JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
	    LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
	    LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON classid='pg_class'::regclass AND objid=cs.oid AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
	    LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
	    LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
	    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
	    LEFT OUTER JOIN pg_catalog.pg_sequence seq ON cs.oid=seq.seqrelid
	WHERE
	
	    att.attrelid = 16667::oid
	    AND att.attnum > 0
	    AND att.attisdropped IS FALSE
	ORDER BY att.attnum
2023-12-10 14:49:53.267 PST [37407] LOG:  execute <unnamed>: SELECT oid, pg_catalog.format_type(oid, NULL) AS typname FROM pg_catalog.pg_type WHERE oid = ANY($1) ORDER BY oid;
2023-12-10 14:49:53.267 PST [37407] DETAIL:  parameters: $1 = '{23,23,1700,1700,1043}'
2023-12-10 14:49:56.050 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:50:25.357 PST [37433] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:50:25.357 PST [37433] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 14:50:28.504 PST [37438] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:50:28.505 PST [37438] LOG:  statement: SELECT name, ratings FROM ratings
2023-12-10 14:51:35.213 PST [36662] LOG:  checkpoint complete: wrote 984 buffers (6.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=99.133 s, sync=0.019 s, total=99.164 s; sync files=15, longest=0.011 s, average=0.002 s; distance=9289 kB, estimate=9289 kB
2023-12-10 14:51:48.862 PST [37488] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:51:48.862 PST [37488] LOG:  statement: SELECT name, ratings FROM ratings
2023-12-10 14:51:50.147 PST [37490] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:51:50.147 PST [37490] LOG:  statement: SELECT name, ratings FROM ratings
2023-12-10 14:52:22.646 PST [37509] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:22.646 PST [37509] LOG:  statement: SELECT name, ratings FROM ratings
2023-12-10 14:52:39.458 PST [37535] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:39.461 PST [37535] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 14:52:39.461 PST [37535] DETAIL:  parameters: $1 = '2'
2023-12-10 14:52:45.571 PST [37540] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:45.575 PST [37540] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:52:45.575 PST [37540] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:52:45.581 PST [37541] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:45.581 PST [37541] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 14:52:45.592 PST [37542] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:45.593 PST [37542] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:52:45.593 PST [37542] DETAIL:  parameters: $1 = '35', $2 = 'Ashunti`Way Smoothie', $3 = '1', $4 = '5.49', $5 = '2'
2023-12-10 14:52:45.594 PST [37542] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:52:45.594 PST [37542] DETAIL:  parameters: $1 = '35', $2 = 'Tejay Impact Smoothie', $3 = '1', $4 = '5.49', $5 = '2'
2023-12-10 14:52:45.594 PST [37542] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:52:45.610 PST [37543] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:45.612 PST [37543] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 14:52:45.612 PST [37543] DETAIL:  parameters: $1 = '35'
2023-12-10 14:52:45.613 PST [37543] LOG:  execute <unnamed>: INSERT INTO orders (user_id,order_total,order_id) VALUES ($1, $2, $3)
2023-12-10 14:52:45.613 PST [37543] DETAIL:  parameters: $1 = '2', $2 = '10.98', $3 = '35'
2023-12-10 14:52:45.616 PST [37543] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:52:54.177 PST [37551] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:54.179 PST [37551] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:52:54.179 PST [37551] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:52:54.187 PST [37552] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:52:54.190 PST [37552] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 14:52:54.190 PST [37552] DETAIL:  parameters: $1 = '2', $2 = 'fagahs', $3 = '123242'
2023-12-10 14:52:54.195 PST [37552] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:53:03.125 PST [37558] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:03.126 PST [37558] LOG:  statement: SELECT id, name FROM restaurants limit 1000
2023-12-10 14:53:06.171 PST [37563] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:06.173 PST [37563] LOG:  execute <unnamed>: SELECT id, name, price FROM menus WHERE restaurant_id = $1
2023-12-10 14:53:06.173 PST [37563] DETAIL:  parameters: $1 = '2'
2023-12-10 14:53:09.232 PST [37567] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:09.234 PST [37567] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:53:09.234 PST [37567] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:53:09.240 PST [37568] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:09.240 PST [37568] LOG:  statement: SELECT MAX(id) FROM menu_items
2023-12-10 14:53:09.246 PST [37569] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:09.247 PST [37569] LOG:  execute <unnamed>: INSERT INTO menu_items (id, item_name, qty, price, user_id) VALUES ($1, $2, $3, $4, $5)
2023-12-10 14:53:09.247 PST [37569] DETAIL:  parameters: $1 = '36', $2 = 'Jimmy Jam Smoothie', $3 = '1', $4 = '5.49', $5 = '2'
2023-12-10 14:53:09.248 PST [37569] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:53:09.260 PST [37570] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:09.262 PST [37570] LOG:  execute <unnamed>: SELECT item_name, qty, price, user_id FROM menu_items WHERE id = $1
2023-12-10 14:53:09.262 PST [37570] DETAIL:  parameters: $1 = '36'
2023-12-10 14:53:09.262 PST [37570] LOG:  execute <unnamed>: INSERT INTO orders (user_id,order_total,order_id) VALUES ($1, $2, $3)
2023-12-10 14:53:09.262 PST [37570] DETAIL:  parameters: $1 = '2', $2 = '5.49', $3 = '36'
2023-12-10 14:53:09.263 PST [37570] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:53:15.396 PST [37575] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:15.399 PST [37575] LOG:  execute <unnamed>: SELECT user_id FROM users WHERE username = $1
2023-12-10 14:53:15.399 PST [37575] DETAIL:  parameters: $1 = 'ayaan'
2023-12-10 14:53:15.406 PST [37576] LOG:  execute <unnamed>: BEGIN
2023-12-10 14:53:15.408 PST [37576] LOG:  execute <unnamed>: INSERT INTO address (user_id, street, pincode) VALUES ($1, $2, $3)
2023-12-10 14:53:15.408 PST [37576] DETAIL:  parameters: $1 = '2', $2 = 'sss', $3 = '1233'
2023-12-10 14:53:15.410 PST [37576] LOG:  execute <unnamed>: COMMIT
2023-12-10 14:54:56.214 PST [36662] LOG:  checkpoint starting: time
2023-12-10 14:54:57.063 PST [36662] LOG:  checkpoint complete: wrote 9 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.830 s, sync=0.009 s, total=0.850 s; sync files=9, longest=0.006 s, average=0.001 s; distance=4 kB, estimate=8361 kB
2023-12-10 14:55:46.193 PST [37666] LOG:  statement: SELECT datname FROM pg_database WHERE datallowconn ORDER BY LOWER(datname)
